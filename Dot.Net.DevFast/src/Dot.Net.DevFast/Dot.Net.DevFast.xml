<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Dot.Net.DevFast</name>
    </assembly>
    <members>
        <member name="T:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1">
            <summary>
            Abstract binary heap implementation.
            </summary>
            <typeparam name="T">Heap element type</typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.#ctor(System.Int32)">
            <summary>
            Ctor with initial heap capacity.
            </summary>
            <param name="initialCapacity">Initial capacity of the heap.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When given capacity is negative.</exception>
        </member>
        <member name="P:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.IsEmpty">
            <inheritdoc />
        </member>
        <member name="P:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.IsFull">
            <inheritdoc />
        </member>
        <member name="P:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.Capacity">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.Peek">
            <summary>
            Returns the first element of the heap without removing it from the heap.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">When the heap is empty.</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.TryPeek(`0@)">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.Pop">
            <summary>
            Removes and returns the first element from the heap.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">When the heap is empty.</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.TryPop(`0@)">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.Add(`0)">
            <summary>
            Adds given element to the heap.
            </summary>
            <param name="item">Element to add</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When element cannot be added.</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.TryAdd(`0)">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.PopAll">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.Compact">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.GetFirstUnsafe">
            <summary>
            Its an unsafe getter. !!! Does not check for the presence of the element
            at 0th index. !!!
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.EnsureCapacity">
            <summary>
            Ensures that there is a capacity to add an element.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.InternalCopyData(System.Int32)">
            <summary>
            Replaces the internal array with a new array of a given <paramref name="size"/>.
            </summary>
            <param name="size">Size of the new array.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When the given size is less than current count.</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.LeftPrecedes(`0,`0)">
            <summary>
            Returns the truth value whether given <paramref name="left"/> element precedes
            compared to given <paramref name="right"/> element, in assumed sorted order (i.e. if
            we start popping out elements from heap, whether element provided as <paramref name="left"/> must
            be popped out before the element provided as <paramref name="right"/>).
            </summary>
            <param name="left">Left element</param>
            <param name="right">Right element</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.All">
            <inheritdoc/>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractBinaryHeap`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:Dot.Net.DevFast.Collections.AbstractSizableBinaryHeap`1">
            <summary>
            Sizable binary heap abstract implementation.
            Think of it as HeapBuilder (similar to StringBuilder) when
            final size of the heap is not known in advance (e.g. data coming from db, network etc).
            Once construction is done, capacity can be frozen, with ot without compaction.
            </summary>
            <typeparam name="T">Heap type</typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractSizableBinaryHeap`1.#ctor(System.Int32)">
            <summary>
            Ctor with initial capacity. <seealso cref="T:Dot.Net.DevFast.Collections.HeapNoResizing"/> is used as sizing strategy.
            </summary>
            <param name="initialCapacity">Initial capacity of the heap</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When given capacity is negative.</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractSizableBinaryHeap`1.#ctor(System.Int32,Dot.Net.DevFast.Collections.Interfaces.IResizeStrategy)">
            <summary>
            Ctor with initial capacity and resizing strategy.
            Different in-built resizing strategy are available (<seealso cref="T:Dot.Net.DevFast.Collections.HeapNoResizing"/>, <seealso cref="T:Dot.Net.DevFast.Collections.StepHeapResizing"/>
            and <seealso cref="T:Dot.Net.DevFast.Collections.PercentHeapResizing"/>).
            </summary>
            <param name="initialCapacity">Initial capacity of the heap</param>
            <param name="resizeStrategy">Heap resizing strategy.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When given capacity is negative or resizing strategy is not provided.</exception>
        </member>
        <member name="P:Dot.Net.DevFast.Collections.AbstractSizableBinaryHeap`1.CanResize">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractSizableBinaryHeap`1.FreezeCapacity(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractSizableBinaryHeap`1.EnsureCapacity">
            <summary>
            Applies resizing strategy when heap is full.
            </summary>
        </member>
        <member name="T:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2">
            <summary>
            Represents a thread-safe collection of key-value pairs that can be accessed by multiple threads concurrently.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2" /> class that is empty and
            has the default initial capacity, has default concurrency level,
            and uses the comparer (if provided else default) for the key type.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2" /> class that is empty and
            has the given initial capacity, has default concurrency level,
            and uses the comparer (if provided else default) for the key type.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2" /> class that
            contains all the items of the provide <paramref name="collection"/> and
            has default concurrency level,
            and uses the comparer (if provided else default) for the key type.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2" /> class that is empty
            and has the given initial capacity, has given concurrency level
            and uses the comparer (if provided else default) for the key type.
            <para>
            NOTE: <paramref name="concurrencyLevel"/> has internal lower bound=2 and upper bound=<see cref="P:System.Environment.ProcessorCount"/>.
            </para>
            </summary>
            <param name="initialCapacity">Initial estimated capacity</param>
            <param name="concurrencyLevel">Concurrency level</param>
            <param name="comparer">Key comparer</param>
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.Count">
            <inheritdoc />
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.IsEmpty">
            <summary>
            Truth value whether collection is empty or not.
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.System#Collections#Generic#IReadOnlyCollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Count">
            <inheritdoc />
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.Clear">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.Clear(System.Boolean)">
            <summary>
            Clear items in the all the partitions.
            </summary>
            <param name="releaseMemory">If <see langword="true"/>, partitions are recreated to release previously allocated memory.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Checks whether given key/value pair is part of current collection using provided <paramref name="valueComparer"/>.
            If <paramref name="valueComparer"/> is <see langword="null" />, then <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>
            will be used.
            </summary>
            <param name="item">Key value pair to check</param>
            <param name="valueComparer">Equality comparer for the value.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Removes the given key/value pair from the collection using provided <paramref name="valueComparer"/>.
            If <paramref name="valueComparer"/> is <see langword="null" />, then <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>
            will be used.
            </summary>
            <param name="item">Key value pair to be removed.</param>
            <param name="valueComparer">Equality comparer for the value.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.TryRemove(`0,`1@)">
            <summary>
            Attempts to remove and return the value that has the specified key.
            </summary>
            <param name="key">The key of the element to remove and return.</param>
            <param name="value">When this method returns, contains the object removed from the collection, or the default value of the <see langword="TValue" /> type if <paramref name="key" /> does not exist.</param>
            <returns><see langword="true" /> if the object was removed successfully; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
            <summary>
            Adds a key/value pair to the collection by using the specified function
            if the key does not already exist.
            Returns the new value, or the existing value if the key exists.</summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key.</param>
            <returns>The value for the key. This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.GetOrAdd(`0,`1)">
            <summary>
            Adds a key/value pair to the collection if the key does not already exist.
            Returns the new value, or the existing value if the key exists.
            </summary>
            <param name="key">Key value.</param>
            <param name="value">Value.</param>
            <returns>The value for the key. This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Adds <paramref name="key"/>/<paramref name="addValue"/> pair to the collection
            if the <paramref name="key"/> does not already exist,
            or updates <paramref name="key"/>/value pair by using <paramref name="updateValueFactory"/> lambda
            if the <paramref name="key"/> already exists.
            </summary>
            <param name="key">The key to be added or updated</param>
            <param name="addValue">The value to be added</param>
            <param name="updateValueFactory">Value generating lambda for an existing key and value</param>
            <param name="comparer">Value comparer. If not provided then default implementation will be used.</param>
            <returns>The new value for the key. This will be either be <paramref name="addValue" /> (if the key was absent) or the result of <paramref name="updateValueFactory" /> (if the key was present).</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.TryUpdate(`0,`1,`1,System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Updates the value associated with <paramref name="key" /> to <paramref name="newValue" />
            if the existing value with <paramref name="key" /> is equal to <paramref name="comparisonValue" />.
            </summary>
            <param name="key">key.</param>
            <param name="newValue">Replacement value.</param>
            <param name="comparisonValue">Value to compare with the existing key value.</param>
            <param name="comparer">Value comparer. If not provided then default implementation will be used.</param>
            <returns><see langword="true" /> if the value with <paramref name="key" /> was equal to <paramref name="comparisonValue" /> and was replaced with <paramref name="newValue" />; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add the specified key and value to the collection.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add.</param>
            <returns> <see langword="true" /> if the key/value pair was added successfully; <see langword="false" /> if the key already exists.</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.Add(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.System#Collections#Generic#IReadOnlyDictionary{TKey,TValue}#ContainsKey(`0)">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.ContainsKey(`0)">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.System#Collections#Generic#IReadOnlyDictionary{TKey,TValue}#TryGetValue(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.TryGetValue(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.Item(`0)">
            <inheritdoc cref="T:System.Collections.Generic.IDictionary`2"/>
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.Keys">
            <inheritdoc />
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.System#Collections#Generic#IReadOnlyDictionary{TKey,TValue}#Keys">
            <inheritdoc />
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.Values">
            <inheritdoc />
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2.System#Collections#Generic#IReadOnlyDictionary{TKey,TValue}#Values">
            <inheritdoc />
        </member>
        <member name="T:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1">
            <summary>
            Lock based implementation of concurrent heap.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.#ctor(Dot.Net.DevFast.Collections.Interfaces.IResizableHeap{`0})">
            <summary>
            Ctor with heap instance.
            </summary>
            <param name="heap">Instance of the heap secure with lock</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When provided instance is null.</exception>
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.IsEmpty">
            <inheritdoc />
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.IsFull">
            <inheritdoc />
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.Capacity">
            <inheritdoc />
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.CanResize">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.Peek">
            <summary>
            Returns the first element of the heap without removing it from the heap.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">When the heap is empty.</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.TryPeek(`0@)">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.Pop">
            <summary>
            Removes and returns the first element from the heap.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">When the heap is empty.</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.TryPop(`0@)">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.Add(`0)">
            <summary>
            Adds given element to the heap.
            </summary>
            <param name="item">Element to add</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When element cannot be added.</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.TryAdd(`0)">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.PopAll">
            <summary>
            Pops all the items (without using snapshot of the current state), i.e.
            during enumeration, all other permutations will be reflected.
            Though it is safe to call this method several times concurrently, each enumeration
            will only receive the part of the state (dependents on the exact state of the heap at runtime). Hence,
            order is guaranteed, in absence of concurrent adding, otherwise not.
            In effect, if only single call of this method is running without any other permutation
            to its state (like no other add, pop is called concurrently),
            then the output will be the enumeration of all the elements in the correct order.
            Finally, if only concurrent pops are running (without any concurrent adding), then order
            is still guaranteed but not the sequence pattern.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.PopAllConsistent">
            <summary>
            Complementary to <see cref="M:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.PopAll"/>. It extracts all the elements based on
            current state of the heap.
            <para>
            CAREFUL: As the method returns <seealso cref="T:System.Collections.Generic.List`1"/> (instead of <seealso cref="T:System.Collections.Generic.IEnumerable`1"/>),
            it will allocate memory. For large heap, this can lead to latency and memory consumption.
            </para>
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds all the items (using snapshot of the current state) to the heap, i.e.
            during enumeration, all elements will be added based on the state that was captured.
            And, it is also safe to call this method several times concurrently, each enumeration
            will add elements to heap based on its runtime state. Nonetheless, for the whole duration of the enumeration,
            the underlying head wont be usable and all other operations will block. If the supplied enumeration is slow
            to execute and/or time consuming otherwise, AVOID this method and instead use <see cref="M:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.Add(`0)"/>.
            Finally, order and elements' sequencing, both, are guaranteed, in absence of concurrent pops, otherwise not.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.Compact">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.FreezeCapacity(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.All">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.LockBasedConcurrentHeap`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Dot.Net.DevFast.Collections.Concurrent.ConcurrentMinHeap`1">
            <summary>
            Lock based Binary Min Heap implementation.
            </summary>
            <typeparam name="T">Heap type</typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.ConcurrentMinHeap`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0},Dot.Net.DevFast.Collections.Interfaces.IResizeStrategy)">
            <summary>
            Ctor with initial capacity, comparer and resizing strategy.
            Different in-built resizing strategy are available (<seealso cref="T:Dot.Net.DevFast.Collections.HeapNoResizing"/>, <seealso cref="T:Dot.Net.DevFast.Collections.StepHeapResizing"/>
            and <seealso cref="T:Dot.Net.DevFast.Collections.PercentHeapResizing"/>).
            </summary>
            <param name="initialCapacity">Initial capacity of the heap</param>
            <param name="comparer">Comparer instance. If not provided, then <seealso cref="P:System.Collections.Generic.Comparer`1.Default"/> will be used.</param>
            <param name="resizeStrategy">Heap resizing strategy. If not provided, then <seealso cref="T:Dot.Net.DevFast.Collections.HeapNoResizing"/> will be internally used.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When given capacity is negative.</exception>
        </member>
        <member name="T:Dot.Net.DevFast.Collections.Concurrent.ConcurrentMaxHeap`1">
            <summary>
            Lock based Binary Max Heap implementation.
            </summary>
            <typeparam name="T">Heap type which also implements <seealso cref="T:System.IComparable`1"/></typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Concurrent.ConcurrentMaxHeap`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0},Dot.Net.DevFast.Collections.Interfaces.IResizeStrategy)">
            <summary>
            Ctor with initial capacity, comparer and resizing strategy.
            Different in-built resizing strategy are available (<seealso cref="T:Dot.Net.DevFast.Collections.HeapNoResizing"/>, <seealso cref="T:Dot.Net.DevFast.Collections.StepHeapResizing"/>
            and <seealso cref="T:Dot.Net.DevFast.Collections.PercentHeapResizing"/>).
            </summary>
            <param name="initialCapacity">Initial capacity of the heap</param>
            <param name="comparer">Comparer instance. If not provided, then <seealso cref="P:System.Collections.Generic.Comparer`1.Default"/> will be used.</param>
            <param name="resizeStrategy">Heap resizing strategy. If not provided, then <seealso cref="T:Dot.Net.DevFast.Collections.HeapNoResizing"/> will be internally used.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When given capacity is negative.</exception>
        </member>
        <member name="T:Dot.Net.DevFast.Collections.Interfaces.ICompactAbleHeap">
            <summary>
            Interface to declare compaction contract.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Interfaces.ICompactAbleHeap.Compact">
            <summary>
            Internally allocated storage will be compacted to match the current usage.
            </summary>
        </member>
        <member name="T:Dot.Net.DevFast.Collections.Interfaces.IHeap`1">
            <summary>
            Heap data structure interface.
            </summary>
            <typeparam name="T">Heap element type</typeparam>
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Interfaces.IHeap`1.IsEmpty">
            <summary>
            Gets the truth value whether the heap is empty or not.
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Interfaces.IHeap`1.IsFull">
            <summary>
            Gets the truth value whether the heap is full or not.
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Interfaces.IHeap`1.Count">
            <summary>
            Current count of the elements in the heap.
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Interfaces.IHeap`1.Capacity">
            <summary>
            Current capacity of the heap.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Interfaces.IHeap`1.Peek">
            <summary>
            Returns the first element of the heap without removing it from the heap.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Interfaces.IHeap`1.TryPeek(`0@)">
            <summary>
            Returns the truth value whether heap contains at least one (1) item and outs the first element of the heap
            without removing it from the heap.
            </summary>
            <param name="item">out element</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Interfaces.IHeap`1.Pop">
            <summary>
            Removes and returns the first element from the heap.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Interfaces.IHeap`1.TryPop(`0@)">
            <summary>
            Returns the truth value whether the first heap element was successfully removed
            and outs that element.
            </summary>
            <param name="item">out element</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Interfaces.IHeap`1.Add(`0)">
            <summary>
            Adds given element to the heap.
            </summary>
            <param name="item">Element to add</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Interfaces.IHeap`1.TryAdd(`0)">
            <summary>
            Tries adding given element in the heap.
            Returns the truth value whether it was successfully added or not.
            </summary>
            <param name="item">Element to add.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Interfaces.IHeap`1.PopAll">
            <summary>
            Removes all the elements from the heap.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Interfaces.IHeap`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds all elements of the given enumeration to the heap.
            Returns the count of the elements that were successfully added.
            </summary>
            <param name="items">Enumeration of the Elements to add.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Interfaces.IHeap`1.All">
            <summary>
            Returns a copy of the internal collection without removing elements from it.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Dot.Net.DevFast.Collections.Interfaces.IResizableHeap`1">
            <summary>
            Interface to declare resizing operations contract.
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Interfaces.IResizableHeap`1.CanResize">
            <summary>
            Gets the current truth value whether resizing is possible or not.
            <para>
            NOTE: After calling <see cref="M:Dot.Net.DevFast.Collections.Interfaces.IResizableHeap`1.FreezeCapacity(System.Boolean)"/>, it will always return false.
            </para>
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Interfaces.IResizableHeap`1.FreezeCapacity(System.Boolean)">
            <summary>
            Calling this method will freeze the capacity (i.e. heap will not resize upon add).
            Also, runs compaction on the internally allocated storage based on <paramref name="compact"/> flag.
            </summary>
            <param name="compact">If true, internally allocated storage will be compacted.</param>
        </member>
        <member name="T:Dot.Net.DevFast.Collections.Interfaces.IResizeStrategy">
            <summary>
            Interface exposing sizing strategy for the binary heap.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.Interfaces.IResizeStrategy.TryComputeNewSize(System.Int32,System.Int32@)">
            <summary>
            Calculates the new size of the heap, based on the given value of current size.
            </summary>
            <param name="currentSize">Current size of the heap</param>
            <param name="newSize">New size</param>
        </member>
        <member name="P:Dot.Net.DevFast.Collections.Interfaces.IResizeStrategy.CanResize">
            <summary>
            Gets the truth value whether new size can be computed.
            </summary>
        </member>
        <member name="T:Dot.Net.DevFast.Collections.AbstractLimitHeap`1">
            <summary>
            Binary heap based limited element abstract heap, i.e. k-heap on N elements.
            That means unlimited of elements (N) can be added, but, only limited number of elements (k) can be popped out.
            It will maintain heap state on the added elements (before each pop) without consuming extra space.
            <example>
            When among long list of numbers, but we are interested to find only HIGHEST/LOWEST k
            elements, this abstract class is the right choice.
            </example>
            </summary>
            <typeparam name="T">Element type</typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractLimitHeap`1.#ctor(System.Int32)">
            <summary>
            Ctor with heap size, i.e. total number of elements to keep.
            </summary>
            <param name="heapSize">Total top elements to keep</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When supplied size is less than 1</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractLimitHeap`1.TryAdd(`0)">
            <summary>
            It ALWAYS returns true. Prefer using the overload <see cref="M:Dot.Net.DevFast.Collections.AbstractLimitHeap`1.TryAdd(`0,`0@)"/>.
            </summary>
            <param name="item">Item to add</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.AbstractLimitHeap`1.TryAdd(`0,`0@)">
            <summary>
            Returns false, if item has been added without replacing existing item
            or the given item cannot be added (not part of k-heap).
            When returns true, also outs the item that was popped (removed) from heap to
            keep the given item.
            </summary>
            <param name="item">Item to add</param>
            <param name="popped">Popped item, if any, that added item has been replaced with</param>
        </member>
        <member name="T:Dot.Net.DevFast.Collections.MinLimitHeap`1">
            <summary>
            Binary heap based limited element min heap, i.e. k-min heap on N elements.
            That means unlimited of elements (N) can be added, but, only limited number of elements (k) can be popped out.
            It will maintain heap state on the added elements (before each pop) without consuming extra space.
            <example>
            When among long list of numbers, but we are interested to find only LOWEST k
            elements, this abstract class is the right choice.
            </example>
            <para>
            NOTE: During pop, order is NOT guaranteed, however, it should NOT matter.
            </para>
            </summary>
            <typeparam name="T">Element type</typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.MinLimitHeap`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Ctor with heap size, i.e. total number of elements to keep, and comparer instance.
            </summary>
            <param name="heapSize">Total top elements to keep</param>
            <param name="comparer">Comparer instance. If not provided, then <seealso cref="P:System.Collections.Generic.Comparer`1.Default"/> will be used.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When supplied size is less than 1</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.MinLimitHeap`1.LeftPrecedes(`0,`0)">
            <inheritdoc />
        </member>
        <member name="T:Dot.Net.DevFast.Collections.MaxLimitHeap`1">
            <summary>
            Binary heap based limited element min heap, i.e. k-max heap on N elements.
            That means unlimited of elements (N) can be added, but, only limited number of elements (k) can be popped out.
            It will maintain heap state on the added elements (before each pop) without consuming extra space.
            <example>
            When among long list of numbers, but we are interested to find only HIGHEST k
            elements, this class is the right choice.
            </example>
            <para>
            NOTE: During pop, order is NOT guaranteed, however, it should NOT matter.
            </para>
            </summary>
            <typeparam name="T">Element type</typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.MaxLimitHeap`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Ctor with heap size, i.e. total number of elements to keep, and comparer instance.
            </summary>
            <param name="heapSize">Total top elements to keep</param>
            <param name="comparer">Comparer instance. If not provided, then <seealso cref="P:System.Collections.Generic.Comparer`1.Default"/> will be used.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When supplied size is less than 1</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.MaxLimitHeap`1.LeftPrecedes(`0,`0)">
            <inheritdoc />
        </member>
        <member name="T:Dot.Net.DevFast.Collections.MinHeap`1">
            <summary>
            Implementation of Binary Min Heap.
            </summary>
            <typeparam name="T">Heap type</typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.MinHeap`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0},Dot.Net.DevFast.Collections.Interfaces.IResizeStrategy)">
            <summary>
            Ctor with initial capacity, comparer and resizing strategy.
            Different in-built resizing strategy are available (<seealso cref="T:Dot.Net.DevFast.Collections.HeapNoResizing"/>, <seealso cref="T:Dot.Net.DevFast.Collections.StepHeapResizing"/>
            and <seealso cref="T:Dot.Net.DevFast.Collections.PercentHeapResizing"/>).
            </summary>
            <param name="initialCapacity">Initial capacity of the heap</param>
            <param name="comparer">Comparer instance. If not provided, then <seealso cref="P:System.Collections.Generic.Comparer`1.Default"/> will be used.</param>
            <param name="resizeStrategy">Heap resizing strategy. If not provided, then <seealso cref="T:Dot.Net.DevFast.Collections.HeapNoResizing"/> will be internally used.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When given capacity is negative.</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.MinHeap`1.LeftPrecedes(`0,`0)">
            <summary>
            Return true when left is less than compared to its right.
            </summary>
            <param name="left">Left hand element</param>
            <param name="right">Right hand element</param>
        </member>
        <member name="T:Dot.Net.DevFast.Collections.MaxHeap`1">
            <summary>
            Implementation of Binary Max Heap.
            </summary>
            <typeparam name="T">Heap type which also implements <seealso cref="T:System.IComparable`1"/></typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.MaxHeap`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0},Dot.Net.DevFast.Collections.Interfaces.IResizeStrategy)">
            <summary>
            Ctor with initial capacity, comparer and resizing strategy.
            Different in-built resizing strategy are available (<seealso cref="T:Dot.Net.DevFast.Collections.HeapNoResizing"/>, <seealso cref="T:Dot.Net.DevFast.Collections.StepHeapResizing"/>
            and <seealso cref="T:Dot.Net.DevFast.Collections.PercentHeapResizing"/>).
            </summary>
            <param name="initialCapacity">Initial capacity of the heap</param>
            <param name="comparer">Comparer instance. If not provided, then <seealso cref="P:System.Collections.Generic.Comparer`1.Default"/> will be used.</param>
            <param name="resizeStrategy">Heap resizing strategy. If not provided, then <seealso cref="T:Dot.Net.DevFast.Collections.HeapNoResizing"/> will be internally used.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When given capacity is negative.</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.MaxHeap`1.LeftPrecedes(`0,`0)">
            <summary>
            Return true when left is greater than compared to its right.
            </summary>
            <param name="left">Left hand element</param>
            <param name="right">Right hand element</param>
        </member>
        <member name="T:Dot.Net.DevFast.Collections.OneToManyDictionary`2">
            <inheritdoc cref="T:System.Collections.Generic.Dictionary`2"/>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.OneToManyDictionary`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Dot.Net.DevFast.Collections.OneToManyDictionary`2" /> class that is empty, has the specified initial capacity, and uses the default equality comparer for the key type.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.OneToManyDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Dot.Net.DevFast.Collections.OneToManyDictionary`2" /> class that is empty, has the default initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the key.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.OneToManyDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Dot.Net.DevFast.Collections.OneToManyDictionary`2" /> class that is empty, has the specified initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.
            </summary>
            <param name="capacity">The initial number of elements that the <see cref="T:System.Collections.Generic.OneToManyDictionary`2" /> can contain.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the key.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.OneToManyDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Tuple{`0,System.Collections.Generic.List{`1}}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Dot.Net.DevFast.Collections.OneToManyDictionary`2" /> class that contains elements copied from the specified <see cref="T:System.Collections.Generic.IDictionary`2" /> and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
            <param name="collection">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are copied.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the key.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.OneToManyDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.List{`1}}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Dot.Net.DevFast.Collections.OneToManyDictionary`2" /> class that contains elements copied from the specified <see cref="T:System.Collections.Generic.IDictionary`2" /> and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
            <param name="collection">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are copied.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the key.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.OneToManyDictionary`2.Add(`0,`1)">
            <summary>
            Add the provide <paramref name="value"/> to the associated <see cref="T:System.Collections.Generic.List`1"/> when <paramref name="key"/> is found;
            otherwise, creates a new <see cref="T:System.Collections.Generic.List`1"/> with <paramref name="value"/> in it and adds the key-value pair.
            </summary>
            <param name="key">Key instance</param>
            <param name="value">Value instance</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.OneToManyDictionary`2.Contains(`0,`1)">
            <summary>
            Checks if the given <paramref name="key"/> exists and <paramref name="value"/> is part of associated key list.
            </summary>
            <param name="key">Key instance</param>
            <param name="value">Value instance</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.OneToManyDictionary`2.Remove(`0,`1)">
            <summary>
            Remove the <paramref name="value"/> if the <paramref name="key"/> exists and <paramref name="value"/> is inside the associated <see cref="T:System.Collections.Generic.List`1"/>.
            It also removes the <paramref name="key"/>, if the resultant list is empty.
            </summary>
            <param name="key">Key instance</param>
            <param name="value">Value instance</param>
        </member>
        <member name="T:Dot.Net.DevFast.Collections.OneToUniqueManyDictionary`2">
            <inheritdoc cref="T:System.Collections.Generic.Dictionary`2"/>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.OneToUniqueManyDictionary`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Dot.Net.DevFast.Collections.OneToManyDictionary`2" /> class that is empty, has the specified initial capacity, and uses the default equality comparer for the key type.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.OneToUniqueManyDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Dot.Net.DevFast.Collections.OneToManyDictionary`2" /> class that is empty, has the default initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the key.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.OneToUniqueManyDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Dot.Net.DevFast.Collections.OneToManyDictionary`2" /> class that is empty, has the specified initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.
            </summary>
            <param name="capacity">The initial number of elements that the <see cref="T:System.Collections.Generic.OneToManyDictionary`2" /> can contain.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the key.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.OneToUniqueManyDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Tuple{`0,System.Collections.Generic.HashSet{`1}}},System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Dot.Net.DevFast.Collections.OneToManyDictionary`2" /> class that contains elements copied from the specified <see cref="T:System.Collections.Generic.IDictionary`2" /> and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
            <param name="collection">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are copied.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the key.</param>
            <param name="valueComparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the value.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.OneToUniqueManyDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.HashSet{`1}}},System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Dot.Net.DevFast.Collections.OneToManyDictionary`2" /> class that contains elements copied from the specified <see cref="T:System.Collections.Generic.IDictionary`2" /> and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
            <param name="collection">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are copied.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the key.</param>
            <param name="valueComparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the value.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.OneToUniqueManyDictionary`2.Add(`0,`1,System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Add the provide <paramref name="value"/> to the associated <see cref="T:System.Collections.Generic.HashSet`1"/> when <paramref name="key"/> is found;
            otherwise, creates a new <see cref="T:System.Collections.Generic.HashSet`1"/> with <paramref name="value"/> in it and adds the key-value pair.
            </summary>
            <param name="key">Key instance</param>
            <param name="value">Value instance</param>
            <param name="valueComparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the value.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.OneToUniqueManyDictionary`2.Contains(`0,`1)">
            <summary>
            Checks if the given <paramref name="key"/> exists and <paramref name="value"/> is part of associated key set.
            </summary>
            <param name="key">Key instance</param>
            <param name="value">Value instance</param>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.OneToUniqueManyDictionary`2.Remove(`0,`1)">
            <summary>
            Remove the <paramref name="value"/> if the <paramref name="key"/> exists and <paramref name="value"/> is inside the associated <see cref="T:System.Collections.Generic.HashSet`1"/>.
            It also removes the <paramref name="key"/>, if the resultant set is empty.
            </summary>
            <param name="key">Key instance</param>
            <param name="value">Value instance</param>
        </member>
        <member name="T:Dot.Net.DevFast.Collections.HeapNoResizing">
            <inheritdoc />
            <summary>
            Simply throws exception saying heap initially created supposed to have fixed capacity.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.HeapNoResizing.TryComputeNewSize(System.Int32,System.Int32@)">
            <summary>
            Calling this method will always returns false.
            </summary>
            <param name="currentSize">Current size of the heap</param>
            <param name="newSize">Always outs Default int value</param>
        </member>
        <member name="P:Dot.Net.DevFast.Collections.HeapNoResizing.CanResize">
            <inheritdoc />
        </member>
        <member name="T:Dot.Net.DevFast.Collections.StepHeapResizing">
            <inheritdoc />
            <summary>
            Increases size of the heap in a fixed size steps.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.StepHeapResizing.#ctor(System.Int32)">
            <summary>
            Ctor with step size.
            </summary>
            <param name="stepSize">Step size for the increments.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When step size is zero (0) or negative.</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.StepHeapResizing.TryComputeNewSize(System.Int32,System.Int32@)">
            <summary>
            New size is simply the sum of the initial fixed step size and current capacity.
            Returns false in case of overflow.
            </summary>
            <param name="currentSize">Current size of the heap</param>
            <param name="newSize">outs new size</param>
        </member>
        <member name="P:Dot.Net.DevFast.Collections.StepHeapResizing.CanResize">
            <inheritdoc />
        </member>
        <member name="T:Dot.Net.DevFast.Collections.PercentHeapResizing">
            <inheritdoc />
            <summary>
            Increases size of the heap by given percentage.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.PercentHeapResizing.#ctor(System.Int32)">
            <summary>
            Ctor with increment percentage.
            <para>
            Value 100 means new value will be increased by 100 percent (i.e. double).
            Similarly 50 means value will be multiplied by 1.5 (cast to int).
            </para>
            <para>
            IMPORTANT: If the percent increase (after int cast) yield no increase, then value
            will be increased by 1.
            </para>
            </summary>
            <param name="incrementPercentage">Percentage to use.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When given percentage is zero (0) or negative.</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Collections.PercentHeapResizing.TryComputeNewSize(System.Int32,System.Int32@)">
            <summary>
            New size is multiplier increased (int cast), with lower bound to <paramref name="currentSize"/>+1.
            Returns false in case of overflow.
            </summary>
            <param name="currentSize">Current size of the heap</param>
            <param name="newSize">outs new size</param>
        </member>
        <member name="P:Dot.Net.DevFast.Collections.PercentHeapResizing.CanResize">
            <inheritdoc />
        </member>
        <member name="T:Dot.Net.DevFast.Etc.ConcurrentBuffer">
            <summary>
            Parallel buffer related standard values and methods.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.StandardSize">
            <summary>
            Standard buffer size.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.MinSize">
            <summary>
            Minimum buffer size.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded">
            <summary>
            Unbounded buffer size.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Etc.ConcurrentBuffer.CreateBuffer``1(System.Int32)">
            <summary>
            Created blocking collection with given buffer size.
            NOTE: <see cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded"/> is a special number to create unbounded buffer.
            </summary>
            <typeparam name="T">Collection type</typeparam>
            <param name="bufferSize">Size of buffer.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When given size is negative</exception>
        </member>
        <member name="T:Dot.Net.DevFast.Etc.DdnDfErrorCode">
            <summary>
            Enum Error codes associated with <seealso cref="T:Dot.Net.DevFast.Etc.DdnDfException"/>
            for DevFast project.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.Unspecified">
            <summary>
            Unspecified code, when the exception is created by using 
            its default Ctor.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.NullString">
            <summary>
            String instance is null
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.NullOrEmptyCollection">
            <summary>
            When the supplied collection is null or empty.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.KeyNotFound">
            <summary>
            When supplied array is a null instance.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotInCollection">
            <summary>
            When supplied array is has no element.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.NullObject">
            <summary>
            When supplied object instance is null.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueLessThanThreshold">
            <summary>
            When given comparable value is less than threshold.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueGreaterThanThreshold">
            <summary>
            When given comparable value is greater than threshold.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueOutOfBound">
            <summary>
            When given comparable value is out of lower and upper bound.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueInBound">
            <summary>
            When given comparable value is within lower and upper bound.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual">
            <summary>
            When given comparable value is equal to comperand.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual">
            <summary>
            When given comparable value is NOT equal to comperand.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed">
            <summary>
            When string parsing to a given type fails.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.JsonIsNotAnArray">
            <summary>
            When json does NOT start with start-array token
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.UnableToGetMemoryStreamBuffer">
            <summary>
            When unable to retrieve buffer of memory stream
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.EmptyOrWhiteSpacedString">
            <summary>
            String instance is either null, empty or contains only whitespaces
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.DemandUnfulfilled">
            <summary>
            When asked operation cannot be performed.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.OverAllocationDemanded">
            <summary>
            When allocation requires more memory than specified.
            </summary>
        </member>
        <member name="T:Dot.Net.DevFast.Etc.DdnDfException">
            <summary>
            Exceptions used inside DevFast library.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Etc.DdnDfException.#ctor(Dot.Net.DevFast.Etc.DdnDfErrorCode)">
            <summary>
            Ctor.
            </summary>
            <param name="errorCode">Associated Error code</param>
        </member>
        <member name="M:Dot.Net.DevFast.Etc.DdnDfException.#ctor(Dot.Net.DevFast.Etc.DdnDfErrorCode,System.String)">
            <summary>
            Ctor.
            </summary>
            <param name="errorCode">Associated Error code</param>
            <param name="message">message text</param>
        </member>
        <member name="M:Dot.Net.DevFast.Etc.DdnDfException.#ctor(Dot.Net.DevFast.Etc.DdnDfErrorCode,System.String,System.Exception)">
            <summary>
            Ctor.
            </summary>
            <param name="errorCode">Associated Error code</param>
            <param name="message">message text</param>
            <param name="inner">Inner exception</param>
        </member>
        <member name="M:Dot.Net.DevFast.Etc.DdnDfException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:Dot.Net.DevFast.Etc.DdnException`1">
            <summary>
            Generic Exception class for Dot.Net libraries.
            <para>All libraries must throw this exception for known error cases.</para>
            <typeparam name="T">Normally should be ENUM type explaining the cause behind the exception</typeparam>
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.Etc.DdnException`1.ErrorCode">
            <summary>
            Gets the error code associated.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Etc.DdnException`1.#ctor(`0)">
            <summary>
            Ctor.
            </summary>
            <param name="errorCode">Associated Error code</param>
        </member>
        <member name="M:Dot.Net.DevFast.Etc.DdnException`1.#ctor(`0,System.String)">
            <summary>
            Ctor.
            </summary>
            <param name="errorCode">Associated Error code</param>
            <param name="message">message text</param>
        </member>
        <member name="M:Dot.Net.DevFast.Etc.DdnException`1.#ctor(`0,System.String,System.Exception)">
            <summary>
            Ctor.
            </summary>
            <param name="errorCode">Associated Error code</param>
            <param name="message">message text</param>
            <param name="inner">Inner exception</param>
        </member>
        <member name="M:Dot.Net.DevFast.Etc.DdnException`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:Dot.Net.DevFast.Etc.DdnException">
            <summary>
            Non generic base exception class for Dot.Net libraries.
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.Etc.DdnException.Reason">
            <summary>
            Gets the error reason string.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Etc.DdnException.#ctor(System.String)">
            <summary>
            Ctor.
            </summary>
            <param name="reason">Associated Error reason</param>
        </member>
        <member name="M:Dot.Net.DevFast.Etc.DdnException.#ctor(System.String,System.String)">
            <summary>
            Ctor.
            </summary>
            <param name="reason">Associated Error code</param>
            <param name="message">message text</param>
        </member>
        <member name="M:Dot.Net.DevFast.Etc.DdnException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Ctor.
            </summary>
            <param name="reason">Associated Error code</param>
            <param name="message">message text</param>
            <param name="inner">Inner exception</param>
        </member>
        <member name="M:Dot.Net.DevFast.Etc.DdnException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="M:Dot.Net.DevFast.Etc.DdnException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="T:Dot.Net.DevFast.Etc.SortOrder">
            <summary>
            Enumeration related to sorting requirements.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.SortOrder.None">
            <summary>
            Represents no sorting.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.SortOrder.Asc">
            <summary>
            Ascending (lowest to highest) sorting order.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.SortOrder.Desc">
            <summary>
            Descending (highest to lowest) sorting order
            </summary>
        </member>
        <member name="T:Dot.Net.DevFast.Etc.StdLookUps">
            <summary>
            Provides fixed values.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.StdLookUps.ExtSeparator">
            <summary>
            Character used to join fileName and extension.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.StdLookUps.DefaultBufferSize">
            <summary>
            Default Buffer size for stream related operations.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.StdLookUps.DefaultStringBuilderSize">
            <summary>
            Default size for string builder.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.StdLookUps.DefaultFileBufferSize">
            <summary>
            Default Buffer size for file stream related operations.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.StdLookUps.JsonFileExt">
            <summary>
            Extension for json file.
            </summary>
        </member>
        <member name="F:Dot.Net.DevFast.Etc.StdLookUps.ZipFileExt">
            <summary>
            Extension for zip file.
            </summary>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.CompressionExts">
            <summary>
            Data Compression related extensions.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CompressionExts.CompressAsync(System.ArraySegment{System.Byte},System.IO.Stream,System.Boolean,System.Threading.CancellationToken,System.IO.Compression.CompressionLevel,System.Boolean)">
            <summary>
            Using compressor (GZip/Deflate), compresses <paramref name="source"/> data and writes 
            to <paramref name="target"/> with given <paramref name="level"/> while observing 
            <paramref name="token"/> asynchronously.
            </summary>
            <param name="source">Source byte array segment to read data from</param>
            <param name="target">Target data stream to write compressed data to</param>
            <param name="gzip">if true, <seealso cref="T:System.IO.Compression.GZipStream"/> is created else <seealso cref="T:System.IO.Compression.DeflateStream"/>
            is created.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="level">Compression level</param>
            <param name="disposeTarget">If true, <paramref name="target"/> is disposed after the operation.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CompressionExts.CompressAsync(System.Byte[],System.IO.Stream,System.Boolean,System.Threading.CancellationToken,System.IO.Compression.CompressionLevel,System.Boolean)">
            <summary>
            Using compressor (GZip/Deflate), compresses <paramref name="source"/> data and writes 
            to <paramref name="target"/> with given <paramref name="level"/> while observing 
            <paramref name="token"/> asynchronously.
            </summary>
            <param name="source">Source byte array to read data from</param>
            <param name="target">Target data stream to write compressed data to</param>
            <param name="gzip">if true, <seealso cref="T:System.IO.Compression.GZipStream"/> is created else <seealso cref="T:System.IO.Compression.DeflateStream"/>
            is created.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="level">Compression level</param>
            <param name="disposeTarget">If true, <paramref name="target"/> is disposed after the operation.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CompressionExts.CompressAsync(System.IO.Stream,System.IO.Stream,System.Boolean,System.Threading.CancellationToken,System.IO.Compression.CompressionLevel,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Using compressor (GZip/Deflate), compresses <paramref name="source"/> data and writes 
            to <paramref name="target"/> with given <paramref name="level"/> and <paramref name="bufferSize"/>
            while observing <paramref name="token"/> asynchronously.
            </summary>
            <param name="source">Source data stream to read data from</param>
            <param name="target">Target data stream to write compressed data to</param>
            <param name="gzip">if true, <seealso cref="T:System.IO.Compression.GZipStream"/> is created else <seealso cref="T:System.IO.Compression.DeflateStream"/>
            is created.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="level">Compression level</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeSource">If true, <paramref name="source"/> is disposed after the operation.</param>
            <param name="disposeTarget">If true, <paramref name="target"/> is disposed after the operation.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CompressionExts.CompressAsync(System.Text.StringBuilder,System.IO.Stream,System.Boolean,System.Threading.CancellationToken,System.IO.Compression.CompressionLevel,System.Text.Encoding,System.Int32,System.Boolean)">
            <summary>
            Using compressor (GZip/Deflate), compresses <paramref name="source"/> data and writes 
            to <paramref name="target"/> with given <paramref name="enc"/>, <paramref name="level"/> 
            and <paramref name="bufferSize"/> while observing <paramref name="token"/> asynchronously.
            </summary>
            <param name="source">Source string builder to read data from</param>
            <param name="target">Target data stream to write compressed data to</param>
            <param name="gzip">if true, <seealso cref="T:System.IO.Compression.GZipStream"/> is created else <seealso cref="T:System.IO.Compression.DeflateStream"/>
            is created.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="level">Compression level</param>
            <param name="enc">Encoding to use to get string bytes, if not supplied <seealso cref="P:System.Text.Encoding.UTF8"/> is used</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeTarget">If true, <paramref name="target"/> is disposed after the operation.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CompressionExts.CompressAsync(System.String,System.IO.Stream,System.Boolean,System.Threading.CancellationToken,System.IO.Compression.CompressionLevel,System.Text.Encoding,System.Int32,System.Boolean)">
            <summary>
            Using compressor (GZip/Deflate), compresses <paramref name="source"/> data and writes 
            to <paramref name="target"/> with given <paramref name="enc"/>, <paramref name="level"/> 
            and <paramref name="bufferSize"/> while observing <paramref name="token"/> asynchronously.
            </summary>
            <param name="source">Source string to read</param>
            <param name="target">Target data stream to write compressed data to</param>
            <param name="gzip">if true, <seealso cref="T:System.IO.Compression.GZipStream"/> is created else <seealso cref="T:System.IO.Compression.DeflateStream"/>
            is created.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="level">Compression level</param>
            <param name="enc">Encoding to use to get string bytes, if not supplied <seealso cref="P:System.Text.Encoding.UTF8"/> is used</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeTarget">If true, <paramref name="target"/> is disposed after the operation.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CompressionExts.DecompressAsStringAsync(System.IO.Stream,System.Boolean,System.Threading.CancellationToken,System.Text.Encoding,System.Int32,System.Boolean)">
            <summary>
            Using compressor (GZip/Deflate), decompresses <paramref name="source"/> data with given 
            <paramref name="enc"/> and <paramref name="bufferSize"/> while observing <paramref name="token"/> 
            asynchronously.
            </summary>
            <param name="source">Source data stream to read compressed data from</param>
            <param name="gzip">if true, <seealso cref="T:System.IO.Compression.GZipStream"/> is created else <seealso cref="T:System.IO.Compression.DeflateStream"/>
            is created.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="enc">Encoding to use to get string bytes, if not supplied <seealso cref="P:System.Text.Encoding.UTF8"/> is used</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeSource">If true, <paramref name="source"/> is disposed after the operation.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CompressionExts.DecompressAsync(System.IO.Stream,System.Text.StringBuilder,System.Boolean,System.Threading.CancellationToken,System.Text.Encoding,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Using compressor (GZip/Deflate), decompresses <paramref name="source"/> data with given 
            <paramref name="enc"/> and <paramref name="bufferSize"/> while observing <paramref name="token"/> 
            asynchronously.
            </summary>
            <param name="source">Source data stream to read compressed data from</param>
            <param name="target"></param>
            <param name="gzip">if true, <seealso cref="T:System.IO.Compression.GZipStream"/> is created else <seealso cref="T:System.IO.Compression.DeflateStream"/>
            is created.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="enc">Encoding to use to get string bytes, if not supplied <seealso cref="P:System.Text.Encoding.UTF8"/> is used</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeSource">If true, <paramref name="source"/> is disposed after the operation.</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CompressionExts.DecompressAsync(System.IO.Stream,System.IO.Stream,System.Boolean,System.Threading.CancellationToken,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Using compressor (GZip/Deflate), decompresses <paramref name="source"/> data and writes 
            to <paramref name="target"/> with given <paramref name="bufferSize"/>
            while observing <paramref name="token"/> asynchronously.
            </summary>
            <param name="source">Source data stream to read compressed data from</param>
            <param name="target">Target data stream to write decompressed data to</param>
            <param name="gzip">if true, <seealso cref="T:System.IO.Compression.GZipStream"/> is created else <seealso cref="T:System.IO.Compression.DeflateStream"/>
            is created.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeSource">If true, <paramref name="source"/> is disposed after the operation.</param>
            <param name="disposeTarget">If true, <paramref name="target"/> is disposed after the operation.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CompressionExts.DecompressAsync(System.IO.Stream,System.Boolean,System.Threading.CancellationToken,System.Int32,System.Boolean)">
            <summary>
            Using compressor (GZip/Deflate), decompresses <paramref name="source"/> data with given
            <paramref name="bufferSize"/> while observing <paramref name="token"/> asynchronously.
            </summary>
            <param name="source">Source data stream to read compressed data from</param>
            <param name="gzip">if true, <seealso cref="T:System.IO.Compression.GZipStream"/> is created else <seealso cref="T:System.IO.Compression.DeflateStream"/>
            is created.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeSource">If true, <paramref name="source"/> is disposed after the operation.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CompressionExts.DecompressAsSegmentAsync(System.IO.Stream,System.Boolean,System.Threading.CancellationToken,System.Int32,System.Boolean)">
            <summary>
            Using compressor (GZip/Deflate), decompresses <paramref name="source"/> data with given
            <paramref name="bufferSize"/> while observing <paramref name="token"/> asynchronously.
            </summary>
            <param name="source">Source data stream to read compressed data from</param>
            <param name="gzip">if true, <seealso cref="T:System.IO.Compression.GZipStream"/> is created else <seealso cref="T:System.IO.Compression.DeflateStream"/>
            is created.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeSource">If true, <paramref name="source"/> is disposed after the operation.</param>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.CreateExts">
            <summary>
            Extensions related to creation of one type of objects to another type.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateKeyAndIv(System.String,System.String,System.Security.Cryptography.HashAlgorithmName,System.Int32,System.Int32,System.Int32,System.Text.Encoding)">
            <summary>
            Using <seealso cref="T:System.Security.Cryptography.Rfc2898DeriveBytes"/> creates the key and IV byte arrays.
            <para>NOTE: Key = tuple.Item1 and IV = tuple.Item2</para>
            </summary>
            <param name="password">password for key/IV generation (see <seealso cref="T:System.Security.Cryptography.Rfc2898DeriveBytes"/>)</param>
            <param name="salt">Salt string to use during key/IV generation (see <seealso cref="T:System.Security.Cryptography.Rfc2898DeriveBytes"/>)</param>
            <param name="hashName">Hash algorithm to use</param>
            <param name="byteLengthKey">Key length in number of bytes</param>
            <param name="byteLengthIv">IV length in number of bytes (normally, block size in bytes)</param>
            <param name="loopCnt">Loop count</param>
            <param name="enc">Encoding to use to convert password and salt to bytes. If not provided, UTF8Encoding(false) is used</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateBytes(System.ArraySegment{System.Byte})">
            <summary>
            Creates the byte array of the segment.
            </summary>
            <param name="input">Input segment</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateFileInfo(System.IO.DirectoryInfo,System.String,System.String)">
            <summary>
            Returns a new <seealso cref="T:System.IO.FileInfo"/> instance (file is physically NOT created)
            after combining <paramref name="filename"/>.<paramref name="extension"/>
            to <seealso cref="P:System.IO.FileSystemInfo.FullName"/> of the <paramref name="folderInfo"/>.
            <para>Expect all <seealso cref="T:System.IO.FileInfo"/> related errors.</para>
            </summary>
            <param name="folderInfo">FolderInfo to which fileInfo is associated</param>
            <param name="filename">filename without extension</param>
            <param name="extension">extension without period, e.g., "txt", "json" etc</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateFileInfo(System.IO.DirectoryInfo,System.String)">
            <summary>
            Returns a new <seealso cref="T:System.IO.FileInfo"/> instance (file is physically NOT created)
            after combining <paramref name="filenameWithExt"/>
            to <seealso cref="P:System.IO.FileSystemInfo.FullName"/> of the <paramref name="folderInfo"/>.
            <para>Expect all <seealso cref="T:System.IO.FileInfo"/> related errors.</para>
            </summary>
            <param name="folderInfo">FolderInfo to which fileInfo is associated</param>
            <param name="filenameWithExt">file name with extensions, e.g., "abc.txt", "mydata.json" etc</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateStream(System.IO.FileInfo,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
            <summary>
            Create new file stream for <paramref name="targetFileInfo"/>.
            </summary>
            <param name="targetFileInfo">Target file info</param>
            <param name="mode">mode of the stream</param>
            <param name="access">Access permission</param>
            <param name="share">File share type</param>
            <param name="bufferSize">Buffer size</param>
            <param name="options">File options</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateJsonReader(System.IO.FileInfo,System.Text.Encoding,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Boolean)">
            <summary>
            Create new JSON reader for <paramref name="targetFileInfo"/> with custom properties.
            </summary>
            <param name="targetFileInfo">Target file info</param>
            <param name="enc">Text encoding to use. If null, then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <param name="share">File share type</param>
            <param name="bufferSize">Buffer size</param>
            <param name="options">File options</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateStreamReader(System.IO.FileInfo,System.Text.Encoding,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Boolean)">
            <summary>
            Create new stream reader for <paramref name="targetFileInfo"/>.
            </summary>
            <param name="targetFileInfo">Target file info</param>
            <param name="enc">Text encoding to use. If null, then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <param name="share">File share type</param>
            <param name="bufferSize">Buffer size</param>
            <param name="options">File options</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateJsonWriter(System.IO.FileInfo,System.Text.Encoding,System.Boolean,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Boolean)">
            <summary>
            Create new JSON writer for <paramref name="targetFileInfo"/> with custom properties.
            </summary>
            <param name="targetFileInfo">Target file info</param>
            <param name="enc">Text encoding to use. If null, then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <param name="appendToFile">If true, existing file is appended or new file is created. If false, existing file is
            truncated or new file is created.</param>
            <param name="share">File share type</param>
            <param name="bufferSize">Buffer size</param>
            <param name="options">File options</param>
            <param name="autoFlush">True to enable auto-flushing else false</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateStreamWriter(System.IO.FileInfo,System.Text.Encoding,System.Boolean,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Boolean)">
            <summary>
            Create new stream writer for <paramref name="targetFileInfo"/>.
            </summary>
            <param name="targetFileInfo">Target file info</param>
            <param name="enc">Text encoding to use. If null, then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <param name="appendToFile">If true, existing file is appended or new file is created. If false, existing file is
            truncated or new file is created.</param>
            <param name="share">File share type</param>
            <param name="bufferSize">Buffer size</param>
            <param name="options">File options</param>
            <param name="autoFlush">True to enable auto-flushing else false</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateJsonWriter(System.Text.StringBuilder,System.IFormatProvider)">
            <summary>
            Create a JSON writer for <paramref name="stringBuilder"/> with custom properties.
            </summary>
            <param name="stringBuilder">Target string builder</param>
            <param name="formatProvider">Format provider. If null, then <seealso cref="P:System.Globalization.CultureInfo.CurrentCulture"/> is used</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateWriter(System.Text.StringBuilder,System.IFormatProvider)">
            <summary>
            Create a string writer for <paramref name="stringBuilder"/>.
            </summary>
            <param name="stringBuilder">Target string builder</param>
            <param name="formatProvider">Format provider. If null, then <seealso cref="P:System.Globalization.CultureInfo.CurrentCulture"/> is used</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateJsonReader(System.Text.StringBuilder)">
            <summary>
            Creates a JSON reader for <paramref name="stringBuilder"/> with custom properties.
            </summary>
            <param name="stringBuilder">Target string builder</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateReader(System.Text.StringBuilder)">
            <summary>
            Creates a string reader for <paramref name="stringBuilder"/>
            </summary>
            <param name="stringBuilder">Target string builder</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateJsonReader(System.String)">
            <summary>
            Creates a JSON reader for <paramref name="textVal"/> with custom properties.
            </summary>
            <param name="textVal">Target string</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateReader(System.String)">
            <summary>
            Creates a string reader for <paramref name="textVal"/>
            </summary>
            <param name="textVal">Target string</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateJsonReader(System.IO.TextReader,System.Boolean)">
            <summary>
            Creates a JSON reader for <paramref name="textReader"/> with custom properties.
            </summary>
            <param name="textReader">Target text reader</param>
            <param name="disposeReader">If true, <paramref name="textReader"/> is disposed after the deserialization</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateJsonWriter(System.IO.TextWriter,System.Boolean)">
            <summary>
            Creates a JSON writer for <paramref name="textWriter"/> with custom properties.
            </summary>
            <param name="textWriter">Target text writer</param>
            <param name="disposeWriter">If true, <paramref name="textWriter"/> is disposed after the serialization</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateJsonWriter(System.IO.Stream,System.Text.Encoding,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Create a JSON writer for <paramref name="targetStream"/> with custom properties.
            </summary>
            <param name="targetStream">target stream to write to</param>
            <param name="enc">Text encoding to use. If null, then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeStream">If true, <paramref name="targetStream"/> is disposed after the serialization</param>
            <param name="autoFlush">True to enable auto-flushing else false</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateWriter(System.IO.Stream,System.Text.Encoding,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Create a stream writer for <paramref name="targetStream"/>.
            </summary>
            <param name="targetStream">target stream to write to</param>
            <param name="enc">Text encoding to use. If null, then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeStream">If true, <paramref name="targetStream"/> is disposed after the serialization</param>
            <param name="autoFlush">Auto flush</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateJsonReader(System.IO.Stream,System.Text.Encoding,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Create a JSON reader for <paramref name="sourceStream"/> with custom properties.
            </summary>
            <param name="sourceStream">source stream to read from</param>
            <param name="enc">Text encoding to use. If null, then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeStream">If true, <paramref name="sourceStream"/> is disposed after the deserialization</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateReader(System.IO.Stream,System.Text.Encoding,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Create a stream reader for <paramref name="sourceStream"/>.
            </summary>
            <param name="sourceStream">source stream to read from</param>
            <param name="enc">Text encoding to use. If null, then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeStream">If true, <paramref name="sourceStream"/> is disposed after the deserialization</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateCompressionStream(System.IO.Stream,System.Boolean,System.IO.Compression.CompressionLevel,System.Boolean)">
            <summary>
            Creates compression stream (GZip or Deflate) that would hold <paramref name="innerStream"/> 
            and <paramref name="level"/> with an option to dispose the <paramref name="innerStream"/> after the operation.
            </summary>
            <param name="innerStream">stream on which compressed data will be written</param>
            <param name="gzip">if true, <seealso cref="T:System.IO.Compression.GZipStream"/> is created else <seealso cref="T:System.IO.Compression.DeflateStream"/>
            is created.</param>
            <param name="level">Compression level</param>
            <param name="disposeInner">If true, <paramref name="innerStream"/> is disposed after the operation.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateDecompressionStream(System.IO.Stream,System.Boolean,System.Boolean)">
            <summary>
            Creates compression stream (GZip or Deflate) that would hold <paramref name="innerStream"/> 
            with an option to dispose the <paramref name="innerStream"/> after the operation.
            </summary>
            <param name="innerStream">stream on which compressed data will be written</param>
            <param name="gzip">if true, <seealso cref="T:System.IO.Compression.GZipStream"/> is created else <seealso cref="T:System.IO.Compression.DeflateStream"/>
            is created.</param>
            <param name="disposeSource">If true, <paramref name="innerStream"/> is disposed after the operation.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateCryptoStream(System.IO.Stream,System.Security.Cryptography.ICryptoTransform,System.Security.Cryptography.CryptoStreamMode,System.Boolean)">
            <summary>
            Create <seealso cref="T:System.Security.Cryptography.CryptoStream"/> to perform operations on <paramref name="target"/>
            using supplied <paramref name="mode"/>.
            </summary>
            <param name="target">Target stream on which transformed data will be written
            or from which input data for transformation will be read (depends on <paramref name="mode"/>)</param>
            <param name="transform">Transform to perform</param>
            <param name="mode">Mode on the <paramref name="target"/></param>
            <param name="disposeTarget">If true, <paramref name="target"/> is disposed after the operation.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.CreateExts.CreateWrappedStream(System.IO.Stream,System.Boolean)">
            <summary>
            Creates an artificial wrapper around <paramref name="target"/> to control disposal
            (when it is not possible otherwise, e.g. <seealso cref="T:System.Security.Cryptography.CryptoStream"/>).
            </summary>
            <param name="target">Target stream to wrap</param>
            <param name="disposeTarget">True to dispose, else false. Disposal takes effect when wrapper is disposed.</param>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.EnumerableExts">
            <summary>
            Contains extension methods on <see cref="T:System.Collections.Generic.IEnumerable`1"/>, <see cref="T:System.Collections.IEnumerable"/> and <see cref="T:System.Collections.Generic.IAsyncEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.EqualsItemWise``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEqualityComparer{``0},System.Boolean)">
            <summary>
            Returns <see langword="true"/> when both (<paramref name="first"/> and <paramref name="second"/>) collections
            have equal items.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">First collection</param>
            <param name="second">Second collection</param>
            <param name="equalityComparer">Equality comparator of T, if any.</param>
            <param name="sameItemOrder">If <see langword="true"/> then item order is taken into account.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.ToOneToManyDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates and returns an instance of <see cref="T:Dot.Net.DevFast.Collections.OneToManyDictionary`2"/> from <paramref name="collection"/> items
            using <paramref name="keyFinder"/> lambda and provided key <paramref name="comparer"/> (if any).
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="collection">Collection of Value items</param>
            <param name="keyFinder">Key finder lambda</param>
            <param name="comparer">Key comparer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.ToOneToManyDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates and returns an instance of <see cref="T:Dot.Net.DevFast.Collections.OneToManyDictionary`2"/> from <paramref name="collection"/> items
            using <paramref name="keyFinder"/> lambda and <paramref name="valueFinder"/> lambda; with provided key <paramref name="comparer"/> (if any).
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="collection">Collection of Value items</param>
            <param name="keyFinder">Key finder lambda</param>
            <param name="valueFinder">Value finder lambda</param>
            <param name="comparer">Key comparer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.ToOneToUniqueManyDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates and returns an instance of <see cref="T:Dot.Net.DevFast.Collections.OneToUniqueManyDictionary`2"/> from <paramref name="collection"/> items
            using <paramref name="keyFinder"/> lambda and provided key <paramref name="comparer"/> (if any).
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="collection">Collection of Value items</param>
            <param name="keyFinder">Key finder lambda</param>
            <param name="comparer">Key comparer</param>
            <param name="valueComparer">Value comparer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.ToOneToUniqueManyDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Creates and returns an instance of <see cref="T:Dot.Net.DevFast.Collections.OneToUniqueManyDictionary`2"/> from <paramref name="collection"/> items
            using <paramref name="keyFinder"/> lambda and <paramref name="valueFinder"/> lambda; with provided key <paramref name="comparer"/> (if any).
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="collection">Collection of Value items</param>
            <param name="keyFinder">Key finder lambda</param>
            <param name="valueFinder">Value finder lambda</param>
            <param name="comparer">Key comparer</param>
            <param name="valueComparer">Value comparer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.ToFastDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates and returns an instance of <see cref="T:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2"/> from <paramref name="collection"/> items
            using <paramref name="keyFinder"/> lambda and provided key <paramref name="comparer"/> (if any).
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="collection">Collection of Value items</param>
            <param name="keyFinder">Key finder lambda</param>
            <param name="comparer">Key comparer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.ToFastDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates and returns an instance of <see cref="T:Dot.Net.DevFast.Collections.Concurrent.FastDictionary`2"/> from <paramref name="collection"/> items
            using <paramref name="keyFinder"/> lambda and <paramref name="valueFinder"/> lambda; with provided key <paramref name="comparer"/> (if any).
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="collection">Collection of Value items</param>
            <param name="keyFinder">Key finder lambda</param>
            <param name="valueFinder">Value finder lambda</param>
            <param name="comparer">Key comparer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Threading.CancellationToken)">
            <summary>
            Applies provided <paramref name="action"/> on every item of the given enumerable while observing for cancellation.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">Items</param>
            <param name="action">Action to apply</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.ForEach(System.Collections.IEnumerable,System.Action{System.Object},System.Threading.CancellationToken)">
            <summary>
            Applies provided <paramref name="action"/> on every item of the given enumerable while observing for cancellation.
            </summary>
            <param name="items">Items</param>
            <param name="action">Action to apply</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.CancellationToken},System.Threading.CancellationToken)">
            <summary>
            Applies provided <paramref name="action"/> on every item of the given enumerable while observing for cancellation.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">Items</param>
            <param name="action">Action to apply</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.ForEach(System.Collections.IEnumerable,System.Action{System.Object,System.Threading.CancellationToken},System.Threading.CancellationToken)">
            <summary>
            Applies provided <paramref name="action"/> on every item of the given enumerable while observing for cancellation.
            </summary>
            <param name="items">Items</param>
            <param name="action">Action to apply</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.ForEachAsync``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Applies provided async <paramref name="action"/> on every item of the given enumerable,
            asynchronously, while observing for cancellation.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">Items</param>
            <param name="action">Action to apply</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.ForEachAsync``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Action{``0,System.Threading.CancellationToken},System.Threading.CancellationToken)">
            <summary>
            Applies provided <paramref name="action"/> on every item of the given enumerable while observing for cancellation.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">Items</param>
            <param name="action">Action to apply</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.ForEachAsync``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Applies provided <paramref name="action"/> on every item of the given enumerable while observing for cancellation.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">Items</param>
            <param name="action">Action to apply</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.SelectAsync``2(System.Collections.Generic.IAsyncEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,``1},System.Threading.CancellationToken)">
            <summary>
            Applies provided <paramref name="selector"/> lambda on every item of the asynchronous collection asynchronously.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TR"></typeparam>
            <param name="items">Items</param>
            <param name="selector">Selector lambda</param>
            <param name="token">Token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.SelectAsync``2(System.Collections.Generic.IAsyncEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}},System.Threading.CancellationToken)">
            <summary>
            Applies provided <paramref name="selector"/> lambda on every item of the asynchronous collection asynchronously.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TR"></typeparam>
            <param name="items">Items</param>
            <param name="selector">Selector lambda</param>
            <param name="token">Token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.WhereAsync``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Applies provided <paramref name="predicate"/> lambda on every item of the asynchronous collection asynchronously.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">Items</param>
            <param name="predicate">Selector lambda</param>
            <param name="token">Token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.WhereAsync``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.Boolean}},System.Threading.CancellationToken)">
            <summary>
            Applies provided <paramref name="predicate"/> lambda on every item of the asynchronous collection asynchronously.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">Items</param>
            <param name="predicate">Selector lambda</param>
            <param name="token">Token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.ToListAsync``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Creates a new list using all the items of the given asynchronous enumerable asynchronously.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">Items</param>
            <param name="token">Token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.EnumerableExts.ToListAsync``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Int32,System.Threading.CancellationToken)">
            <summary>
            Creates a new list using all the items of the given asynchronous enumerable asynchronously; while,
            respecting the <paramref name="limit"/> provided.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">Items</param>
            <param name="limit">Max. items in the list</param>
            <param name="token">Token to observe</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When enumeration returns more elements than the <paramref name="limit"/> count.
            Exception ErrorCode is <see cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.OverAllocationDemanded"/></exception>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.JsonExt.CustomJson">
            <summary>
            Defaults related to JSON Serialization
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer">
            <summary>
            Returns a new instance of custom <seealso cref="T:Newtonsoft.Json.JsonSerializer"/>.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.AdaptedJsonSerializer(Newtonsoft.Json.JsonWriter)">
            <summary>
            Creates <seealso cref="T:Newtonsoft.Json.JsonSerializer"/> using <see cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/> and sets serialization related properties based on
            the properties of the <paramref name="writer"/>.
            </summary>
            <param name="writer">writer to reference</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.AdaptedJsonSerializer(Newtonsoft.Json.JsonReader)">
            <summary>
            Creates <seealso cref="T:Newtonsoft.Json.JsonSerializer"/> using <see cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/> and sets deserialization related properties based on
            the properties of the <paramref name="reader"/>.
            </summary>
            <param name="reader">reader to reference</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.AdaptedJsonWriter(Newtonsoft.Json.JsonSerializer,System.IO.TextWriter,System.Boolean)">
            <summary>
            Creates a <seealso cref="T:Newtonsoft.Json.JsonWriter"/> for given <paramref name="serializer"/> and <paramref name="textWriter"/>.
            </summary>
            <param name="serializer">Serializer to use to populate <seealso cref="T:Newtonsoft.Json.JsonWriter"/> properties</param>
            <param name="textWriter">target text writer</param>
            <param name="disposeWriter">If true, <paramref name="textWriter"/> is disposed after the serialization</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.AdaptedJsonReader(Newtonsoft.Json.JsonSerializer,System.IO.TextReader,System.Boolean)">
            <summary>
            Creates a <seealso cref="T:Newtonsoft.Json.JsonReader"/> for given <paramref name="serializer"/> and <paramref name="textReader"/>.
            </summary>
            <param name="serializer">Serializer to use to populate <seealso cref="T:Newtonsoft.Json.JsonReader"/> properties</param>
            <param name="textReader">target text reader</param>
            <param name="disposeReader">If true, <paramref name="textReader"/> is disposed after the deserialization</param>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt">
            <summary>
            Extensions of Json serializations.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.ToJsonArrayParallely``1(System.Collections.Concurrent.BlockingCollection{``0},Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Threading.CancellationTokenSource,System.IFormatProvider)">
            <summary>
            When employed into Parallel Producer-Consumer pattern, as a consumer of objects (alone or among many others),
            writes the JSON array representation of objects of <paramref name="source"/> using 
            <paramref name="serializer"/> while observing <paramref name="token"/>.
            <para>IMPORTANT: Call to <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> is MANDATORY,
            somewhere outside the call of this method, otherwise this method will NEVER terminate (i.e. Deadlock).</para>
            Best would be to wrap the <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> call inside 
            finally block at producer side.
            </summary>
            <typeparam name="T">Type of the sourceCollection data</typeparam>
            <param name="source">input blocking collection to JSON serialize</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="token">cancellation token to observe</param>
            <param name="producerTokenSource">When developing parallel prooducer-consumer pattern and if you wish you
            cancel the producer side in case of error during json serialization (consumer side),
            pass the source of cancellation token which producer is observing.</param>
            <param name="formatProvider">Format provider. If null, then <seealso cref="P:System.Globalization.CultureInfo.CurrentCulture"/> is used</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.ToJsonArrayParallely``1(System.Collections.Concurrent.BlockingCollection{``0},System.Text.StringBuilder,Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Threading.CancellationTokenSource,System.IFormatProvider)">
            <summary>
            When employed into Parallel Producer-Consumer pattern, as a consumer of objects (alone or among many others),
            writes the JSON array representation of objects of <paramref name="source"/> using 
            <paramref name="serializer"/> to <paramref name="target"/>
            while observing <paramref name="token"/>.
            <para>IMPORTANT: Call to <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> is MANDATORY,
            somewhere outside the call of this method, otherwise this method will NEVER terminate (i.e. Deadlock).</para>
            Best would be to wrap the <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> call inside 
            finally block at producer side.
            </summary>
            <typeparam name="T">Type of the sourceCollection data</typeparam>
            <param name="source">input blocking collection to JSON serialize</param>
            <param name="target">target output string builder</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="token">cancellation token to observe</param>
            <param name="producerTokenSource">When developing parallel prooducer-consumer pattern and if you wish you
            cancel the producer side in case of error during json serialization (consumer side),
            pass the source of cancellation token which producer is observing.</param>
            <param name="formatProvider">Format provider. If null, then <seealso cref="P:System.Globalization.CultureInfo.CurrentCulture"/> is used</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.ToJsonArrayParallely``1(System.Collections.Concurrent.BlockingCollection{``0},System.IO.Stream,Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Threading.CancellationTokenSource,System.Text.Encoding,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            When employed into Parallel Producer-Consumer pattern, as a consumer of objects (alone or among many others),
            writes the JSON array representation of objects of <paramref name="source"/> using 
            <paramref name="serializer"/> to <paramref name="target"/>
            while observing <paramref name="token"/>.
            <para>IMPORTANT: Call to <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> is MANDATORY,
            somewhere outside the call of this method, otherwise this method will NEVER terminate (i.e. Deadlock).</para>
            Best would be to wrap the <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> call inside 
            finally block at producer side.
            </summary>
            <typeparam name="T">Type of the sourceCollection data</typeparam>
            <param name="source">input blocking collection to JSON serialize</param>
            <param name="target">target output stream</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="token">cancellation token to observe</param>
            <param name="producerTokenSource">When developing parallel prooducer-consumer pattern and if you wish you
            cancel the producer side in case of error during json serialization (consumer side),
            pass the source of cancellation token which producer is observing.</param>
            <param name="enc">Text encoding to use. If null, then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeTarget">If true, <paramref name="target"/> is disposed after the serialization</param>
            <param name="autoFlush">True to enable auto-flushing else false</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.ToJsonArrayParallely``1(System.Collections.Concurrent.BlockingCollection{``0},System.IO.TextWriter,Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Threading.CancellationTokenSource,System.Boolean)">
            <summary>
            When employed into Parallel Producer-Consumer pattern, as a consumer of objects (alone or among many others),
            writes the JSON array representation of objects of <paramref name="source"/> using 
            <paramref name="serializer"/> to <paramref name="target"/>
            while observing <paramref name="token"/>.
            <para>IMPORTANT: Call to <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> is MANDATORY,
            somewhere outside the call of this method, otherwise this method will NEVER terminate (i.e. Deadlock).</para>
            Best would be to wrap the <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> call inside 
            finally block at producer side.
            </summary>
            <typeparam name="T">Type of the sourceCollection data</typeparam>
            <param name="source">input blocking collection to JSON serialize</param>
            <param name="target">target text writer</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="token">cancellation token to observe</param>
            <param name="producerTokenSource">When developing parallel prooducer-consumer pattern and if you wish you
            cancel the producer side in case of error during json serialization (consumer side),
            pass the source of cancellation token which producer is observing.</param>
            <param name="disposeTarget">If true, <paramref name="target"/> is disposed after the serialization</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.ToJsonArrayParallely``1(System.Collections.Concurrent.BlockingCollection{``0},Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Threading.CancellationTokenSource,System.Boolean)">
            <summary>
            When employed into Parallel Producer-Consumer pattern, as a consumer of objects (alone or among many others),
            writes the JSON array representation of objects of <paramref name="source"/> using 
            <paramref name="serializer"/> to <paramref name="target"/>
            while observing <paramref name="token"/>.
            <para>IMPORTANT: Call to <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> is MANDATORY,
            somewhere outside the call of this method, otherwise this method will NEVER terminate (i.e. Deadlock).</para>
            Best would be to wrap the <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> call inside 
            finally block at producer side.
            </summary>
            <typeparam name="T">Type of the sourceCollection data</typeparam>
            <param name="source">input blocking collection to JSON serialize</param>
            <param name="target">target JSON writer</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.AdaptedJsonSerializer(Newtonsoft.Json.JsonWriter)"/></param>
            <param name="token">cancellation token to observe</param>
            <param name="producerTokenSource">When developing parallel prooducer-consumer pattern and if you wish you
            cancel the producer side in case of error during json serialization (consumer side),
            pass the source of cancellation token which producer is observing.</param>
            <param name="disposeTarget">If true, <paramref name="target"/> is disposed after the serialization</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.ToJsonArray``1(System.Collections.Generic.IEnumerable{``0},Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.IFormatProvider)">
            <summary>
            Returns the JSON serialized string of <paramref name="source"/> using <paramref name="serializer"/>
            while observing <paramref name="token"/>.
            </summary>
            <typeparam name="T">Type of the input object array</typeparam>
            <param name="source">input object enumerable to JSON serialize</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="token">cancellation token to observe</param>
            <param name="formatProvider">Format provider. If null, then <seealso cref="P:System.Globalization.CultureInfo.CurrentCulture"/> is used</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.ToJsonArray``1(System.Collections.Generic.IEnumerable{``0},System.Text.StringBuilder,Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.IFormatProvider)">
            <summary>
            Writes the JSON serialized string of <paramref name="source"/> using <paramref name="serializer"/>
            to <paramref name="target"/> while observing <paramref name="token"/>.
            </summary>
            <typeparam name="T">Type of the input object array</typeparam>
            <param name="source">input object enumerable to JSON serialize</param>
            <param name="target">target output string builder</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="token">cancellation token to observe</param>
            <param name="formatProvider">Format provider. If null, then <seealso cref="P:System.Globalization.CultureInfo.CurrentCulture"/> is used</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.ToJsonArray``1(System.Collections.Generic.IEnumerable{``0},System.IO.Stream,Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Text.Encoding,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Writes the JSON serialized string of <paramref name="source"/> using <paramref name="serializer"/>
            to <paramref name="target"/> while observing <paramref name="token"/>.
            </summary>
            <typeparam name="T">Type of the input object array</typeparam>
            <param name="source">input object enumerable to JSON serialize</param>
            <param name="target">target output stream</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="token">cancellation token to observe</param>
            <param name="enc">Text encoding to use. If null, then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeTarget">If true, <paramref name="target"/> is disposed after the serialization</param>
            <param name="autoFlush">True to enable auto-flushing else false</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.ToJsonArray``1(System.Collections.Generic.IEnumerable{``0},System.IO.TextWriter,Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Writes the JSON serialized string of <paramref name="source"/> using <paramref name="serializer"/>
            to <paramref name="target"/> while observing <paramref name="token"/>.
            </summary>
            <typeparam name="T">Type of the input object array</typeparam>
            <param name="source">input object enumerable to JSON serialize</param>
            <param name="target">target text writer</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="token">cancellation token to observe</param>
            <param name="disposeTarget">If true, <paramref name="target"/> is disposed after the serialization</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.ToJsonArray``1(System.Collections.Generic.IEnumerable{``0},Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Writes the JSON serialized string of <paramref name="source"/> using <paramref name="serializer"/>
            to <paramref name="target"/> while observing <paramref name="token"/>.
            </summary>
            <typeparam name="T">Type of the input object array</typeparam>
            <param name="source">input object enumerable to JSON serialize</param>
            <param name="target">target JSON writer</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.AdaptedJsonSerializer(Newtonsoft.Json.JsonWriter)"/></param>
            <param name="token">cancellation token to observe</param>
            <param name="disposeTarget">If true, <paramref name="target"/> is disposed after the serialization</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.ToJson``1(``0,Newtonsoft.Json.JsonSerializer,System.IFormatProvider)">
            <summary>
            Returns the JSON serialized string of <paramref name="source"/> using <paramref name="serializer"/>.
            </summary>
            <typeparam name="T">Type of the input object to serialize</typeparam>
            <param name="source">input object to JSON serialize</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="formatProvider">Format provider. If null, then <seealso cref="P:System.Globalization.CultureInfo.CurrentCulture"/> is used</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.ToJson``1(``0,System.Text.StringBuilder,Newtonsoft.Json.JsonSerializer,System.IFormatProvider)">
            <summary>
            Writes the JSON serialized string of <paramref name="source"/> using <paramref name="serializer"/>
            to <paramref name="target"/>.
            </summary>
            <typeparam name="T">Type of the input object to serialize</typeparam>
            <param name="source">input object to JSON serialize</param>
            <param name="target">target output string builder</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="formatProvider">Format provider. If null, then <seealso cref="P:System.Globalization.CultureInfo.CurrentCulture"/> is used</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.ToJson``1(``0,System.IO.Stream,Newtonsoft.Json.JsonSerializer,System.Text.Encoding,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Writes the JSON serialized string of <paramref name="source"/> using <paramref name="serializer"/>
            to <paramref name="target"/>.
            </summary>
            <typeparam name="T">Type of the input object to serialize</typeparam>
            <param name="source">input object to JSON serialize</param>
            <param name="target">target output stream</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="enc">Text encoding to use. If null, then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeTarget">If true, <paramref name="target"/> is disposed after the serialization</param>
            <param name="autoFlush">True to enable auto-flushing else false</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.ToJson``1(``0,System.IO.TextWriter,Newtonsoft.Json.JsonSerializer,System.Boolean)">
            <summary>
            Writes the JSON serialized string of <paramref name="source"/> using <paramref name="serializer"/>
            to <paramref name="target"/>.
            </summary>
            <typeparam name="T">Type of the input object to serialize</typeparam>
            <param name="source">input object to JSON serialize</param>
            <param name="target">target text writer</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="disposeTarget">If true, <paramref name="target"/> is disposed after the serialization</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.ToJson``1(``0,Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonSerializer,System.Boolean)">
            <summary>
            Writes the JSON serialized string of <paramref name="source"/> using <paramref name="serializer"/>
            to <paramref name="target"/>.
            </summary>
            <typeparam name="T">Type of the input object to serialize</typeparam>
            <param name="source">input object to JSON serialize</param>
            <param name="target">target JSON writer</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.AdaptedJsonSerializer(Newtonsoft.Json.JsonWriter)"/></param>
            <param name="disposeTarget">If true, <paramref name="target"/> is disposed after the serialization</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.FromJson``1(System.Text.StringBuilder,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Deserializes the JSON string of <paramref name="source"/> using <paramref name="serializer"/>.
            </summary>
            <typeparam name="T">Type of deserialized object</typeparam>
            <param name="source">source JSON String Builder</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.FromJson``1(System.String,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Deserializes <paramref name="source"/> using <paramref name="serializer"/>.
            </summary>
            <typeparam name="T">Type of deserialized object</typeparam>
            <param name="source">source JSON String</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.FromJson``1(System.IO.Stream,Newtonsoft.Json.JsonSerializer,System.Text.Encoding,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Deserializes the JSON data of <paramref name="source"/> using <paramref name="serializer"/>.
            </summary>
            <typeparam name="T">Type of deserialized object</typeparam>
            <param name="source">source JSON stream</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="enc">Text encoding to use. If null, then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeSource">If true, <paramref name="source"/> is disposed after the deserialization</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.FromJson``1(System.IO.TextReader,Newtonsoft.Json.JsonSerializer,System.Boolean)">
            <summary>
            Deserializes the JSON data of <paramref name="source"/> using <paramref name="serializer"/>.
            </summary>
            <typeparam name="T">Type of deserialized object</typeparam>
            <param name="source">Text reader as data source</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="disposeSource">If true, <paramref name="source"/> is disposed after the deserialization</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.FromJson``1(Newtonsoft.Json.JsonReader,Newtonsoft.Json.JsonSerializer,System.Boolean)">
            <summary>
            Deserializes the JSON data of <paramref name="source"/> using <paramref name="serializer"/>.
            </summary>
            <typeparam name="T">Type of deserialized object</typeparam>
            <param name="source">JSON reader as data source</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.AdaptedJsonSerializer(Newtonsoft.Json.JsonReader)"/></param>
            <param name="disposeSource">If true, <paramref name="source"/> is disposed after the deserialization</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.FromJsonAsEnumerable``1(System.Text.StringBuilder,Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Int32)">
            <summary>
            A simple enumerator on JSON data deserialization with an expectation that <paramref name="source"/> will
            start reading from <seealso cref="F:Newtonsoft.Json.JsonToken.StartArray"/>. Parses array objects, using <paramref name="serializer"/>,
            one at a time for enumeration until <seealso cref="F:Newtonsoft.Json.JsonToken.EndArray"/> is encountered OR <paramref name="token"/> is cancelled.
            </summary>
            <typeparam name="T">Type of deserialized object</typeparam>
            <param name="source">source JSON String builder</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="token">Cancellation token to observe</param>
            <param name="objectBufferSize">Size of the intermediate object buffer in terms of number (count) of deserialized objects. NOTE: <see cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded"/> is a special number to create unbounded buffer.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When given size is negative</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.FromJsonAsEnumerable``1(System.String,Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Int32)">
            <summary>
            A simple enumerator on JSON data deserialization with an expectation that <paramref name="source"/> will
            start reading from <seealso cref="F:Newtonsoft.Json.JsonToken.StartArray"/>. Parses array objects, using <paramref name="serializer"/>,
            one at a time for enumeration until <seealso cref="F:Newtonsoft.Json.JsonToken.EndArray"/> is encountered OR <paramref name="token"/> is cancelled.
            </summary>
            <typeparam name="T">Type of deserialized object</typeparam>
            <param name="source">source JSON String</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="token">Cancellation token to observe</param>
            <param name="objectBufferSize">Size of the intermediate object buffer in terms of number (count) of deserialized objects. NOTE: <see cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded"/> is a special number to create unbounded buffer.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When given size is negative</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.FromJsonAsEnumerable``1(System.IO.Stream,Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Text.Encoding,System.Int32,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            A simple enumerator on JSON data deserialization with an expectation that <paramref name="source"/> will
            start reading from <seealso cref="F:Newtonsoft.Json.JsonToken.StartArray"/>. Parses array objects, using <paramref name="serializer"/>,
            one at a time for enumeration until <seealso cref="F:Newtonsoft.Json.JsonToken.EndArray"/> is encountered OR <paramref name="token"/> is cancelled.
            </summary>
            <typeparam name="T">Type of deserialized object</typeparam>
            <param name="source">source JSON stream</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="token">Cancellation token to observe</param>
            <param name="enc">Text encoding to use. If null, then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeSource">If true, <paramref name="source"/> is disposed after the deserialization</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="objectBufferSize">Size of the intermediate object buffer in terms of number (count) of deserialized objects. NOTE: <see cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded"/> is a special number to create unbounded buffer.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When given size is negative</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.FromJsonAsEnumerable``1(System.IO.TextReader,Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Boolean,System.Int32)">
            <summary>
            A simple enumerator on JSON data deserialization with an expectation that <paramref name="source"/> will
            start reading from <seealso cref="F:Newtonsoft.Json.JsonToken.StartArray"/>. Parses array objects, using <paramref name="serializer"/>,
            one at a time for enumeration until <seealso cref="F:Newtonsoft.Json.JsonToken.EndArray"/> is encountered OR <paramref name="token"/> is cancelled.
            </summary>
            <typeparam name="T">Type of deserialized object</typeparam>
            <param name="source">JSON text reader as data source</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="token">Cancellation token to observe</param>
            <param name="disposeSource">If true, <paramref name="source"/> is disposed after the deserialization</param>
            <param name="objectBufferSize">Size of the intermediate object buffer in terms of number (count) of deserialized objects. NOTE: <see cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded"/> is a special number to create unbounded buffer.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When given size is negative</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.FromJsonAsEnumerable``1(Newtonsoft.Json.JsonReader,Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Boolean,System.Int32)">
            <summary>
            A simple enumerator on JSON data deserialization with an expectation that <paramref name="source"/> will
            start reading from <seealso cref="F:Newtonsoft.Json.JsonToken.StartArray"/>. Parses array objects, using <paramref name="serializer"/>,
            one at a time for enumeration until <seealso cref="F:Newtonsoft.Json.JsonToken.EndArray"/> is encountered OR <paramref name="token"/> is cancelled.
            </summary>
            <typeparam name="T">Type of deserialized object</typeparam>
            <param name="source">JSON reader as data source</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.AdaptedJsonSerializer(Newtonsoft.Json.JsonReader)"/></param>
            <param name="token">Cancellation token to observe</param>
            <param name="disposeSource">If true, <paramref name="source"/> is disposed after the deserialization</param>
            <param name="objectBufferSize">Size of the intermediate object buffer in terms of number (count) of deserialized objects. NOTE: <see cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded"/> is a special number to create unbounded buffer.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When given size is negative</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.FromJsonArrayParallely``1(System.Text.StringBuilder,System.Collections.Concurrent.BlockingCollection{``0},Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Threading.CancellationTokenSource,System.Boolean,System.Boolean)">
            <summary>
            When employed into Parallel Producer-Consumer pattern, as a producer of objects (alone or among many others),
            performs JSON data deserialization with an expectation that <paramref name="source"/> will
            start reading from <seealso cref="F:Newtonsoft.Json.JsonToken.StartArray"/>. Parses array objects, using <paramref name="serializer"/>,
            one at a time to populate <paramref name="target"/> until <seealso cref="F:Newtonsoft.Json.JsonToken.EndArray"/> is encountered
            OR <paramref name="token"/> is cancelled.
            <para>IMPORTANT: Call to <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> anywhere outside of this method 
            must be done with the proper setup of <paramref name="closeTarget"/> and <paramref name="forceCloseWhenError"/>
            (please look at the comments of those parameters for details).</para>
            You may think of passing <seealso cref="T:System.Collections.Concurrent.BlockingCollection`1"/> with some pre-instrumented
            <seealso cref="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity"/> (in most of the cases, 1 is sufficient) to minimize memory consumption.
            </summary>
            <typeparam name="T">Type of deserialized object</typeparam>
            <param name="source">source JSON String builder</param>
            <param name="target">target blocking collection to populate deserialied JSON data objects</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="token">Cancellation token to observe</param>
            <param name="consumerTokenSource">When developing parallel prooducer-consumer pattern and if you wish you
            cancel the consumer side in case of error during json deserialization (producer side),
            pass the source of cancellation token which consumer is observing.</param>
            <param name="closeTarget"><para>When this is the ONLY call that populates the <paramref name="target"/>
            keep it true so that when operation finishes the collection is automatically closed for adding so that consumer 
            shall not remain blocked infinitely. If setting false, then you must explicitly call 
            <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> for the obvious reason.</para>
            <para>When this call is one among multiple producers populating the same <paramref name="target"/>,
            it is MANDATORY to set this to false and you must explicitly call <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/>
            when all producers finished populating the collection, otherwise weird things may happen.</para></param>
            <param name="forceCloseWhenError">if true, when any error occurs closes the collection for any additional 
            adding irrespective of <paramref name="closeTarget"/> setting. When false, <paramref name="closeTarget"/>
            setting takes precedence.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.FromJsonArrayParallely``1(System.String,System.Collections.Concurrent.BlockingCollection{``0},Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Threading.CancellationTokenSource,System.Boolean,System.Boolean)">
            <summary>
            When employed into Parallel Producer-Consumer pattern, as a producer of objects (alone or among many others),
            performs JSON data deserialization with an expectation that <paramref name="source"/> will
            start reading from <seealso cref="F:Newtonsoft.Json.JsonToken.StartArray"/>. Parses array objects, using <paramref name="serializer"/>,
            one at a time to populate <paramref name="target"/> until <seealso cref="F:Newtonsoft.Json.JsonToken.EndArray"/> is encountered
            OR <paramref name="token"/> is cancelled.
            <para>IMPORTANT: Call to <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> anywhere outside of this method 
            must be done with the proper setup of <paramref name="closeTarget"/> and <paramref name="forceCloseWhenError"/>
            (please look at the comments of those parameters for details).</para>
            You may think of passing <seealso cref="T:System.Collections.Concurrent.BlockingCollection`1"/> with some pre-instrumented
            <seealso cref="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity"/> (in most of the cases, 1 is sufficient) to minimize memory consumption.
            </summary>
            <typeparam name="T">Type of deserialized object</typeparam>
            <param name="source">source JSON String</param>
            <param name="target">target blocking collection to populate deserialied JSON data objects</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="token">Cancellation token to observe</param>
            <param name="consumerTokenSource">When developing parallel prooducer-consumer pattern and if you wish you
            cancel the consumer side in case of error during json deserialization (producer side),
            pass the source of cancellation token which consumer is observing.</param>
            <param name="closeTarget"><para>When this is the ONLY call that populates the <paramref name="target"/>
            keep it true so that when operation finishes the collection is automatically closed for adding so that consumer 
            shall not remain blocked infinitely. If setting false, then you must explicitly call 
            <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> for the obvious reason.</para>
            <para>When this call is one among multiple producers populating the same <paramref name="target"/>,
            it is MANDATORY to set this to false and you must explicitly call <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/>
            when all producers finished populating the collection, otherwise weird things may happen.</para></param>
            <param name="forceCloseWhenError">if true, when any error occurs closes the collection for any additional 
            adding irrespective of <paramref name="closeTarget"/> setting. When false, <paramref name="closeTarget"/>
            setting takes precedence.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.FromJsonArrayParallely``1(System.IO.Stream,System.Collections.Concurrent.BlockingCollection{``0},Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Threading.CancellationTokenSource,System.Text.Encoding,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            When employed into Parallel Producer-Consumer pattern, as a producer of objects (alone or among many others),
            performs JSON data deserialization with an expectation that <paramref name="source"/> will
            start reading from <seealso cref="F:Newtonsoft.Json.JsonToken.StartArray"/>. Parses array objects, using <paramref name="serializer"/>,
            one at a time to populate <paramref name="target"/> until <seealso cref="F:Newtonsoft.Json.JsonToken.EndArray"/> is encountered
            OR <paramref name="token"/> is cancelled.
            <para>IMPORTANT: Call to <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> anywhere outside of this method 
            must be done with the proper setup of <paramref name="closeTarget"/> and <paramref name="forceCloseWhenError"/>
            (please look at the comments of those parameters for details).</para>
            You may think of passing <seealso cref="T:System.Collections.Concurrent.BlockingCollection`1"/> with some pre-instrumented
            <seealso cref="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity"/> (in most of the cases, 1 is sufficient) to minimize memory consumption.
            </summary>
            <typeparam name="T">Type of deserialized object</typeparam>
            <param name="source">source JSON stream</param>
            <param name="target">target blocking collection to populate deserialied JSON data objects</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="token">Cancellation token to observe</param>
            <param name="enc">Text encoding to use. If null, then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <param name="bufferSize">Buffer size</param>
            <param name="consumerTokenSource">When developing parallel prooducer-consumer pattern and if you wish you
            cancel the consumer side in case of error during json deserialization (producer side),
            pass the source of cancellation token which consumer is observing.</param>
            <param name="disposeSource">If true, <paramref name="source"/> is disposed after the deserialization</param>
            <param name="closeTarget"><para>When this is the ONLY call that populates the <paramref name="target"/>
            keep it true so that when operation finishes the collection is automatically closed for adding so that consumer 
            shall not remain blocked infinitely. If setting false, then you must explicitly call 
            <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> for the obvious reason.</para>
            <para>When this call is one among multiple producers populating the same <paramref name="target"/>,
            it is MANDATORY to set this to false and you must explicitly call <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/>
            when all producers finished populating the collection, otherwise weird things may happen.</para></param>
            <param name="forceCloseWhenError">if true, when any error occurs closes the collection for any additional 
            adding irrespective of <paramref name="closeTarget"/> setting. When false, <paramref name="closeTarget"/>
            setting takes precedence.</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.FromJsonArrayParallely``1(System.IO.TextReader,System.Collections.Concurrent.BlockingCollection{``0},Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Threading.CancellationTokenSource,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            When employed into Parallel Producer-Consumer pattern, as a producer of objects (alone or among many others),
            performs JSON data deserialization with an expectation that <paramref name="source"/> will
            start reading from <seealso cref="F:Newtonsoft.Json.JsonToken.StartArray"/>. Parses array objects, using <paramref name="serializer"/>,
            one at a time to populate <paramref name="target"/> until <seealso cref="F:Newtonsoft.Json.JsonToken.EndArray"/> is encountered
            OR <paramref name="token"/> is cancelled.
            <para>IMPORTANT: Call to <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> anywhere outside of this method 
            must be done with the proper setup of <paramref name="closeTarget"/> and <paramref name="forceCloseWhenError"/>
            (please look at the comments of those parameters for details).</para>
            You may think of passing <seealso cref="T:System.Collections.Concurrent.BlockingCollection`1"/> with some pre-instrumented
            <seealso cref="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity"/> (in most of the cases, 1 is sufficient) to minimize memory consumption.
            </summary>
            <typeparam name="T">Type of deserialized object</typeparam>
            <param name="source">JSON text reader as data source</param>
            <param name="target">target blocking collection to populate deserialied JSON data objects</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/></param>
            <param name="token">Cancellation token to observe</param>
            <param name="consumerTokenSource">When developing parallel prooducer-consumer pattern and if you wish you
            cancel the consumer side in case of error during json deserialization (producer side),
            pass the source of cancellation token which consumer is observing.</param>
            <param name="disposeSource">If true, <paramref name="source"/> is disposed after the deserialization</param>
            <param name="closeTarget"><para>When this is the ONLY call that populates the <paramref name="target"/>
            keep it true so that when operation finishes the collection is automatically closed for adding so that consumer 
            shall not remain blocked infinitely. If setting false, then you must explicitly call 
            <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> for the obvious reason.</para>
            <para>When this call is one among multiple producers populating the same <paramref name="target"/>,
            it is MANDATORY to set this to false and you must explicitly call <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/>
            when all producers finished populating the collection, otherwise weird things may happen.</para></param>
            <param name="forceCloseWhenError">if true, when any error occurs closes the collection for any additional 
            adding irrespective of <paramref name="closeTarget"/> setting. When false, <paramref name="closeTarget"/>
            setting takes precedence.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.JsonExt.JsonTxtExt.FromJsonArrayParallely``1(Newtonsoft.Json.JsonReader,System.Collections.Concurrent.BlockingCollection{``0},Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Threading.CancellationTokenSource,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            When employed into Parallel Producer-Consumer pattern, as a producer of objects (alone or among many others),
            performs JSON data deserialization with an expectation that <paramref name="source"/> will
            start reading from <seealso cref="F:Newtonsoft.Json.JsonToken.StartArray"/>. Parses array objects, using <paramref name="serializer"/>,
            one at a time to populate <paramref name="target"/> until <seealso cref="F:Newtonsoft.Json.JsonToken.EndArray"/> is encountered
            OR <paramref name="token"/> is cancelled.
            <para>IMPORTANT: Call to <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> anywhere outside of this method 
            must be done with the proper setup of <paramref name="closeTarget"/> and <paramref name="forceCloseWhenError"/>
            (please look at the comments of those parameters for details).</para>
            You may think of passing <seealso cref="T:System.Collections.Concurrent.BlockingCollection`1"/> with some pre-instrumented
            <seealso cref="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity"/> (in most of the cases, 1 is sufficient) to minimize memory consumption.
            </summary>
            <typeparam name="T">Type of deserialized object</typeparam>
            <param name="source">JSON reader as data source</param>
            <param name="target">target blocking collection to populate deserialied JSON data objects</param>
            <param name="serializer">JSON serializer to use, if not supplied then internally uses <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.AdaptedJsonSerializer(Newtonsoft.Json.JsonReader)"/></param>
            <param name="token">Cancellation token to observe</param>
            <param name="consumerTokenSource">When developing parallel prooducer-consumer pattern and if you wish you
            cancel the consumer side in case of error during json deserialization (producer side),
            pass the source of cancellation token which consumer is observing.</param>
            <param name="disposeSource">If true, <paramref name="source"/> is disposed after the deserialization</param>
            <param name="closeTarget"><para>When this is the ONLY call that populates the <paramref name="target"/>
            keep it true so that when operation finishes the collection is automatically closed for adding so that consumer 
            shall not remain blocked infinitely. If setting false, then you must explicitly call 
            <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> for the obvious reason.</para>
            <para>When this call is one among multiple producers populating the same <paramref name="target"/>,
            it is MANDATORY to set this to false and you must explicitly call <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/>
            when all producers finished populating the collection, otherwise weird things may happen.</para></param>
            <param name="forceCloseWhenError">if true, when any error occurs closes the collection for any additional 
            adding irrespective of <paramref name="closeTarget"/> setting. When false, <paramref name="closeTarget"/>
            setting takes precedence.</param>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.MiscExts">
            <summary>
            Contains miscellaneous extensions method.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.MiscExts.ToPpcEnumerableWithException``1(System.Collections.Concurrent.BlockingCollection{``0},System.Threading.CancellationToken,System.Threading.CancellationTokenSource)">
            <summary>
            Creates an Enumerable out of supplied <paramref name="collection"></paramref> with <seealso cref="F:System.Threading.Timeout.Infinite"/>
            while observing given token. In case of error, cancels the provided token source to signal problem on this leg
            of PPC (Parallel-Producer-Consumer) pattern and raises the error.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection">Collection to enumerate on</param>
            <param name="toObserve">Token to observe for cancellation</param>
            <param name="toCancel">Token source to cancel in case of error (if not already canceled.)</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.MiscExts.ToPpcEnumerable``1(System.Collections.Concurrent.BlockingCollection{``0},System.Threading.CancellationToken,System.Threading.CancellationTokenSource,System.Action{System.Exception})">
            <summary>
            Creates an Enumerable out of supplied <paramref name="collection"></paramref> with <seealso cref="F:System.Threading.Timeout.Infinite"/>
            while observing given token. In case of error, cancels the provided token source to signal problem on this leg
            of PPC (Parallel-Producer-Consumer) pattern and passes the error to supplied <paramref name="errorHandler"/>
            without raising it.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection">Collection to enumerate on</param>
            <param name="toObserve">Token to observe for cancellation</param>
            <param name="toCancel">Token source to cancel in case of error (if not already canceled.)</param>
            <param name="errorHandler">Error handler</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.MiscExts.HasElements(System.Collections.ICollection)">
            <summary>
            Checks that collection is not null and it has at least one (1) element.
            </summary>
            <param name="collection">Collection to check</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.MiscExts.FindMaximums``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Collections.Generic.IComparer{``0},Dot.Net.DevFast.Etc.SortOrder)">
            <summary>
            Enumerates over given <paramref name="itemCollection"/> and finds the
            maximums (up to <paramref name="totalMaximums"/>) items using <paramref name="comparer"/>.
            Returns another enumerable based of required <paramref name="sorting"/>.
            </summary>
            <typeparam name="T">Type of the items in the input collection</typeparam>
            <param name="itemCollection">Input collection</param>
            <param name="totalMaximums">Count of total number of maximum to find.
            Error is thrown if value is negative or zero (0).</param>
            <param name="comparer">Comparer instance. If not provided, then <seealso cref="P:System.Collections.Generic.Comparer`1.Default"/> will be used.</param>
            <param name="sorting">Output sorting (it uses <paramref name="comparer"/>). As the interest is only to find all the required
            number of maximums. It is best to use <seealso cref="F:Dot.Net.DevFast.Etc.SortOrder.None"/> as sorting value
            otherwise, an additional latency might be observed.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.MiscExts.FindMinimums``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Collections.Generic.IComparer{``0},Dot.Net.DevFast.Etc.SortOrder)">
            <summary>
            Enumerates over given <paramref name="itemCollection"/> and finds the
            minimums (up to <paramref name="totalMinimums"/>) items using <paramref name="comparer"/>.
            Returns another enumerable based of required <paramref name="sorting"/>.
            </summary>
            <typeparam name="T">Type of the items in the input collection</typeparam>
            <param name="itemCollection">Input collection</param>
            <param name="totalMinimums">Count of total number of minimum to find.
            Error is thrown if value is negative or zero (0).</param>
            <param name="comparer">Comparer instance. If not provided, then <seealso cref="P:System.Collections.Generic.Comparer`1.Default"/> will be used.</param>
            <param name="sorting">Output sorting (it uses <paramref name="comparer"/>). As the interest is only to find all the required
            number of minimums. It is best to use <seealso cref="F:Dot.Net.DevFast.Etc.SortOrder.None"/> as sorting value
            otherwise, an additional latency might be observed.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.MiscExts.ToTuple``2(``0,``1)">
            <summary>
            Simply creates an instance of <see cref="T:System.Tuple`2"/> and sets <paramref name="t1"/> as <see cref="P:System.Tuple`2.Item1"/>
            and <paramref name="t2"/> as <see cref="P:System.Tuple`2.Item2"/>.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="t1">T1 Instance</param>
            <param name="t2">T2 Instance</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.MiscExts.ToKvp``2(``0,``1)">
            <summary>
            Simply creates an instance of <see cref="T:System.Collections.Generic.KeyValuePair`2"/> and sets <paramref name="key"/> as <see cref="P:System.Collections.Generic.KeyValuePair`2.Key"/>
            and <paramref name="value"/> as <see cref="P:System.Collections.Generic.KeyValuePair`2.Value"/>.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key">TKey Instance</param>
            <param name="value">TValue Instance</param>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.Ppc.AwaitableAdapter`2">
            <summary>
            This class is just a wrapper to recover the consumable item from
            the <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumerBuffer`1"/> in standard way. Actual
            transformation can be implemented inside <see cref="M:Dot.Net.DevFast.Extensions.Ppc.AwaitableAdapter`2.Adapt(`0,System.Threading.CancellationToken)"/>.
            </summary>
            <typeparam name="TP">Produced item type</typeparam>
            <typeparam name="TC">Consumable item type</typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.AwaitableAdapter`2.TryGet(Dot.Net.DevFast.Extensions.Ppc.IConsumerBuffer{`0},System.Threading.CancellationToken,`1@)">
            <summary>
            Standardized implementation to recover single item from buffer.
            Calls <see cref="M:Dot.Net.DevFast.Extensions.Ppc.AwaitableAdapter`2.Adapt(`0,System.Threading.CancellationToken)"/> to perform the desired transformed.
            <para>Returns true when a consumable instance can be created from
            <paramref name="producerDataFeed"/> else returns false.</para>
            </summary>
            <param name="producerDataFeed">Feed that is getting populated by producers.</param>
            <param name="token">Cancellation token</param>
            <param name="consumable">transfomed item that can be passed to consumer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.AwaitableAdapter`2.Adapt(`0,System.Threading.CancellationToken)">
            <summary>
            Will be called to perform the required transformation on all the produced instances.
            </summary>
            <param name="produced">produced item</param>
            <param name="token">cancellation token to observe</param>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.Ppc.AwaitableListAdapter`2">
            <summary>
            Adapter to pack individual items to list of items.
            <para>NOTE:</para>
            <para>1. It does NOT observes <seealso cref="P:Dot.Net.DevFast.Extensions.Ppc.IConsumerBuffer`1.Finished"/> status</para>
            <para>2. The first element is ALWAYS (irrespective of provided timeout value) waited for 
            <seealso cref="F:System.Threading.Timeout.Infinite"/>. Then items are added to list as long as they can be recovered
            before provided millisecond timeout is reached.</para>
            <para>3. Further, items are recovered and populated as long as they are available without
            any wait. Then the list if finalized and returned. Step 2 and 3 are same when inifinite timeout 
            is suplied.</para>
            <para>4. If <see cref="M:Dot.Net.DevFast.Extensions.Ppc.AwaitableListAdapter`2.TryGet(Dot.Net.DevFast.Extensions.Ppc.IConsumerBuffer{`0},System.Threading.CancellationToken,System.Collections.Generic.List{`1}@)"/> returns true, then the list would contains at least 1 item.</para>
            <para>5. List max size would be respected as provided in Ctor.</para>
            <para>6. A call to <see cref="M:Dot.Net.DevFast.Extensions.Ppc.AwaitableListAdapter`2.Adapt(`0,System.Threading.CancellationToken)"/> will be made to perform the instance transformation</para>
            </summary>
            <typeparam name="TP"></typeparam>
            <typeparam name="TC"></typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.AwaitableListAdapter`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Ctor.
            <para>NOTE:</para>
            <para>1. It does NOT observes <seealso cref="P:Dot.Net.DevFast.Extensions.Ppc.IConsumerBuffer`1.Finished"/> status</para>
            <para>2. The first element is ALWAYS (irrespective of provided timeout value) waited for 
            <seealso cref="F:System.Threading.Timeout.Infinite"/>. Then items are added to list as long as they can be recovered
            before provided millisecond timeout is reached.</para>
            <para>3. Further, items are recovered and populated as long as they are available without
            any wait. Then the list if finalized and returned. Step 2 and 3 are same when inifinite timeout 
            is suplied.</para>
            <para>4. If <see cref="M:Dot.Net.DevFast.Extensions.Ppc.AwaitableListAdapter`2.TryGet(Dot.Net.DevFast.Extensions.Ppc.IConsumerBuffer{`0},System.Threading.CancellationToken,System.Collections.Generic.List{`1}@)"/> returns true, then the list would contains at least 1 item.</para>
            <para>5. List max size would be respected as provided in Ctor..</para>
            <para>6. A call to <see cref="M:Dot.Net.DevFast.Extensions.Ppc.AwaitableListAdapter`2.Adapt(`0,System.Threading.CancellationToken)"/> will be made to perform the instance transformation.</para>
            </summary>
            <param name="maxListSize">Max item to be sent in single list instance</param>
            <param name="millisecTimeout">Milliseconds time to observe before finalizing the list</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.AwaitableListAdapter`2.TryGet(Dot.Net.DevFast.Extensions.Ppc.IConsumerBuffer{`0},System.Threading.CancellationToken,System.Collections.Generic.List{`1}@)">
            <summary>
            Return true when a consumable instance can be created from
            <paramref name="producerDataFeed"/> else returns false.
            <para>NOTE:</para>
            <para>1. It does NOT observes <seealso cref="P:Dot.Net.DevFast.Extensions.Ppc.IConsumerBuffer`1.Finished"/> status</para>
            <para>2. The first element is ALWAYS (irrespective of provided timeout value) waited for 
            <seealso cref="F:System.Threading.Timeout.Infinite"/>. Then items are added to list as long as they can be recovered
            before provided millisecond timeout is reached.</para>
            <para>3. Further, items are recovered and populated as long as they are available without
            any wait. Then the list if finalized and returned. Step 2 and 3 are same when inifinite timeout 
            is suplied.</para>
            <para>4. If method returns true, then the list would contains at least 1 item.</para>
            <para>5. List max size would be respected as provided in Ctor.</para>
            </summary>
            <param name="producerDataFeed">Data feed</param>
            <param name="token">token to observe</param>
            <param name="consumable">consumable data instance</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.AwaitableListAdapter`2.Adapt(`0,System.Threading.CancellationToken)">
            <summary>
            Will be called to perform the required transformation on all the produced instances.
            </summary>
            <param name="produced">produced item</param>
            <param name="token">cancellation token to observe</param>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1">
            <summary>
            Consumer interface for parallel Producer consumer pattern.
            </summary>
            <typeparam name="T">Content type</typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1.InitAsync">
            <summary>
            This method is called ONCE before any call is made to <see cref="M:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1.ConsumeAsync(`0,System.Threading.CancellationToken)"/>.
            <para>Similarly, <seealso cref="M:System.IDisposable.Dispose"/> will be called after
            all the calls to <see cref="M:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1.ConsumeAsync(`0,System.Threading.CancellationToken)"/> are done.</para>
            <para>If this method results in an exception, running producers will be signaled to quit producing data
            as soon as possible and the whole pipeline will be destroyed.</para>
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1.ConsumeAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Expect multiple calls to this function as calls are made whenever some data is 
            available from <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IProducer`1"/>.
            <para><seealso cref="M:System.IAsyncDisposable.DisposeAsync"/> will be called when there is 
            NO more data available.</para>
            <para>Method must return as soon as EITHER data consumption is done
            OR some error has occurred.</para>
            <para>Explicit thread safety is NOT required as long as consumer instances are wholly distinct.</para>
            <para><seealso cref="M:System.IAsyncDisposable.DisposeAsync"/> will be called when there is no more
            data available.</para>
            <para>If this method results in an exception, running producers will be signaled to quit producing data
            as soon as possible and the whole pipeline will be destroyed.</para>
            </summary>
            <param name="item">instance to be consumed</param>
            <param name="cancellationToken">Cancellation token</param>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.Ppc.IDataAdapter`2">
            <summary>
            Adapter interface between produced data and consumable data.
            </summary>
            <typeparam name="TProducer">Produced data type</typeparam>
            <typeparam name="TConsumer">Consumable data type</typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.IDataAdapter`2.TryGet(Dot.Net.DevFast.Extensions.Ppc.IConsumerBuffer{`0},System.Threading.CancellationToken,`1@)">
            <summary>
            Must return true when a consumable instance can be created from
            <paramref name="producerDataFeed"/>. Must return false when <paramref name="consumable"/>
            cannot be created; in this case associated consumer will be distroyed.
            <para>This method must be thread safe.</para>
            <para>Must throw all exceptions.</para>
            </summary>
            <param name="producerDataFeed">Data feed</param>
            <param name="token">token to observe while adapting data</param>
            <param name="consumable">consumable data instance</param>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1">
            <summary>
            Interface to expose concurrent producer-consumer pipeline operations.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown">
            <summary>
            Retruns a running task that performs following operations:
            <para>1. Prohibit pipeline to accept any new item</para>
            <para>2. Signals consumers that pipeline is closed for new items</para>
            <para>3. Let consumers to finish consuming remaining queued items</para>
            <para>4. Disposes all consumers</para>
            <para>NOTE:This method is NOT thread-safe</para>
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.UnconsumedCount">
            <summary>
            Returns the count of items currently available awaiting for a free consumer.
            </summary>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.Ppc.IConsumerBuffer`1">
            <summary>
            Feed generated by producers (to be consumed by consumers).
            </summary>
            <typeparam name="T">feed Data type</typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.IConsumerBuffer`1.TryGet(System.Int32,System.Threading.CancellationToken,`0@)">
            <summary>
            Provides the data instances generatd by Producer(s) and returns true. 
            False is returned when no more data is available OR timeout is reached.
            <para>NOTE: It is possible that more data will be available in future,
            thus, check <see cref="P:Dot.Net.DevFast.Extensions.Ppc.IConsumerBuffer`1.Finished"/> before giving up looping.</para>
            </summary>
            <param name="millisecTimeout">Timeout in milliseconds. use <seealso cref="F:System.Threading.Timeout.Infinite"/> 
            to wait inifinitely.</param>
            <param name="token">Cancellation token to observer while extracting data</param>
            <param name="data">Produced data instance, if any</param>
            <exception cref="T:System.OperationCanceledException">If token is canceled</exception>
        </member>
        <member name="P:Dot.Net.DevFast.Extensions.Ppc.IConsumerBuffer`1.Finished">
            <summary>
            Returns true if the data collection would never return an item when calling
            <see cref="M:Dot.Net.DevFast.Extensions.Ppc.IConsumerBuffer`1.TryGet(System.Int32,System.Threading.CancellationToken,`0@)"/> even with <seealso cref="F:System.Threading.Timeout.Infinite"/> timeout.
            </summary>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1">
            <summary>
            Feed generated for consumers (to be populated by producers).
            </summary>
            <typeparam name="T">feed Data type</typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)">
            <summary>
            Adds an item in the feed to be consumed by consumers observing the feed.
            <para>This method is THREAD-SAFE.</para>
            </summary>
            <param name="item">item to add</param>
            <param name="token">Cancellation token to observer while adding data</param>
            <exception cref="T:System.OperationCanceledException">If token is canceled</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tries adding an item in the feed to be consumed by consumers observing the feed.
            Returns true if the item was added before the timeout else false.
            <para>This method is THREAD-SAFE.</para>
            </summary>
            <param name="item">item to add</param>
            <param name="millisecTimeout">timeout in milliseconds</param>
            <param name="token">Cancellation token to observer while adding data</param>
            <exception cref="T:System.OperationCanceledException">If token is canceled</exception>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.Ppc.IProducer`1">
            <summary>
            Producer interface for parallel Producer consumer pattern.
            </summary>
            <typeparam name="T">Content type</typeparam>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.IProducer`1.InitAsync">
            <summary>
            This method is called ONCE before any call is made to <see cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducer`1.ProduceAsync(Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{`0},System.Threading.CancellationToken)"/>.
            <para>Similarly, <seealso cref="M:System.IAsyncDisposable.DisposeAsync"/> will be called after
            the call to <see cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducer`1.ProduceAsync(Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{`0},System.Threading.CancellationToken)"/> are done.</para>
            <para>If this method results in an exception, running consumers will be signaled to quit consuming
            as soon as possible and the whole pipeline will be destroyed.</para>
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.IProducer`1.ProduceAsync(Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{`0},System.Threading.CancellationToken)">
            <summary>
            Call to this method MUST start the data production.
            <para>NOTE: This method is called just ONCE after calling <see cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducer`1.InitAsync"/> 
            this method call must return ONLY WHEN EITHER all the data 
            production is done OR any error has occurred.</para>
            <para>Upon returning from this function, call to <seealso cref="M:System.IAsyncDisposable.DisposeAsync"/>
            will be made.</para>
            <para>If this method results in an exception, running consumers will be signaled to quit consuming
            as soon as possible and the whole pipeline will be destroyed.</para>
            </summary>
            <param name="feedToPopulate">All produced data intances must be added to 
            <paramref name="feedToPopulate"/> instance, in order to pass on to associated consumers.</param>
            <param name="cancellationToken">Cancellation token</param>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.Ppc.PpcExts">
            <summary>
            Extensions for PPC patterns.
            </summary>
            <summary>
            Extensions for PPC patterns.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Action{``0,System.Threading.CancellationToken},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer action and a consumer action instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer action</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Action{``0,System.Threading.CancellationToken},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer function and a consumer action instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer action</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Action{``0,System.Threading.CancellationToken},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and an async consumer action instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumer">consumer action</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer action and a consumer function instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer function</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer and a consumer function instances.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer function</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and an async consumer function instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumer">consumer function</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},Dot.Net.DevFast.Extensions.Ppc.IConsumer{``0},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a synchronous producer action and a consumer instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer instance</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},Dot.Net.DevFast.Extensions.Ppc.IConsumer{``0},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer function and a consumer instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer instance</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},Dot.Net.DevFast.Extensions.Ppc.IConsumer{``0},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and a consumer instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumer">consumer instance</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Collections.Generic.IReadOnlyList{System.Action{``0,System.Threading.CancellationToken}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer action and a consumer action collection instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer action collection</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Collections.Generic.IReadOnlyList{System.Action{``0,System.Threading.CancellationToken}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer function and a consumer action collection instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer action collection</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Collections.Generic.IReadOnlyList{System.Action{``0,System.Threading.CancellationToken}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and an async consumer action collection instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumer">consumer action collection</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Collections.Generic.IReadOnlyList{System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer action and a consumer function collection instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer function collection</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Collections.Generic.IReadOnlyList{System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer and a consumer function collection instances.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer function collection</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Collections.Generic.IReadOnlyList{System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and an async consumer function collection instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumer">consumer function collection</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{``0}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a synchronous producer action and a consumer collection instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer instance collection</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{``0}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer function and a consumer collection instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer instance collection</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{``0}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer instance and a collection of consumers.
            Executes producer and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumers">Collection of consumers</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Action{``0,System.Threading.CancellationToken},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer action collection and a consumer action instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action collection</param>
            <param name="consumer">consumer action</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Action{``0,System.Threading.CancellationToken},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer function collection and a consumer action instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function collection</param>
            <param name="consumer">consumer action</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Action{``0,System.Threading.CancellationToken},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer collection and an async consumer action instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer collection</param>
            <param name="consumer">consumer action</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer action collection and a consumer function instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action collection</param>
            <param name="consumer">consumer function</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer collection and a consumer function instances.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function collection</param>
            <param name="consumer">consumer function</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer collection and an async consumer function instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer collection</param>
            <param name="consumer">consumer function</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},Dot.Net.DevFast.Extensions.Ppc.IConsumer{``0},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a synchronous producer action collection and a consumer instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action collection</param>
            <param name="consumer">consumer instance</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},Dot.Net.DevFast.Extensions.Ppc.IConsumer{``0},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer function collection and a consumer instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function collection</param>
            <param name="consumer">consumer instance</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},Dot.Net.DevFast.Extensions.Ppc.IConsumer{``0},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and a consumer instance.
            Executes producers and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumer">consumer instance</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Collections.Generic.IReadOnlyList{System.Action{``0,System.Threading.CancellationToken}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer action and a consumer action collection instances.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action collection</param>
            <param name="consumer">consumer action collection</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Collections.Generic.IReadOnlyList{System.Action{``0,System.Threading.CancellationToken}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer function and a consumer action collection instances.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function collection</param>
            <param name="consumer">consumer action collection</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Collections.Generic.IReadOnlyList{System.Action{``0,System.Threading.CancellationToken}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and an async consumer action collection instances.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance collection</param>
            <param name="consumer">consumer action collection</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Collections.Generic.IReadOnlyList{System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer action and a consumer function collection instances.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action collection</param>
            <param name="consumer">consumer function collection</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Collections.Generic.IReadOnlyList{System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer and a consumer function collection instances.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function collection</param>
            <param name="consumer">consumer function collection</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Collections.Generic.IReadOnlyList{System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and an async consumer function collection instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance collection</param>
            <param name="consumer">consumer function collection</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{``0}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a synchronous producer action and a consumer collection instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action collection</param>
            <param name="consumer">consumer instance collection</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{``0}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts an async producer function and a consumer collection instance.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function collection</param>
            <param name="consumer">consumer instance collection</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{``0}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer action and a consumer action instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer action</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer function and a consumer action instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer action</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and a consumer action instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumer">consumer action</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer action and a consumer function instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer function</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer function and a consumer function instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer function</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and a consumer function instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumer">consumer function</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer action and a consumer instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer instance</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer function and a consumer instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer instance</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and a consumer instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumer">consumer instance</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Collections.Generic.IReadOnlyList{System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer action and a consumer action instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer action</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Collections.Generic.IReadOnlyList{System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer function and a consumer action instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer action</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Collections.Generic.IReadOnlyList{System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and a consumer action instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumer">consumer action</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Collections.Generic.IReadOnlyList{System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer action and a consumer function instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer function</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Collections.Generic.IReadOnlyList{System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer function and a consumer function instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer function</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Collections.Generic.IReadOnlyList{System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and a consumer function instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumer">consumer function</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer action and a consumer instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer instance</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer function and a consumer instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer instance</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer instance and collection of consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer action and a consumer action instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer action</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer function and a consumer action instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer action</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and a consumer action instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumer">consumer action</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer action and a consumer function instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer function</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer function and a consumer function instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer function</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and a consumer function instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumer">consumer function</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer action and a consumer instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer instance</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer function and a consumer instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer instance</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and a consumer instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producers and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumer">consumer instance</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Collections.Generic.IReadOnlyList{System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer action and a consumer action instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer action</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Collections.Generic.IReadOnlyList{System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer function and a consumer action instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer action</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Collections.Generic.IReadOnlyList{System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and a consumer action instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumer">consumer action</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Collections.Generic.IReadOnlyList{System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer action and a consumer function instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer function</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Collections.Generic.IReadOnlyList{System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer function and a consumer function instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer function</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Collections.Generic.IReadOnlyList{System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and a consumer function instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumer">consumer function</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer action and a consumer instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer action</param>
            <param name="consumer">consumer instance</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer function and a consumer instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer function</param>
            <param name="consumer">consumer instance</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}}},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have max items, but the last one (it would contain
            remaining produced items).
            <para>Minimum acceptable size = 2.</para>
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and a consumer instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumer">consumer instance</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Collections.Generic.IReadOnlyList{System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Collections.Generic.IReadOnlyList{System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Collections.Generic.IReadOnlyList{System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Collections.Generic.IReadOnlyList{System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Collections.Generic.IReadOnlyList{System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Collections.Generic.IReadOnlyList{System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer instance and collection of consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producer and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and a consumer instance, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumer">consumer instance</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Collections.Generic.IReadOnlyList{System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Collections.Generic.IReadOnlyList{System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Collections.Generic.IReadOnlyList{System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Collections.Generic.IReadOnlyList{System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Collections.Generic.IReadOnlyList{System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Collections.Generic.IReadOnlyList{System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, while using an internal
            list adapter (with given <paramref name="listMaxSize"/> and <paramref name="millisecondTimeout"/>) along to transforms the produced data into consumable list.
            Executes producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="T">Produced data type.</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. This is similar
            to using another overloaded version without the <paramref name="millisecondTimeout" />, though,
            provides an improvement when you do NOT want to wait for the SLOW producer to produce items
            to fill the whole list instead would prefer to consume what is available within this timeout.
            </param>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Action{``1,System.Threading.CancellationToken},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Action{``1,System.Threading.CancellationToken},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Action{``1,System.Threading.CancellationToken},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},Dot.Net.DevFast.Extensions.Ppc.IConsumer{``1},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},Dot.Net.DevFast.Extensions.Ppc.IConsumer{``1},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},Dot.Net.DevFast.Extensions.Ppc.IConsumer{``1},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer and a consumer instance, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producer and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumer">consumer instance</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Collections.Generic.IReadOnlyList{System.Action{``1,System.Threading.CancellationToken}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Collections.Generic.IReadOnlyList{System.Action{``1,System.Threading.CancellationToken}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Collections.Generic.IReadOnlyList{System.Action{``1,System.Threading.CancellationToken}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Collections.Generic.IReadOnlyList{System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Collections.Generic.IReadOnlyList{System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Collections.Generic.IReadOnlyList{System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{``1}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{``1}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{``1}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a producer instance and a collection of consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producer and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producer">producer instance</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Action{``1,System.Threading.CancellationToken},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Action{``1,System.Threading.CancellationToken},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Action{``1,System.Threading.CancellationToken},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},Dot.Net.DevFast.Extensions.Ppc.IConsumer{``1},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},Dot.Net.DevFast.Extensions.Ppc.IConsumer{``1},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},Dot.Net.DevFast.Extensions.Ppc.IConsumer{``1},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and a consumer instance, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumer concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumer">consumer instance</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Collections.Generic.IReadOnlyList{System.Action{``1,System.Threading.CancellationToken}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Collections.Generic.IReadOnlyList{System.Action{``1,System.Threading.CancellationToken}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Collections.Generic.IReadOnlyList{System.Action{``1,System.Threading.CancellationToken}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Collections.Generic.IReadOnlyList{System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Collections.Generic.IReadOnlyList{System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Collections.Generic.IReadOnlyList{System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken}},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{``1}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{``1}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipe``2(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IProducer{``0}},System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{``1}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Accepts a collection of producers and consumers, along with an instance of
            data adapter which transforms the produced data into consumable data type. Executes
            producers and consumers concurrently (parallel producer-consumer pattern) while mediating
            data transfer using a buffer of given size (refer <seealso cref="T:Dot.Net.DevFast.Etc.ConcurrentBuffer" /> properties
            for available standard buffer size); at the same time, observing given cancellation token.
            <para>IMPORTANT: Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" /></para>
            <para>
            Upon receiving exception from either producer/consumer instances would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </para>
            </summary>
            <typeparam name="TP">Produced data type</typeparam>
            <typeparam name="TC">Consumable data type</typeparam>
            <param name="producers">Collection of producers</param>
            <param name="consumers">Collection of consumers</param>
            <param name="adapter">data adapter</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">size of data buffer</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``1(System.Action{``0,System.Threading.CancellationToken},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumer" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />).
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="T">
            Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept and <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" />
            will consume
            </typeparam>
            <param name="consumer">consumer</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``1(System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumer" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />).
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="T">
            Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept and <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" />
            will consume
            </typeparam>
            <param name="consumer">consumer</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``1(Dot.Net.DevFast.Extensions.Ppc.IConsumer{``0},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumer" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />).
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="T">
            Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept and <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" />
            will consume
            </typeparam>
            <param name="consumer">consumer</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``1(System.Collections.Generic.IReadOnlyList{System.Action{``0,System.Threading.CancellationToken}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumers" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />).
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="T">
            Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept and <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" />
            will consume
            </typeparam>
            <param name="consumers">consumers</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``1(System.Collections.Generic.IReadOnlyList{System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumers" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />).
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="T">
            Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept and <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" />
            will consume
            </typeparam>
            <param name="consumers">consumers</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{``0}},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumers" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />).
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="T">
            Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept and <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" />
            will consume
            </typeparam>
            <param name="consumers">consumers</param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``1(System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumer" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />) and list-adapter (with given
            <paramref name="listMaxSize" /> and
            <paramref name="millisecondTimeout" />).
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Be careful with <seealso cref="F:System.Threading.Timeout.Infinite" /> timeouts as items in the list will get processed
            only when the list reaches its capacity. In effect, if for long time, no item was added to the pipeline
            item processing will get delayed. On the other hand, 0 as timeout value is very well accepted.
            </description>
            </item>
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="T">
            Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept and whose items list
            <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" /> will consume
            </typeparam>
            <param name="consumer">consumer</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. Be careful with <seealso cref="F:System.Threading.Timeout.Infinite" /> timeouts as
            items in the list will get processed only when the list reaches its capacity. In effect, if for long time,
            no item was added to the pipeline item processing will get delayed. On the other hand, 0 as timeout value is very well accepted.
            </param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``1(System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumer" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />) and list-adapter (with given
            <paramref name="listMaxSize" /> and
            <paramref name="millisecondTimeout" />).
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Be careful with <seealso cref="F:System.Threading.Timeout.Infinite" /> timeouts as items in the list will get processed
            only when the list reaches its capacity. In effect, if for long time, no item was added to the pipeline
            item processing will get delayed. On the other hand, 0 as timeout value is very well accepted.
            </description>
            </item>
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="T">
            Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept and whose items list
            <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" /> will consume
            </typeparam>
            <param name="consumer">consumer</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. Be careful with <seealso cref="F:System.Threading.Timeout.Infinite" /> timeouts as
            items in the list will get processed only when the list reaches its capacity. In effect, if for long time,
            no item was added to the pipeline item processing will get delayed. On the other hand, 0 as timeout value is very well accepted.
            </param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``1(Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumer" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />) and list-adapter (with given
            <paramref name="listMaxSize" /> and
            <paramref name="millisecondTimeout" />).
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Be careful with <seealso cref="F:System.Threading.Timeout.Infinite" /> timeouts as items in the list will get processed
            only when the list reaches its capacity. In effect, if for long time, no item was added to the pipeline
            item processing will get delayed. On the other hand, 0 as timeout value is very well accepted.
            </description>
            </item>
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="T">
            Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept and whose items list
            <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" /> will consume
            </typeparam>
            <param name="consumer">consumer</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. Be careful with <seealso cref="F:System.Threading.Timeout.Infinite" /> timeouts as
            items in the list will get processed only when the list reaches its capacity. In effect, if for long time,
            no item was added to the pipeline item processing will get delayed. On the other hand, 0 as timeout value is very well accepted.
            </param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``1(System.Collections.Generic.IReadOnlyList{System.Action{System.Collections.Generic.List{``0},System.Threading.CancellationToken}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumers" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />) and list-adapter (with given
            <paramref name="listMaxSize" /> and
            <paramref name="millisecondTimeout" />).
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Be careful with <seealso cref="F:System.Threading.Timeout.Infinite" /> timeouts as items in the list will get processed
            only when the list reaches its capacity. In effect, if for long time, no item was added to the pipeline
            item processing will get delayed. On the other hand, 0 as timeout value is very well accepted.
            </description>
            </item>
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="T">
            Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept and whose items list
            <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" /> will consume
            </typeparam>
            <param name="consumers">consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. Be careful with <seealso cref="F:System.Threading.Timeout.Infinite" /> timeouts as
            items in the list will get processed only when the list reaches its capacity. In effect, if for long time,
            no item was added to the pipeline item processing will get delayed. On the other hand, 0 as timeout value is very well accepted.
            </param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``1(System.Collections.Generic.IReadOnlyList{System.Func{System.Collections.Generic.List{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumers" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />) and list-adapter (with given
            <paramref name="listMaxSize" /> and
            <paramref name="millisecondTimeout" />).
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Be careful with <seealso cref="F:System.Threading.Timeout.Infinite" /> timeouts as items in the list will get processed
            only when the list reaches its capacity. In effect, if for long time, no item was added to the pipeline
            item processing will get delayed. On the other hand, 0 as timeout value is very well accepted.
            </description>
            </item>
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="T">
            Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept and whose items list
            <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" /> will consume
            </typeparam>
            <param name="consumers">consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. Be careful with <seealso cref="F:System.Threading.Timeout.Infinite" /> timeouts as
            items in the list will get processed only when the list reaches its capacity. In effect, if for long time,
            no item was added to the pipeline item processing will get delayed. On the other hand, 0 as timeout value is very well accepted.
            </param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``1(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{System.Collections.Generic.List{``0}}},System.Int32,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumers" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />) and list-adapter (with given
            <paramref name="listMaxSize" /> and
            <paramref name="millisecondTimeout" />).
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Be careful with <seealso cref="F:System.Threading.Timeout.Infinite" /> timeouts as items in the list will get processed
            only when the list reaches its capacity. In effect, if for long time, no item was added to the pipeline
            item processing will get delayed. On the other hand, 0 as timeout value is very well accepted.
            </description>
            </item>
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="T">
            Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept and whose items list
            <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" /> will consume
            </typeparam>
            <param name="consumers">consumers</param>
            <param name="listMaxSize">
            Maximum number of items to be in the list given to consumer.
            Basically, all the list will have AT LEAST 1 item and maximum this given size.
            </param>
            <param name="millisecondTimeout">
            Maximum time to await on produced items. Be careful with <seealso cref="F:System.Threading.Timeout.Infinite" /> timeouts as
            items in the list will get processed only when the list reaches its capacity. In effect, if for long time,
            no item was added to the pipeline item processing will get delayed. On the other hand, 0 as timeout value is very well accepted.
            </param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``2(System.Action{``1,System.Threading.CancellationToken},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumer" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />) and <paramref name="adapter" />.
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="TP">Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept</typeparam>
            <typeparam name="TC">Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" /> is able to consume</typeparam>
            <param name="consumer">consumer</param>
            <param name="adapter">
            adapter instance to create instances of type <typeparamref name="TC" /> from the instances
            of type <typeparamref name="TP" />
            </param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``2(System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumer" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />) and <paramref name="adapter" />.
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="TP">Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept</typeparam>
            <typeparam name="TC">Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" /> is able to consume</typeparam>
            <param name="consumer">consumer</param>
            <param name="adapter">
            adapter instance to create instances of type <typeparamref name="TC" /> from the instances
            of type <typeparamref name="TP" />
            </param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``2(Dot.Net.DevFast.Extensions.Ppc.IConsumer{``1},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumer" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />) and <paramref name="adapter" />.
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="TP">Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept</typeparam>
            <typeparam name="TC">Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" /> is able to consume</typeparam>
            <param name="consumer">consumer</param>
            <param name="adapter">
            adapter instance to create instances of type <typeparamref name="TC" /> from the instances
            of type <typeparamref name="TP" />
            </param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``2(System.Collections.Generic.IReadOnlyList{System.Action{``1,System.Threading.CancellationToken}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumers" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />) and <paramref name="adapter" />.
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="TP">Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept</typeparam>
            <typeparam name="TC">Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" /> is able to consume</typeparam>
            <param name="consumers">consumers</param>
            <param name="adapter">
            adapter instance to create instances of type <typeparamref name="TC" /> from the instances
            of type <typeparamref name="TP" />
            </param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``2(System.Collections.Generic.IReadOnlyList{System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumers" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />) and <paramref name="adapter" />.
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="TP">Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept</typeparam>
            <typeparam name="TC">Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" /> is able to consume</typeparam>
            <param name="consumers">consumers</param>
            <param name="adapter">
            adapter instance to create instances of type <typeparamref name="TC" /> from the instances
            of type <typeparamref name="TP" />
            </param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.Ppc.PpcExts.Pipeline``2(System.Collections.Generic.IReadOnlyList{Dot.Net.DevFast.Extensions.Ppc.IConsumer{``1}},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Creates and returns an instance of <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> as an end-point to accept data while
            executing given <paramref name="consumers" /> concurrently. Pipeline is responcible for data transfer with the help
            of a buffer (with size= <paramref name="bufferSize" />) and <paramref name="adapter" />.
            <para>Ideally, this instance one would like to use as a singleton for the application life time.</para>
            <para>IMPORTANT:</para>
            <list type="number">
            <item>
            <description>
            Unbounded buffer size is represented by <seealso cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded" />
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> (as documented) should be called only after it is
            certain no
            more calls to <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> will be made, to avoid unexpected errors.
            </description>
            </item>
            <item>
            <description>
            Upon receiving exception from any of consumer instance would result in the destruction of the
            pipeline (all producers and consumers will be destroyed including the queued data)
            </description>
            </item>
            <item>
            <description>
            <seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer`1.Add(`0,System.Threading.CancellationToken)" /> method:
            <list type="bullet">
            <item>
            <description>is Thread-safe and can be called concurrently.</description>
            </item>
            <item>
            <description>
            throws <seealso cref="T:System.OperationCanceledException" /> when either
            <paramref name="token" /> is cancelled or any of the consumers ends-up throwing an
            exception
            (<seealso cref="M:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1.TearDown" /> or
            <seealso cref="M:System.IDisposable.Dispose" /> might not have been called at
            this moment, but, at least all the consumers are disposed)
            </description>
            </item>
            </list>
            </description>
            </item>
            </list>
            </summary>
            <typeparam name="TP">Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IPipeline`1" /> will accept</typeparam>
            <typeparam name="TC">Type of items <seealso cref="T:Dot.Net.DevFast.Extensions.Ppc.IConsumer`1" /> is able to consume</typeparam>
            <param name="consumers">consumers</param>
            <param name="adapter">
            adapter instance to create instances of type <typeparamref name="TC" /> from the instances
            of type <typeparamref name="TP" />
            </param>
            <param name="token">cancellation token to observe</param>
            <param name="bufferSize">buffer size</param>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.ReflectionExts">
            <summary>
            Extension methods related to reflection.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ReflectionExts.InvokeNonValueMethodAsync(System.Type,System.String,System.Type[],System.Object[],System.Object,System.Reflection.BindingFlags)">
            <summary>
            Finds Generic method using <paramref name="methodName"/> inside <paramref name="declaringType"/>,
            then, invokes it using given <paramref name="classInstance"/>
            and <paramref name="methodParameters"/> and finally awaits on the invocation.
            See also <seealso cref="M:Dot.Net.DevFast.Extensions.ReflectionExts.InvokeNonValueMethodAsync(System.Reflection.MethodInfo,System.Object[],System.Object)"/>.
            <para>
            Method MUST return either <see langword="void"/> or a <see cref="T:System.Threading.Tasks.Task"/>.
            </para>
            </summary>
            <param name="declaringType">Type that contains the method</param>
            <param name="methodName">Name of the method. HINT: Use <see langword="nameof"/> instead
            of passing hard-coded string to avoid any refactoring changes.</param>
            <param name="methodGenerics">Generic types to apply on the method; if any.</param>
            <param name="methodParameters">Parameters to pass to method; if any.</param>
            <param name="classInstance">Instance of the class (if method is not static).
            For static methods keep this value <see langword="null"/></param>
            <param name="bindingFlags">Binding flags to use to find the correct method.</param>
            <exception cref="T:System.ArgumentException">When method return type cannot be assigned to <see cref="T:System.Threading.Tasks.Task"/>
            nor to <see langword="void"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ReflectionExts.InvokeNonValueMethodAsync(System.Reflection.MethodInfo,System.Object[],System.Object)">
            <summary>
            Invokes the provided <paramref name="method"/> with given <paramref name="classInstance"/>
            and <paramref name="methodParameters"/> and awaits on the invocation.
            <para>
            Method MUST return either <see langword="void"/> or a <see cref="T:System.Threading.Tasks.Task"/>.
            </para>
            </summary>
            <param name="method">Method to invoke.</param>
            <param name="methodParameters">Parameters to pass to method; if any.</param>
            <param name="classInstance">Instance of the class (if method is not static).
            For static methods keep this value <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">When method return type cannot be assigned to <see cref="T:System.Threading.Tasks.Task"/>
            nor to <see langword="void"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ReflectionExts.InvokeValueMethodAsync``1(System.Type,System.String,System.Type[],System.Object[],System.Object,System.Reflection.BindingFlags)">
            <summary>
            Finds generic method using <paramref name="methodName"/> inside <paramref name="declaringType"/>,
            then, invokes it using given <paramref name="classInstance"/>
            and <paramref name="methodParameters"/> and finally awaits on the invocation.
            See also <seealso cref="M:Dot.Net.DevFast.Extensions.ReflectionExts.InvokeValueMethodAsync``1(System.Reflection.MethodInfo,System.Object[],System.Object)"/>.
            <para>
            Method MUST return either a <see cref="T:System.Threading.Tasks.Task`1"/> OR
            an instance of <typeparamref name="TResult"/> OR
            a derived type of <typeparamref name="TResult"/> (derived type with or without Task).
            </para>
            </summary>
            <typeparam name="TResult">Method return type.</typeparam>
            <param name="declaringType">Type that contains the method</param>
            <param name="methodName">Name of the method. HINT: Use <see langword="nameof"/> instead
            of passing hard-coded string to avoid any refactoring changes.</param>
            <param name="methodGenerics">Generic types to apply on the method; if any.</param>
            <param name="methodParameters">Parameters to pass to method; if any.</param>
            <param name="classInstance">Instance of the class (if method is not static).
            For static methods keep this value <see langword="null"/></param>
            <param name="bindingFlags">Binding flags to use to find the correct method.</param>
            <exception cref="T:System.ArgumentException">When method return type cannot be assigned to <see cref="T:System.Threading.Tasks.Task`1"/>
            nor to <typeparamref name="TResult"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ReflectionExts.InvokeValueMethodAsync``1(System.Reflection.MethodInfo,System.Object[],System.Object)">
            <summary>
            Invokes the provided <paramref name="method"/> with given <paramref name="classInstance"/>
            and <paramref name="methodParameters"/> and awaits on the invocation.
            <para>
            Method MUST return either a <see cref="T:System.Threading.Tasks.Task`1"/> OR
            an instance of <typeparamref name="TResult"/> OR
            a derived type of <typeparamref name="TResult"/> (derived type with or without Task).
            </para>
            </summary>
            <param name="method">Method to invoke.</param>
            <param name="methodParameters">Parameters to pass to method; if any.</param>
            <param name="classInstance">Instance of the class (if method is not static).
            For static methods keep this value <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">When method return type cannot be assigned to <see cref="T:System.Threading.Tasks.Task`1"/>
            nor to <typeparamref name="TResult"/></exception>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext">
            <summary>
            Class that provides extensions to perform Base64 string operations
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.ToBase64(System.String,System.Base64FormattingOptions,System.Text.Encoding)">
            <summary>
            Converts the input string to Base64 string.
            <para>Ecoding's Preamable is NOT injected</para>
            </summary>
            <param name="input">UTF8 string</param>
            <param name="options">Options to use for the transformation</param>
            <param name="encoding">Encoding to use to get string bytes, if not supplied UTF8 is used</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.ToBase64(System.Byte[],System.Base64FormattingOptions)">
            <summary>
            Converts the whole <paramref name="input"/> array to Base64 string.
            <para>Ecoding's Preamable is NOT injected</para>
            <para>Refer to <see cref="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.ToBase64(System.ArraySegment{System.Byte},System.Base64FormattingOptions)"/> to perform
            conversion on a segment of the array</para>
            </summary>
            <param name="input">Input byte array</param>
            <param name="options">Options to use for the transformation</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.ToBase64(System.ArraySegment{System.Byte},System.Base64FormattingOptions)">
            <summary>
            Converts the segment of the <paramref name="input"/> to Base64 string.
            <para>Ecoding's Preamable is NOT injected</para>
            <para>Refer to <see cref="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.ToBase64(System.Byte[],System.Base64FormattingOptions)"/> to perform
            conversion on full array</para>
            </summary>
            <param name="input">Input byte array</param>
            <param name="options">Options to use for the transformation</param>
            <exception cref="T:System.NullReferenceException">if <paramref name="input"/> is null</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.FromBase64(System.String,System.Text.Encoding)">
            <summary>
            Converts the <paramref name="base64"/> to string for given encoding.
            </summary>
            <param name="base64">Base64 string</param>
            <param name="encoding">Encoding to use during byte to string transformations.
            <para>If null is supplied then UTF-8 encoding is used as default with the possibility
            to detect encoding from byte order mark.</para></param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.FromBase64(System.String)">
            <summary>
            Converts the <paramref name="base64"/> to unencoded byte array.
            <para>Expect all base64 transformation related exceptions</para>
            </summary>
            <param name="base64">Base64 string</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.ToBase64Async(System.Byte[],System.IO.Stream,System.Boolean)">
            <summary>
            Reads <paramref name="input"/> bytes and writes Base64 data on <paramref name="targetStream"/>.
            <para>NOTE: <paramref name="targetStream"/> is NEITHER closed NOR disposed inside this operation.
            Only Flush is performed.</para>
            </summary>
            <param name="input">String to convert</param>
            <param name="targetStream">Stream to write base64 data to.</param>
            <param name="disposeOutput">If true, disposes <paramref name="targetStream"/> upon operation completion, else leaves it open</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.ToBase64Async(System.Byte[],System.IO.Stream,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Reads <paramref name="input"/> bytes and writes Base64 data on <paramref name="targetStream"/>
            while observing <paramref name="token"/> for cancellation.
            <para>NOTE: <paramref name="targetStream"/> is NEITHER closed NOR disposed inside this operation.
            Only Flush is performed.</para>
            </summary>
            <param name="input">String to convert</param>
            <param name="targetStream">Stream to write base64 data to.</param>
            <param name="token">Cancellation token</param>
            <param name="disposeOutput">If true, disposes <paramref name="targetStream"/> upon operation completion, else leaves it open</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.ToBase64Async(System.ArraySegment{System.Byte},System.IO.Stream,System.Boolean)">
            <summary>
            Reads <paramref name="input"/> byte segment and writes Base64 data on <paramref name="targetStream"/>.
            <para>NOTE: <paramref name="targetStream"/> is NEITHER closed NOR disposed inside this operation.
            Only Flush is performed.</para>
            </summary>
            <param name="input">String to convert</param>
            <param name="targetStream">Stream to write base64 data to.</param>
            <param name="disposeOutput">If true, disposes <paramref name="targetStream"/> upon operation completion, else leaves it open</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.ToBase64Async(System.ArraySegment{System.Byte},System.IO.Stream,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Reads <paramref name="input"/> byte segment and writes Base64 data on <paramref name="targetStream"/>
            while observing <paramref name="token"/> for cancellation.
            <para>NOTE: <paramref name="targetStream"/> is NEITHER closed NOR disposed inside this operation.
            Only Flush is performed.</para>
            </summary>
            <param name="input">String to convert</param>
            <param name="targetStream">Stream to write base64 data to.</param>
            <param name="token">Cancellation token</param>
            <param name="disposeOutput">If true, disposes <paramref name="targetStream"/> upon operation completion, else leaves it open</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.ToBase64Async(System.String,System.IO.Stream,System.Boolean,System.Text.Encoding,System.Int32)">
            <summary>
            Reads characters from <paramref name="input"/> and writes Base64 data on <paramref name="targetStream"/>, 
            using <paramref name="encoding"/>.
            </summary>
            <param name="input">String to convert</param>
            <param name="targetStream">Stream to write base64 data to.</param>
            <param name="disposeOutput">If true, disposes <paramref name="targetStream"/> upon operation completion, else leaves it open</param>
            <param name="encoding">Encoding to use to get string bytes, if not supplied UTF8 is used</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.ToBase64Async(System.String,System.IO.Stream,System.Threading.CancellationToken,System.Boolean,System.Text.Encoding,System.Int32)">
            <summary>
            Reads characters from <paramref name="input"/> and writes Base64 data on <paramref name="targetStream"/>, 
            using <paramref name="encoding"/>, while observing <paramref name="token"/> for cancellation.
            </summary>
            <param name="input">String to convert</param>
            <param name="targetStream">Stream to write base64 data to.</param>
            <param name="token">Cancellation token</param>
            <param name="disposeOutput">If true, disposes <paramref name="targetStream"/> upon operation completion, else leaves it open</param>
            <param name="encoding">Encoding to use to get string bytes, if not supplied UTF8 is used</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.ToBase64Async(System.Text.StringBuilder,System.IO.Stream,System.Boolean,System.Text.Encoding,System.Int32)">
            <summary>
            Reads characters from <paramref name="input"/> and writes Base64 data on <paramref name="targetStream"/>, 
            using <paramref name="encoding"/>.
            </summary>
            <param name="input">StringBuilder whose String to convert</param>
            <param name="targetStream">Stream to write base64 data to.</param>
            <param name="disposeOutput">If true, disposes <paramref name="targetStream"/> upon operation completion, else leaves it open</param>
            <param name="encoding">Encoding to use to get string bytes, if not supplied UTF8 is used</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.ToBase64Async(System.Text.StringBuilder,System.IO.Stream,System.Threading.CancellationToken,System.Boolean,System.Text.Encoding,System.Int32)">
            <summary>
            Reads characters from <paramref name="input"/> and writes Base64 data on <paramref name="targetStream"/>, 
            using <paramref name="encoding"/>, while observing <paramref name="token"/> for cancellation.
            </summary>
            <param name="input">StringBuilder whose String to convert</param>
            <param name="targetStream">Stream to write base64 data to.</param>
            <param name="token">Cancellation token</param>
            <param name="disposeOutput">If true, disposes <paramref name="targetStream"/> upon operation completion, else leaves it open</param>
            <param name="encoding">Encoding to use to get string bytes, if not supplied UTF8 is used</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.ToBase64Async(System.IO.Stream,System.IO.Stream,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Reads from <paramref name="sourceStream"/> and writes Base64 data on <paramref name="targetStream"/>.
            </summary>
            <param name="sourceStream">Stream to read from</param>
            <param name="targetStream">Stream to write base64 data to.</param>
            <param name="disposeInput">If true, disposes <paramref name="sourceStream"/> upon operation completion, else leaves it open</param>
            <param name="disposeOutput">If true, disposes <paramref name="targetStream"/> upon operation completion, else leaves it open</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.ToBase64Async(System.IO.Stream,System.IO.Stream,System.Threading.CancellationToken,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Reads from <paramref name="sourceStream"/> and writes Base64 data on <paramref name="targetStream"/>,
            while observing <paramref name="token"/>.
            </summary>
            <param name="sourceStream">Stream to read from</param>
            <param name="targetStream">Stream to write base64 data to.</param>
            <param name="token">Cancellation token</param>
            <param name="disposeInput">If true, disposes <paramref name="sourceStream"/> upon operation completion, else leaves it open</param>
            <param name="disposeOutput">If true, disposes <paramref name="targetStream"/> upon operation completion, else leaves it open</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.FromBase64Async(System.IO.Stream,System.IO.Stream,System.Security.Cryptography.FromBase64TransformMode,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Reads Base64 data from <paramref name="sourceStream"/> and writes decoded data on <paramref name="targetStream"/>,
            with <paramref name="bufferSize"/>.
            </summary>
            <param name="sourceStream">Stream to read Base64 data from</param>
            <param name="targetStream">Stream to write decoded data to</param>
            <param name="mode">transformation mode to use</param>
            <param name="disposeInput">If true, disposes <paramref name="sourceStream"/> upon operation completion, else leaves it open</param>
            <param name="disposeOutput">If true, disposes <paramref name="targetStream"/> upon operation completion, else leaves it open</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.FromBase64Async(System.IO.Stream,System.IO.Stream,System.Threading.CancellationToken,System.Security.Cryptography.FromBase64TransformMode,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Reads Base64 data from <paramref name="sourceStream"/> and writes unencoded data on <paramref name="targetStream"/>,
            with <paramref name="bufferSize"/>, while observing <paramref name="token"/>.
            </summary>
            <param name="sourceStream">Stream to read Base64 data from</param>
            <param name="targetStream">Stream to write unencoded data to.</param>
            <param name="token">Cancellation token</param>
            <param name="mode">transformation mode to use</param>
            <param name="disposeInput">If true, disposes <paramref name="sourceStream"/> upon operation completion, else leaves it open</param>
            <param name="disposeOutput">If true, disposes <paramref name="targetStream"/> upon operation completion, else leaves it open</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.FromBase64Async(System.IO.Stream,System.Text.StringBuilder,System.Security.Cryptography.FromBase64TransformMode,System.Boolean,System.Text.Encoding,System.Int32)">
            <summary>
            Reads Base64 data from <paramref name="sourceStream"/> and appends decoded string to <paramref name="appendTo"/>,
            with <paramref name="bufferSize"/>.
            </summary>
            <param name="sourceStream">Stream to read Base64 data from</param>
            <param name="appendTo">Stream to write decoded data to</param>
            <param name="mode">transformation mode to use</param>
            <param name="disposeInput">If true, disposes <paramref name="sourceStream"/> upon operation completion, else leaves it open</param>
            <param name="encoding">Encoding to use to get string bytes, if not supplied UTF8 is used</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.FromBase64Async(System.IO.Stream,System.Text.StringBuilder,System.Threading.CancellationToken,System.Security.Cryptography.FromBase64TransformMode,System.Boolean,System.Text.Encoding,System.Int32)">
            <summary>
            Reads Base64 data from <paramref name="sourceStream"/> and appends decoded string to <paramref name="appendTo"/>,
            with <paramref name="bufferSize"/>, while observing <paramref name="token"/>.
            </summary>
            <param name="sourceStream">Stream to read Base64 data from</param>
            <param name="appendTo">Stream to write decoded data to</param>
            <param name="token">Cancellation token</param>
            <param name="mode">transformation mode to use</param>
            <param name="disposeInput">If true, disposes <paramref name="sourceStream"/> upon operation completion, else leaves it open</param>
            <param name="encoding">Encoding to use to get string bytes, if not supplied UTF8 is used</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.FromBase64AsStringAsync(System.IO.Stream,System.Security.Cryptography.FromBase64TransformMode,System.Boolean,System.Text.Encoding,System.Int32)">
            <summary>
            Reads Base64 data from <paramref name="sourceStream"/> and prepares decoded string (return value),
            with <paramref name="bufferSize"/>.
            </summary>
            <param name="sourceStream">Stream to read Base64 data from</param>
            <param name="mode">transformation mode to use</param>
            <param name="disposeInput">If true, disposes <paramref name="sourceStream"/> upon operation completion, else leaves it open</param>
            <param name="encoding">Encoding to use to get string bytes, if not supplied UTF8 is used</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.FromBase64AsStringAsync(System.IO.Stream,System.Threading.CancellationToken,System.Security.Cryptography.FromBase64TransformMode,System.Boolean,System.Text.Encoding,System.Int32)">
            <summary>
            Reads Base64 data from <paramref name="sourceStream"/> and prepares decoded string (return value),
            with <paramref name="bufferSize"/>, while observing <paramref name="token"/>.
            </summary>
            <param name="sourceStream">Stream to read Base64 data from</param>
            <param name="token">Cancellation token</param>
            <param name="mode">transformation mode to use</param>
            <param name="disposeInput">If true, disposes <paramref name="sourceStream"/> upon operation completion, else leaves it open</param>
            <param name="encoding">Encoding to use to get string bytes, if not supplied <seealso cref="P:System.Text.Encoding.UTF8"/> is used</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.FromBase64Async(System.IO.Stream,System.Security.Cryptography.FromBase64TransformMode,System.Boolean,System.Int32)">
            <summary>
            Reads Base64 data from <paramref name="sourceStream"/> and prepares decoded byte array (return value),
            with <paramref name="bufferSize"/>.
            </summary>
            <param name="sourceStream">Stream to read Base64 data from</param>
            <param name="mode">transformation mode to use</param>
            <param name="disposeInput">If true, disposes <paramref name="sourceStream"/> upon operation completion, else leaves it open</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.FromBase64Async(System.IO.Stream,System.Threading.CancellationToken,System.Security.Cryptography.FromBase64TransformMode,System.Boolean,System.Int32)">
            <summary>
            Reads Base64 data from <paramref name="sourceStream"/> and prepares decoded byte array (return value),
            with <paramref name="bufferSize"/>, while observing <paramref name="token"/>.
            </summary>
            <param name="sourceStream">Stream to read Base64 data from</param>
            <param name="token">Cancellation token</param>
            <param name="mode">transformation mode to use</param>
            <param name="disposeInput">If true, disposes <paramref name="sourceStream"/> upon operation completion, else leaves it open</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.FromBase64AsSegmentAsync(System.IO.Stream,System.Security.Cryptography.FromBase64TransformMode,System.Boolean,System.Int32)">
            <summary>
            Reads Base64 data from <paramref name="sourceStream"/> and prepares decoded byte array, (return as segment, 
            idea is to save on array copy to remain low on latency n memory as perhaps segment can serve the purpose),
            with <paramref name="bufferSize"/>.
            </summary>
            <param name="sourceStream">Stream to read Base64 data from</param>
            <param name="mode">transformation mode to use</param>
            <param name="disposeInput">If true, disposes <paramref name="sourceStream"/> upon operation completion, else leaves it open</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.Base64Ext.FromBase64AsSegmentAsync(System.IO.Stream,System.Threading.CancellationToken,System.Security.Cryptography.FromBase64TransformMode,System.Boolean,System.Int32)">
            <summary>
            Reads Base64 data from <paramref name="sourceStream"/> and prepares decoded byte array, (return as segment, 
            idea is to save on array copy to remain low on latency n memory as perhaps segment can serve the purpose),
            with <paramref name="bufferSize"/>, while observing <paramref name="token"/>.
            </summary>
            <param name="sourceStream">Stream to read Base64 data from</param>
            <param name="token">Cancellation token</param>
            <param name="mode">transformation mode to use</param>
            <param name="disposeInput">If true, disposes <paramref name="sourceStream"/> upon operation completion, else leaves it open</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.StreamExt.CryptoStreamExt">
            <summary>
            Extensions on Cypto stream for data transformation.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.CryptoStreamExt.TransformAsync(System.ArraySegment{System.Byte},System.Security.Cryptography.ICryptoTransform,System.IO.Stream,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Reads byte segment from <paramref name="source"/> and writes transformed data on <paramref name="output"/>,
            using <paramref name="transform"/>, while observing <paramref name="token"/>.
            </summary>
            <param name="source">Bytes to transform</param>
            <param name="transform">transform to use</param>
            <param name="output">Stream to write transformed data to.</param>
            <param name="token">Cancellation token</param>
            <param name="disposeOutput">If true, disposes <paramref name="output"/> upon operation completion, else leaves it open</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.CryptoStreamExt.TransformAsync(System.Byte[],System.Security.Cryptography.ICryptoTransform,System.IO.Stream,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Reads full <paramref name="source"/> array and writes transformed data on <paramref name="output"/>,
            using <paramref name="transform"/>, while observing <paramref name="token"/>.
            </summary>
            <param name="source">Bytes to transform</param>
            <param name="transform">transform to use</param>
            <param name="output">Stream to write transformed data to.</param>
            <param name="token">Cancellation token</param>
            <param name="disposeOutput">If true, disposes <paramref name="output"/> upon operation completion, else leaves it open</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.CryptoStreamExt.TransformAsync(System.IO.Stream,System.Security.Cryptography.ICryptoTransform,System.IO.Stream,System.Threading.CancellationToken,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Reads from <paramref name="input"/> and writes transformed data on <paramref name="output"/>,
            using <paramref name="transform"/>, while observing <paramref name="token"/>.
            </summary>
            <param name="input">Stream to read from</param>
            <param name="transform">transform to use</param>
            <param name="output">Stream to write transformed data to.</param>
            <param name="token">Cancellation token</param>
            <param name="disposeInput">If true, disposes <paramref name="input"/> upon operation completion, else leaves it open</param>
            <param name="disposeOutput">If true, disposes <paramref name="output"/> upon operation completion, else leaves it open</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.CryptoStreamExt.TransformAsync(System.Text.StringBuilder,System.Security.Cryptography.ICryptoTransform,System.IO.Stream,System.Threading.CancellationToken,System.Boolean,System.Text.Encoding,System.Int32)">
            <summary>
            Reads characters from <paramref name="source"/> and writes transformed data on <paramref name="output"/>,
            using <paramref name="transform"/> and <paramref name="encoding"/> while observing 
            <paramref name="token"/> for cancellation.
            </summary>
            <param name="source">String to convert</param>
            <param name="transform">transform to use</param>
            <param name="output">Stream to write transformed data to.</param>
            <param name="token">Cancellation token</param>
            <param name="disposeOutput">If true, disposes <paramref name="output"/> upon operation completion, else leaves it open</param>
            <param name="encoding">Encoding to use to get string bytes, if not supplied <seealso cref="P:System.Text.Encoding.UTF8"/> is used</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.CryptoStreamExt.TransformAsync(System.String,System.Security.Cryptography.ICryptoTransform,System.IO.Stream,System.Threading.CancellationToken,System.Boolean,System.Text.Encoding,System.Int32)">
            <summary>
            Reads characters from <paramref name="source"/> and writes transformed data on <paramref name="output"/>, 
            using <paramref name="transform"/> and <paramref name="encoding"/> while observing <paramref name="token"/> for cancellation.
            </summary>
            <param name="source">String to convert</param>
            <param name="transform">transform to use</param>
            <param name="output">Stream to write transformed data to.</param>
            <param name="token">Cancellation token</param>
            <param name="disposeOutput">If true, disposes <paramref name="output"/> upon operation completion, else leaves it open</param>
            <param name="encoding">Encoding to use to get string bytes, if not supplied <seealso cref="P:System.Text.Encoding.UTF8"/> is used</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.CryptoStreamExt.TransformAsync(System.IO.Stream,System.Security.Cryptography.ICryptoTransform,System.Threading.CancellationToken,System.Boolean,System.Int32)">
            <summary>
            Reads from <paramref name="input"/> and prepares decoded byte array (return value),
            using <paramref name="transform"/>, while observing <paramref name="token"/>.
            </summary>
            <param name="input">Stream to read from</param>
            <param name="transform">transform to use</param>
            <param name="token">Cancellation token</param>
            <param name="disposeInput">If true, disposes <paramref name="input"/> upon operation completion, else leaves it open</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.CryptoStreamExt.TransformAsSegmentAsync(System.IO.Stream,System.Security.Cryptography.ICryptoTransform,System.Threading.CancellationToken,System.Boolean,System.Int32)">
            <summary>
            Reads from <paramref name="input"/> and prepares decoded byte array, (return as segment, 
            idea is to save on array copy to remain low on latency n memory as perhaps segment can serve the purpose),
            using <paramref name="transform"/>, while observing <paramref name="token"/>.
            </summary>
            <param name="input">Stream to read from</param>
            <param name="transform">transform to use</param>
            <param name="token">Cancellation token</param>
            <param name="disposeInput">If true, disposes <paramref name="input"/> upon operation completion, else leaves it open</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.CryptoStreamExt.TransformAsStringAsync(System.IO.Stream,System.Security.Cryptography.ICryptoTransform,System.Text.Encoding,System.Threading.CancellationToken,System.Boolean,System.Int32)">
            <summary>
            Reads from <paramref name="input"/> and prepares transformed string (return value),
            using <paramref name="transform"/> and <paramref name="encoding"/>, while observing <paramref name="token"/>.
            </summary>
            <param name="input">Stream to read from</param>
            <param name="transform">transform to use</param>
            <param name="token">Cancellation token</param>
            <param name="disposeInput">If true, disposes <paramref name="input"/> upon operation completion, else leaves it open</param>
            <param name="encoding">Encoding to use to compose string characters, if not supplied <seealso cref="P:System.Text.Encoding.UTF8"/> is used</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamExt.CryptoStreamExt.TransformAsync(System.IO.Stream,System.Security.Cryptography.ICryptoTransform,System.Text.StringBuilder,System.Threading.CancellationToken,System.Boolean,System.Text.Encoding,System.Int32,System.Boolean)">
            <summary>
            Reads from <paramref name="input"/> and appends transformed string to <paramref name="target"/>,
            using <paramref name="transform"/> and <paramref name="encoding"/>, while observing <paramref name="token"/>.
            </summary>
            <param name="input">Stream to read from</param>
            <param name="transform">transform to use</param>
            <param name="target">StringBuilder to write transformed data to.</param>
            <param name="token">Cancellation token</param>
            <param name="disposeInput">If true, disposes <paramref name="input"/> upon operation completion, else leaves it open</param>
            <param name="encoding">Encoding to use to compose string characters, if not supplied <seealso cref="P:System.Text.Encoding.UTF8"/> is used</param>
            <param name="bufferSize">Buffer size</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts">
            <summary>
            Extensions methods on stream pipes.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Pull(System.IO.DirectoryInfo,System.String,System.Int32,System.IO.FileOptions)">
            <summary>
            Pulls underlying data of the given file as byte stream and returns a new pipe for chaining.
            </summary>
            <param name="folder">Parent folder of the file</param>
            <param name="filename">An existing readable file's name with extension</param>
            <param name="fileStreamBuffer">Buffer size to use</param>
            <param name="options">File options</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Pull(System.IO.FileInfo,System.Int32,System.IO.FileOptions)">
            <summary>
            Pulls underlying data of the given file as byte stream and returns a new pipe for chaining.
            </summary>
            <param name="fileinfo">Fileinfo instance of an existing readable file</param>
            <param name="fileStreamBuffer">Buffer size to use</param>
            <param name="options">File options</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Pull(System.Threading.Tasks.Task{System.Byte[]})">
            <summary>
            Pulls bytes from given array and returns a new pipe for chaining.
            Supplied <paramref name="byteTask"/> is awaited during bootstrapping (NOT during chaining) 
            </summary>
            <param name="byteTask">Task returning Source byte array. If the task is just created,
             it will be started during bootstrapping.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Pull(System.Byte[])">
            <summary>
            Pulls bytes from given array and returns a new pipe for chaining.
            </summary>
            <param name="bytes">Source byte array</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Pull(System.Threading.Tasks.Task{System.ArraySegment{System.Byte}})">
            <summary>
            Pulls bytes from given byte segment and returns a new pipe for chaining.
            Supplied <paramref name="byteSegTask"/> is awaited during bootstrapping (NOT during chaining) 
            </summary>
            <param name="byteSegTask">task returning Source array segment. If the task is just created,
             it will be started during bootstrapping.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Pull(System.ArraySegment{System.Byte})">
            <summary>
            Pulls bytes from given byte segment and returns a new pipe for chaining.
            </summary>
            <param name="byteSeg">Source byte array</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Pull(System.Threading.Tasks.Task{System.IO.Stream},System.Boolean)">
            <summary>
            Pulls bytes from given source stream and returns a new pipe for chaining.
            Supplied <paramref name="streamTask"/> is awaited during bootstrapping (NOT during chaining) 
            </summary>
            <param name="streamTask">Task returning Source data stream. If the task is just created,
             it will be started during bootstrapping.</param>
            <param name="disposeSourceStream">If true, source stream is disposed</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Pull(System.IO.Stream,System.Boolean)">
            <summary>
            Pulls the underlying data from the stream and returns a new pipe for chaining.
            </summary>
            <param name="stream">A readable stream</param>
            <param name="disposeSource">If true, stream is disposed at the end of streaming else left open</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenCountBytes(System.Func{Dot.Net.DevFast.IO.PullFuncStream},Dot.Net.DevFast.IO.IByteCounter@,System.Boolean)">
            <summary>
            Counts the number of bytes observed during pull based streaming (exposed through 
            <seealso cref="T:Dot.Net.DevFast.IO.IByteCounter"/>.<seealso cref="P:Dot.Net.DevFast.IO.IByteCounter.ByteCount"/>) 
            and returns a new pipe for chaining.
            <para>IMPORTANT: Access <seealso cref="P:Dot.Net.DevFast.IO.IByteCounter.ByteCount"/> ONLY AFTER the full
            piepline is bootstrapped and processed, i.e., calling <paramref name="byteCounter"/>.ByteCount immediately
            after this call will not provide the correct count.</para>
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="byteCounter">out param which exposes <seealso cref="P:Dot.Net.DevFast.IO.IByteCounter.ByteCount"/>) property.</param>
            <param name="include">If true is passed, compression is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenDecompress(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Boolean,System.Boolean)">
            <summary>
            Applies decompression on the data of given functional Stream pipe and returns a new pipe for chaining.
            </summary>
            <param name="pullSrc">Current pipe of the PUSH pipeline</param>
            <param name="include">If true is passed, decompression is performed else ignored</param>
            <param name="gzip">If true, <seealso cref="T:System.IO.Compression.GZipStream"/> is used else 
            <seealso cref="T:System.IO.Compression.DeflateStream"/> is used</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenComputeHash(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Security.Cryptography.HashAlgorithm,System.Boolean)">
            <summary>
            Computes the hash on the data of the given functional stream pipe and returns a new pipe for chaining.
            <para>IMPORTANT: Access <seealso cref="P:System.Security.Cryptography.HashAlgorithm.Hash"/> ONLY AFTER the full
            piepline is bootstrapped and processed, i.e., calling <paramref name="ha"/>.Hash immediately
            after this call will not provide the correct hash.</para>
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="ha">Instance of crypto hash algorithm</param>
            <param name="include">If true is passed, hash is computed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenToBase64(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Boolean)">
            <summary>
            Converts the data, of the given functional stream pipe to equivalent Base64
            and returns a new pipe for chaining.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="include">If true is passed, ToBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenFromBase64(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Security.Cryptography.FromBase64TransformMode,System.Boolean)">
            <summary>
            Decodes the Base64 data, of the given functional stream pipe and returns a new pipe for chaining.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="mode">Base64 transform mode</param>
            <param name="include">If true is passed, FromBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenEncrypt``1(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Func{``0},System.String,System.String,System.Security.Cryptography.HashAlgorithmName,System.Int32,System.Text.Encoding,System.Security.Cryptography.CipherMode,System.Security.Cryptography.PaddingMode,System.Boolean)">
            <summary>
            Encrypts the underlying data, of the given functional stream pipe based on give <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/>,
            and returns a new pipe for chaining.
            <para>NOTE:You may use <seealso cref="M:Dot.Net.DevFast.Extensions.CreateExts.CreateKeyAndIv(System.String,System.String,System.Security.Cryptography.HashAlgorithmName,System.Int32,System.Int32,System.Int32,System.Text.Encoding)"/> extension method to create IV and KEY byte arrays
            using plain text password and salt string.</para>
            </summary>
            <typeparam name="T">Type of <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/> to apply</typeparam>
            <param name="src">Current pipe of the pipeline</param>
            <param name="cryptoProvider">lambda that provides the crypto instance</param>
            <param name="password">password for key/IV generation (see <seealso cref="T:System.Security.Cryptography.Rfc2898DeriveBytes"/>)</param>
            <param name="salt">Salt string to use during key/IV generation (see <seealso cref="T:System.Security.Cryptography.Rfc2898DeriveBytes"/>)</param>
            <param name="hashName">Hash algorithm to use</param>
            <param name="loopCnt">Loop count</param>
            <param name="enc">Encoding to use to convert password and salt to bytes. If not provided, UTF8Encoding(false) is used</param>
            <param name="cipher">Cipher mode to use</param>
            <param name="padding">Padding mode to use</param>
            <param name="include">If true is passed, FromBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenEncrypt``1(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Func{``0},System.Byte[],System.Byte[],System.Security.Cryptography.CipherMode,System.Security.Cryptography.PaddingMode,System.Boolean)">
            <summary>
            Encrypts the underlying data, of the given functional stream pipe based on give <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/>,
            and returns a new pipe for chaining.
            </summary>
            <typeparam name="T">Type of <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/> to apply</typeparam>
            <param name="src">Current pipe of the pipeline</param>
            <param name="cryptoProvider">lambda that provides the crypto instance</param>
            <param name="key">key byte array</param>
            <param name="iv">iv byte array</param>
            <param name="cipher">Cipher mode to use</param>
            <param name="padding">Padding mode to use</param>
            <param name="include">If true is passed, FromBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenDecrypt``1(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Func{``0},System.String,System.String,System.Security.Cryptography.HashAlgorithmName,System.Int32,System.Text.Encoding,System.Security.Cryptography.CipherMode,System.Security.Cryptography.PaddingMode,System.Boolean)">
            <summary>
            Decrypts the underlying data, of the given functional stream pipe based on give <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/>,
            and returns a new pipe for chaining.
            <para>NOTE:You may use <seealso cref="M:Dot.Net.DevFast.Extensions.CreateExts.CreateKeyAndIv(System.String,System.String,System.Security.Cryptography.HashAlgorithmName,System.Int32,System.Int32,System.Int32,System.Text.Encoding)"/> extension method to create IV and KEY byte arrays
            using plain text password and salt string.</para>
            </summary>
            <typeparam name="T">Type of <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/> to apply</typeparam>
            <param name="src">Current pipe of the pipeline</param>
            <param name="cryptoProvider">lambda that provides the crypto instance</param>
            <param name="password">password for key/IV generation (see <seealso cref="T:System.Security.Cryptography.Rfc2898DeriveBytes"/>)</param>
            <param name="salt">Salt string to use during key/IV generation (see <seealso cref="T:System.Security.Cryptography.Rfc2898DeriveBytes"/>)</param>
            <param name="hashName">Hash algorithm to use</param>
            <param name="loopCnt">Loop count</param>
            <param name="enc">Encoding to use to convert password and salt to bytes. If not provided, UTF8Encoding(false) is used</param>
            <param name="cipher">Cipher mode to use</param>
            <param name="padding">Padding mode to use</param>
            <param name="include">If true is passed, FromBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenDecrypt``1(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Func{``0},System.Byte[],System.Byte[],System.Security.Cryptography.CipherMode,System.Security.Cryptography.PaddingMode,System.Boolean)">
            <summary>
            Decrypts the underlying data, of the given functional stream pipe based on give <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/>,
            and returns a new pipe for chaining.
            </summary>
            <typeparam name="T">Type of <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/> to apply</typeparam>
            <param name="src">Current pipe of the pipeline</param>
            <param name="cryptoProvider">lambda that provides the crypto instance</param>
            <param name="key">key byte array</param>
            <param name="iv">iv byte array</param>
            <param name="cipher">Cipher mode to use</param>
            <param name="padding">Padding mode to use</param>
            <param name="include">If true is passed, FromBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenTransform(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Security.Cryptography.ICryptoTransform,System.Boolean)">
            <summary>
            Applies the given crypto transformation to the data of the given functional stream pipe
            and returns a new pipe for chaining.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="transformation">Crypto Transformation to apply</param>
            <param name="include">If true is passed, CryptoTransform is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenApply(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Func{System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Func{Dot.Net.DevFast.IO.PullFuncStream}},System.Boolean)">
            <summary>
            Appends the given arbitrary custom functional stream pipe (i.e. <paramref name="applyFunc"/>) to the pipeline
            and returns a new pipe for chaining.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="applyFunc">Yet another custom functional stream pipe</param>
            <param name="include">If true is passed, CryptoTransform is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenCountBytes(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},Dot.Net.DevFast.IO.IByteCounter@,System.Boolean)">
            <summary>
            Counts the number of bytes observed during pull based streaming (exposed through 
            <seealso cref="T:Dot.Net.DevFast.IO.IByteCounter"/>.<seealso cref="P:Dot.Net.DevFast.IO.IByteCounter.ByteCount"/>) 
            and returns a new pipe for chaining.
            <para>IMPORTANT: Access <seealso cref="P:Dot.Net.DevFast.IO.IByteCounter.ByteCount"/> ONLY AFTER the full
            piepline is bootstrapped and processed, i.e., calling <paramref name="byteCounter"/>.ByteCount immediately
            after this call will not provide the correct count.</para>
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="byteCounter">out param which exposes <seealso cref="P:Dot.Net.DevFast.IO.IByteCounter.ByteCount"/>) property.</param>
            <param name="include">If true is passed, compression is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenDecompress(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Boolean,System.Boolean)">
            <summary>
            Applies decompression on the data of given functional Stream pipe and returns a new pipe for chaining.
            </summary>
            <param name="pullSrc">Current pipe of the PUSH pipeline</param>
            <param name="include">If true is passed, decompression is performed else ignored</param>
            <param name="gzip">If true, <seealso cref="T:System.IO.Compression.GZipStream"/> is used else 
            <seealso cref="T:System.IO.Compression.DeflateStream"/> is used</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenComputeHash(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Security.Cryptography.HashAlgorithm,System.Boolean)">
            <summary>
            Computes the hash on the data of the given functional stream pipe and returns a new pipe for chaining.
            <para>IMPORTANT: Access <seealso cref="P:System.Security.Cryptography.HashAlgorithm.Hash"/> ONLY AFTER the full
            piepline is bootstrapped and processed, i.e., calling <paramref name="ha"/>.Hash immediately
            after this call will not provide the correct hash.</para>
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="ha">Instance of crypto hash algorithm</param>
            <param name="include">If true is passed, hash is computed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenToBase64(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Boolean)">
            <summary>
            Converts the data, of the given functional stream pipe to equivalent Base64
            and returns a new pipe for chaining.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="include">If true is passed, ToBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenFromBase64(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Security.Cryptography.FromBase64TransformMode,System.Boolean)">
            <summary>
            Decodes the Base64 data, of the given functional stream pipe and returns a new pipe for chaining.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="mode">Base64 transform mode</param>
            <param name="include">If true is passed, FromBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenEncrypt``1(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Func{``0},System.String,System.String,System.Security.Cryptography.HashAlgorithmName,System.Int32,System.Text.Encoding,System.Security.Cryptography.CipherMode,System.Security.Cryptography.PaddingMode,System.Boolean)">
            <summary>
            Encrypts the underlying data, of the given functional stream pipe based on give <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/>,
            and returns a new pipe for chaining.
            <para>NOTE:You may use <seealso cref="M:Dot.Net.DevFast.Extensions.CreateExts.CreateKeyAndIv(System.String,System.String,System.Security.Cryptography.HashAlgorithmName,System.Int32,System.Int32,System.Int32,System.Text.Encoding)"/> extension method to create IV and KEY byte arrays
            using plain text password and salt string.</para>
            </summary>
            <typeparam name="T">Type of <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/> to apply</typeparam>
            <param name="src">Current pipe of the pipeline</param>
            <param name="cryptoProvider">lambda that provides the crypto instance</param>
            <param name="password">password for key/IV generation (see <seealso cref="T:System.Security.Cryptography.Rfc2898DeriveBytes"/>)</param>
            <param name="salt">Salt string to use during key/IV generation (see <seealso cref="T:System.Security.Cryptography.Rfc2898DeriveBytes"/>)</param>
            <param name="hashName">Hash algorithm to use</param>
            <param name="loopCnt">Loop count</param>
            <param name="enc">Encoding to use to convert password and salt to bytes. If not provided, UTF8Encoding(false) is used</param>
            <param name="cipher">Cipher mode to use</param>
            <param name="padding">Padding mode to use</param>
            <param name="include">If true is passed, FromBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenEncrypt``1(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Func{``0},System.Byte[],System.Byte[],System.Security.Cryptography.CipherMode,System.Security.Cryptography.PaddingMode,System.Boolean)">
            <summary>
            Encrypts the underlying data, of the given functional stream pipe based on give <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/>,
            and returns a new pipe for chaining.
            </summary>
            <typeparam name="T">Type of <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/> to apply</typeparam>
            <param name="src">Current pipe of the pipeline</param>
            <param name="cryptoProvider">lambda that provides the crypto instance</param>
            <param name="key">key byte array</param>
            <param name="iv">iv byte array</param>
            <param name="cipher">Cipher mode to use</param>
            <param name="padding">Padding mode to use</param>
            <param name="include">If true is passed, FromBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenDecrypt``1(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Func{``0},System.String,System.String,System.Security.Cryptography.HashAlgorithmName,System.Int32,System.Text.Encoding,System.Security.Cryptography.CipherMode,System.Security.Cryptography.PaddingMode,System.Boolean)">
            <summary>
            Decrypts the underlying data, of the given functional stream pipe based on give <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/>,
            and returns a new pipe for chaining.
            <para>NOTE:You may use <seealso cref="M:Dot.Net.DevFast.Extensions.CreateExts.CreateKeyAndIv(System.String,System.String,System.Security.Cryptography.HashAlgorithmName,System.Int32,System.Int32,System.Int32,System.Text.Encoding)"/> extension method to create IV and KEY byte arrays
            using plain text password and salt string.</para>
            </summary>
            <typeparam name="T">Type of <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/> to apply</typeparam>
            <param name="src">Current pipe of the pipeline</param>
            <param name="cryptoProvider">lambda that provides the crypto instance</param>
            <param name="password">password for key/IV generation (see <seealso cref="T:System.Security.Cryptography.Rfc2898DeriveBytes"/>)</param>
            <param name="salt">Salt string to use during key/IV generation (see <seealso cref="T:System.Security.Cryptography.Rfc2898DeriveBytes"/>)</param>
            <param name="hashName">Hash algorithm to use</param>
            <param name="loopCnt">Loop count</param>
            <param name="enc">Encoding to use to convert password and salt to bytes. If not provided, UTF8Encoding(false) is used</param>
            <param name="cipher">Cipher mode to use</param>
            <param name="padding">Padding mode to use</param>
            <param name="include">If true is passed, FromBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenDecrypt``1(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Func{``0},System.Byte[],System.Byte[],System.Security.Cryptography.CipherMode,System.Security.Cryptography.PaddingMode,System.Boolean)">
            <summary>
            Decrypts the underlying data, of the given functional stream pipe based on give <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/>,
            and returns a new pipe for chaining.
            </summary>
            <typeparam name="T">Type of <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/> to apply</typeparam>
            <param name="src">Current pipe of the pipeline</param>
            <param name="cryptoProvider">lambda that provides the crypto instance</param>
            <param name="key">key byte array</param>
            <param name="iv">iv byte array</param>
            <param name="cipher">Cipher mode to use</param>
            <param name="padding">Padding mode to use</param>
            <param name="include">If true is passed, FromBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenTransform(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Security.Cryptography.ICryptoTransform,System.Boolean)">
            <summary>
            Applies the given crypto transformation to the data of the given functional stream pipe
            and returns a new pipe for chaining.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="transformation">Crypto Transformation to apply</param>
            <param name="include">If true is passed, CryptoTransform is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenApply(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Func{System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}}},System.Boolean)">
            <summary>
            Appends the given arbitrary custom functional stream pipe (i.e. <paramref name="applyFunc"/>) to the pipeline
            and returns a new pipe for chaining.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="applyFunc">Yet another custom functional stream pipe</param>
            <param name="include">If true is passed, CryptoTransform is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenConvertToPush(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Int32)">
            <summary>
            Converts the PULL pipeline to PUSH pipeline and returns it for chaining.
            </summary>
            <param name="src">Current PULL source pipe</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenConvertToPush(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Int32)">
            <summary>
            Converts the PULL pipeline to PUSH pipeline and returns it for chaining.
            </summary>
            <param name="src">Current PULL source pipe</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteFileAsync(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.String,System.String,System.Int32,System.IO.FileOptions,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline to the file.
            <para>Returns the <seealso cref="T:System.IO.FileInfo"/> object of that the written file</para>
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="folder">folder path where file is saved</param>
            <param name="filename">name of file. If not supplied a new GUID string will be used instead (without extension)</param>
            <param name="fileStreamBuffer">Buffer size of the file stream</param>
            <param name="options">File options</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteFileAsync(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.IO.DirectoryInfo,System.String,System.Int32,System.IO.FileOptions,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline to the file.
            <para>Returns the <seealso cref="T:System.IO.FileInfo"/> object of that the written file</para>
            </summary> 
            <param name="src">Current pipe of the pipeline</param>
            <param name="folder">directory information of folder where file will be created</param>
            <param name="filename">name of file. If not supplied a new GUID string will be used instead (without extension)</param>
            <param name="fileStreamBuffer">Buffer size of the file stream</param>
            <param name="options">File options</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteFileAsync(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.IO.FileInfo,System.Int32,System.IO.FileOptions,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline to the file.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="fileinfo">file info object of the file to create/rewrite.</param>
            <param name="fileStreamBuffer">Buffer size of the file stream</param>
            <param name="options">File options</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteBytesAsync(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Threading.CancellationToken,System.Int32,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and returns the results as byte array.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="token">Cancellation token to observe</param>
            <param name="estimatedSize">Intial guess for the size of the byte array (optimization on resizing operation).</param>
            <param name="bufferSize">Buffer size for data-pull (copying) ops</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteByteSegAsync(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Threading.CancellationToken,System.Int32,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and returns the results as byte array.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="token">Cancellation token to observe</param>
            <param name="estimatedSize">Intial guess for the size of the byte array (optimization on resizing operation).</param>
            <param name="bufferSize">Buffer size for data-pull (copying) ops</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteBufferAsync(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Threading.CancellationToken,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and returns the contents as newly created <seealso cref="T:System.IO.MemoryStream"/>.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="token">Cancellation token to observe</param>
            <param name="seekToOrigin">If true, Seek with <seealso cref="F:System.IO.SeekOrigin.Begin"/> is performed else not.</param>
            <param name="initialSize">Initial Memory buffer Size</param>
            <param name="bufferSize">Buffer size for data-pull (copying) ops</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndExecuteAsync(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Int32,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pushes data throw the pipeline.
            <para>NOTE: Calling this function will result in running the streaming pipeline, but, you won't receive
            anything in the end. Normally, usage of this function is to avoid use of <seealso cref="T:System.IO.MemoryStream"/>
            to reduce runtime memory pressure, and at the same time counting bytes, calculate crypto-hashes etc.</para>
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="bufferSize">Buffer size</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteStreamAsync(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.IO.Stream,System.Int32,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and appends the contents to the given <seealso cref="T:System.IO.Stream"/>.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="writableTarget">Target stream to write on</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeTarget">If true, target stream is disposed else left open.</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteStringAsync(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Int32,System.Text.Encoding,System.Boolean,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and returns results as string.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="initialSize">Initial guess of the size of the string (optimization on resizing ops)</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteStringBuilderAsync(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Int32,System.Text.Encoding,System.Boolean,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and returns results as newly created <seealso cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="initialSize">Initial guess of the size of StringBuilder (optimization on array resizing)</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteStringBuilderAsync(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Text.StringBuilder,System.Text.Encoding,System.Boolean,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and appends the contents to the given <seealso cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="sbToAppend">String builder to append data</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndParseJson``1(System.Func{Dot.Net.DevFast.IO.PullFuncStream},Newtonsoft.Json.JsonSerializer,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and pulls data throw the pipeline 
            in order to obtain deserialized object based on the Json text.
            </summary>
            <typeparam name="T">Type of the object from deserialization</typeparam>
            <param name="src"></param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndParseJsonArray``1(System.Func{Dot.Net.DevFast.IO.PullFuncStream},Newtonsoft.Json.JsonSerializer,System.Text.Encoding,System.Boolean,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and pulls data throw the pipeline 
            in order to achieve enumeration on json based deserialized objects.
            </summary>
            <typeparam name="T">Type of the object from deserialization</typeparam>
            <param name="src"></param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
            <param name="token">Cancellation token to observe</param>
            <param name="objectBufferSize">Size of the intermediate object buffer in terms of number (count) of deserialized objects. NOTE: <see cref="F:Dot.Net.DevFast.Etc.ConcurrentBuffer.Unbounded"/> is a special number to create unbounded buffer.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When given size is negative</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndParseJsonArrayAsync``1(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Action{``0,System.Threading.CancellationToken},Newtonsoft.Json.JsonSerializer,System.Int32,System.Threading.CancellationToken,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and deserializes the object and feeds to consumer after adapting those
            using the given adapter.
            </summary>
            <typeparam name="T">Type of the object for deserialization and consumer</typeparam>
            <param name="src"></param>
            <param name="consumerAction">Consumer lambda to form the PPC-Pipe</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="ppcBufferSize">Max. number of produced item to hold in intermediary buffer.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndParseJsonArrayAsync``1(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},Newtonsoft.Json.JsonSerializer,System.Int32,System.Threading.CancellationToken,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and deserializes the object and feeds to consumer after adapting those
            using the given adapter.
            </summary>
            <typeparam name="T">Type of the object for deserialization and consumer</typeparam>
            <param name="src"></param>
            <param name="consumerFunc">Consumer lambda to form the PPC-Pipe</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="ppcBufferSize">Max. number of produced item to hold in intermediary buffer.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndParseJsonArrayAsync``1(System.Func{Dot.Net.DevFast.IO.PullFuncStream},Dot.Net.DevFast.Extensions.Ppc.IConsumer{``0},Newtonsoft.Json.JsonSerializer,System.Int32,System.Threading.CancellationToken,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and deserializes the object and feeds to consumer after adapting those
            using the given adapter.
            </summary>
            <typeparam name="T">Type of the object for deserialization and consumer</typeparam>
            <param name="src"></param>
            <param name="consumer">Consumer instance to form the PPC-Pipe</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="ppcBufferSize">Max. number of produced item to hold in intermediary buffer.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndParseJsonArrayAsync``2(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Action{``1,System.Threading.CancellationToken},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},Newtonsoft.Json.JsonSerializer,System.Int32,System.Threading.CancellationToken,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and deserializes the object and feeds to consumer after adapting those
            using the given adapter.
            </summary>
            <typeparam name="TJ">Type of the object for deserialization</typeparam>
            <typeparam name="TC">Type of the object for consumer</typeparam>
            <param name="src"></param>
            <param name="consumer">Consumer lambda to form the PPC-Pipe</param>
            <param name="adapter">Adapter to convert deserialized objects to consumable type</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="ppcBufferSize">Max. number of produced item to hold in intermediary buffer.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndParseJsonArrayAsync``2(System.Func{Dot.Net.DevFast.IO.PullFuncStream},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},Newtonsoft.Json.JsonSerializer,System.Int32,System.Threading.CancellationToken,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and deserializes the object and feeds to consumer after adapting those
            using the given adapter.
            </summary>
            <typeparam name="TJ">Type of the object for deserialization</typeparam>
            <typeparam name="TC">Type of the object for consumer</typeparam>
            <param name="src"></param>
            <param name="consumer">Consumer lambda to form the PPC-Pipe</param>
            <param name="adapter">Adapter to convert deserialized objects to consumable type</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="ppcBufferSize">Max. number of produced item to hold in intermediary buffer.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndParseJsonArrayAsync``2(System.Func{Dot.Net.DevFast.IO.PullFuncStream},Dot.Net.DevFast.Extensions.Ppc.IConsumer{``1},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},Newtonsoft.Json.JsonSerializer,System.Int32,System.Threading.CancellationToken,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and deserializes the object and feeds to consumer after adapting those
            using the given adapter.
            </summary>
            <typeparam name="TJ">Type of the object for deserialization</typeparam>
            <typeparam name="TC">Type of the object for consumer</typeparam>
            <param name="src"></param>
            <param name="consumer">Consumer instance to form the PPC-Pipe</param>
            <param name="adapter">Adapter to convert deserialized objects to consumable type</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="ppcBufferSize">Max. number of produced item to hold in intermediary buffer.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteFileAsync(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.String,System.String,System.Int32,System.IO.FileOptions,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline to the file.
            <para>Returns the <seealso cref="T:System.IO.FileInfo"/> object of that the written file</para>
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="folder">folder path where file is saved</param>
            <param name="filename">name of file. If not supplied a new GUID string will be used instead (without extension)</param>
            <param name="fileStreamBuffer">Buffer size of the file stream</param>
            <param name="options">File options</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteFileAsync(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.IO.DirectoryInfo,System.String,System.Int32,System.IO.FileOptions,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline to the file.
            <para>Returns the <seealso cref="T:System.IO.FileInfo"/> object of that the written file</para>
            </summary> 
            <param name="src">Current pipe of the pipeline</param>
            <param name="folder">directory information of folder where file will be created</param>
            <param name="filename">name of file. If not supplied a new GUID string will be used instead (without extension)</param>
            <param name="fileStreamBuffer">Buffer size of the file stream</param>
            <param name="options">File options</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteFileAsync(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.IO.FileInfo,System.Int32,System.IO.FileOptions,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline to the file.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="fileinfo">file info object of the file to create/rewrite.</param>
            <param name="fileStreamBuffer">Buffer size of the file stream</param>
            <param name="options">File options</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteBytesAsync(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Threading.CancellationToken,System.Int32,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and returns the results as byte array.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="token">Cancellation token to observe</param>
            <param name="estimatedSize">Intial guess for the size of the byte array (optimization on resizing operation).</param>
            <param name="bufferSize">Buffer size for data-pull (copying) ops</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteByteSegAsync(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Threading.CancellationToken,System.Int32,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and returns the results as byte array.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="token">Cancellation token to observe</param>
            <param name="estimatedSize">Intial guess for the size of the byte array (optimization on resizing operation).</param>
            <param name="bufferSize">Buffer size for data-pull (copying) ops</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteBufferAsync(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Threading.CancellationToken,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and returns the contents as newly created <seealso cref="T:System.IO.MemoryStream"/>.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="token">Cancellation token to observe</param>
            <param name="seekToOrigin">If true, Seek with <seealso cref="F:System.IO.SeekOrigin.Begin"/> is performed else not.</param>
            <param name="initialSize">Initial Memory buffer Size</param>
            <param name="bufferSize">Buffer size for data-pull (copying) ops</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndExecuteAsync(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Int32,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pushes data throw the pipeline.
            <para>NOTE: Calling this function will result in running the streaming pipeline, but, you won't receive
            anything in the end. Normally, usage of this function is to avoid use of <seealso cref="T:System.IO.MemoryStream"/>
            to reduce runtime memory pressure, and at the same time counting bytes, calculate crypto-hashes etc.</para>
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="bufferSize">Buffer size</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteStreamAsync(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.IO.Stream,System.Int32,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and appends the contents to the given <seealso cref="T:System.IO.Stream"/>.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="writableTarget">Target stream to write on</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeTarget">If true, target stream is disposed else left open.</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteStringAsync(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Int32,System.Text.Encoding,System.Boolean,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and returns results as string.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="initialSize">Initial guess of the size of the string (optimization on resizing ops)</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteStringBuilderAsync(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Int32,System.Text.Encoding,System.Boolean,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and returns results as newly created <seealso cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="initialSize">Initial guess of the size of StringBuilder (optimization on array resizing)</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteStringBuilderAsync(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Text.StringBuilder,System.Text.Encoding,System.Boolean,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and appends the contents to the given <seealso cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="sbToAppend">String builder to append data</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndParseJsonAsync``1(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},Newtonsoft.Json.JsonSerializer,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and deserializes the object based on the Json text.
            </summary>
            <typeparam name="T">Type of the object from deserialization</typeparam>
            <param name="src"></param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndParseJsonArrayAsync``1(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Collections.Concurrent.BlockingCollection{``0},Newtonsoft.Json.JsonSerializer,System.Threading.CancellationToken,System.Threading.CancellationTokenSource,System.Text.Encoding,System.Boolean,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and deserializes the object based on the Json text.
            </summary>
            <typeparam name="T">Type of the object from deserialization</typeparam>
            <param name="src"></param>
            <param name="target">target blocking collection to populate deserialied JSON data objects</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="observedTokenSource">When developing parallel prooducer-consumer pattern and if you wish you
            cancel the consumer (other producer), in case of error produced during json deserialization,
            pass the source of cancellation token which consumer (other producer) is observing.</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
            <param name="closeTarget"><para>When this is the ONLY call that populates the <paramref name="target"/>
            keep it true so that when operation finishes the collection is automatically closed for adding so that consumer 
            shall not remain blocked infinitely. If setting false, then you must explicitly call 
            <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/> for the obvious reason.</para>
            <para>When this call is one among multiple producers populating the same <paramref name="target"/>,
            it is MANDATORY to set this to false and you must explicitly call <seealso cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding"/>
            when all producers finished populating the collection, otherwise weird things may happen.</para></param>
            <param name="forceCloseWhenError">if true, when any error occurs closes the collection for any additional 
            adding irrespective of <paramref name="closeTarget"/> setting. When false, <paramref name="closeTarget"/>
            setting takes precedence.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndParseJsonArrayAsync``1(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Action{``0,System.Threading.CancellationToken},Newtonsoft.Json.JsonSerializer,System.Int32,System.Threading.CancellationToken,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and deserializes the object and feeds to consumer after adapting those
            using the given adapter.
            </summary>
            <typeparam name="T">Type of the object for deserialization and consumer</typeparam>
            <param name="src"></param>
            <param name="consumerAction">Consumer lambda to form the PPC-Pipe</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="ppcBufferSize">Max. number of produced item to hold in intermediary buffer.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndParseJsonArrayAsync``1(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},Newtonsoft.Json.JsonSerializer,System.Int32,System.Threading.CancellationToken,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and deserializes the object and feeds to consumer after adapting those
            using the given adapter.
            </summary>
            <typeparam name="T">Type of the object for deserialization and consumer</typeparam>
            <param name="src"></param>
            <param name="consumerFunc">Consumer async lambda to form the PPC-Pipe</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="ppcBufferSize">Max. number of produced item to hold in intermediary buffer.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndParseJsonArrayAsync``1(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},Dot.Net.DevFast.Extensions.Ppc.IConsumer{``0},Newtonsoft.Json.JsonSerializer,System.Int32,System.Threading.CancellationToken,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and deserializes the object and feeds to consumer after adapting those
            using the given adapter.
            </summary>
            <typeparam name="T">Type of the object for deserialization and consumer</typeparam>
            <param name="src"></param>
            <param name="consumer">Consumer instance to form the PPC-Pipe</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="ppcBufferSize">Max. number of produced item to hold in intermediary buffer.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndParseJsonArrayAsync``2(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Action{``1,System.Threading.CancellationToken},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},Newtonsoft.Json.JsonSerializer,System.Int32,System.Threading.CancellationToken,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and deserializes the object and feeds to consumer after adapting those
            using the given adapter.
            </summary>
            <typeparam name="TJ">Type of the object for deserialization</typeparam>
            <typeparam name="TC">Type of the object for consumer</typeparam>
            <param name="src"></param>
            <param name="consumerAction">Consumer lambda to form the PPC-Pipe</param>
            <param name="adapter">Adapter to convert deserialized objects to consumable type</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="ppcBufferSize">Max. number of produced item to hold in intermediary buffer.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndParseJsonArrayAsync``2(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},Newtonsoft.Json.JsonSerializer,System.Int32,System.Threading.CancellationToken,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and deserializes the object and feeds to consumer after adapting those
            using the given adapter.
            </summary>
            <typeparam name="TJ">Type of the object for deserialization</typeparam>
            <typeparam name="TC">Type of the object for consumer</typeparam>
            <param name="src"></param>
            <param name="consumerFunc">Consumer lambda to form the PPC-Pipe</param>
            <param name="adapter">Adapter to convert deserialized objects to consumable type</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="ppcBufferSize">Max. number of produced item to hold in intermediary buffer.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndParseJsonArrayAsync``2(System.Func{System.Threading.Tasks.Task{Dot.Net.DevFast.IO.PullFuncStream}},Dot.Net.DevFast.Extensions.Ppc.IConsumer{``1},Dot.Net.DevFast.Extensions.Ppc.IDataAdapter{``0,``1},Newtonsoft.Json.JsonSerializer,System.Int32,System.Threading.CancellationToken,System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pulls data throw the pipeline and deserializes the object and feeds to consumer after adapting those
            using the given adapter.
            </summary>
            <typeparam name="TJ">Type of the object for deserialization</typeparam>
            <typeparam name="TC">Type of the object for consumer</typeparam>
            <param name="src"></param>
            <param name="consumer">Consumer instance to form the PPC-Pipe</param>
            <param name="adapter">Adapter to convert deserialized objects to consumable type</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="ppcBufferSize">Max. number of produced item to hold in intermediary buffer.</param>
            <param name="token">Cancellation token to observe</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="detectEncodingFromBom">If true, an attempt to detect encoding from BOM (byte order mark) is made</param>
            <param name="bufferSize">Buffer size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Push(System.Threading.Tasks.Task{System.String},System.Text.Encoding,System.Int32)">
            <summary>
            Pushes the string content and returns a new pipe for chaining.
            <para>NOTE: If you already have a string builder, then use the overloaded method instead
            of doing yourStringBuilder.ToString().LoadString(...), as overloaded method is optimized.</para>
            Supplied <paramref name="stringTask"/> is awaited during bootstrapping (NOT during chaining)
            </summary>
            <param name="stringTask">Task returning the source string. If the task is just created,
             it will be started during bootstrapping.</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="bufferSize">Buffer size (as number of char instead of bytes)</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Push(System.String,System.Text.Encoding,System.Int32)">
            <summary>
            Pushes the string content and returns a new pipe for chaining.
            <para>NOTE: If you already have a string builder, then use the overloaded method instead
            of doing yourStringBuilder.ToString().LoadString(...), as overloaded method is optimized.</para>
            </summary>
            <param name="s">source string</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="bufferSize">Buffer size (as number of char instead of bytes)</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Push(System.Threading.Tasks.Task{System.Text.StringBuilder},System.Text.Encoding,System.Int32)">
            <summary>
            Pushes the string content of the builder and returns a new pipe for chaining.
            Supplied <paramref name="sbTask"/> is awaited during bootstrapping (NOT during chaining) 
            </summary>
            <param name="sbTask">Task returning source string builder. If the task is just created,
             it will be started during bootstrapping.</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="bufferSize">Buffer size (as number of char instead of bytes)</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Push(System.Text.StringBuilder,System.Text.Encoding,System.Int32)">
            <summary>
            Pushes the string content of the builder and returns a new pipe for chaining.
            </summary>
            <param name="sb">source string builder</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="bufferSize">Buffer size (as number of char instead of bytes)</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Push(System.IO.DirectoryInfo,System.String,System.Int32,System.IO.FileOptions)">
            <summary>
            Pushes the data of the given file as byte stream and returns a new pipe for chaining.
            </summary>
            <param name="folder">Parent folder of the file</param>
            <param name="filename">An existing readable file's name with extension</param>
            <param name="fileStreamBuffer">Buffer size to use</param>
            <param name="options">File options</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Push(System.IO.FileInfo,System.Int32,System.IO.FileOptions)">
            <summary>
            Pushes the data of the given file as byte stream and returns a new pipe for chaining.
            </summary>
            <param name="fileinfo">Fileinfo instance of an existing readable file</param>
            <param name="fileStreamBuffer">Buffer size to use</param>
            <param name="options">File options</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Push(System.Threading.Tasks.Task{System.Byte[]})">
            <summary>
            Pushes bytes from given array and returns a new pipe for chaining.
            Supplied <paramref name="byteTask"/> is awaited during bootstrapping (NOT during chaining) 
            </summary>
            <param name="byteTask">Task returning Source byte array. If the task is just created,
             it will be started during bootstrapping.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Push(System.Byte[])">
            <summary>
            Pushes bytes from given array and returns a new pipe for chaining.
            </summary>
            <param name="bytes">Source byte array</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Push(System.Threading.Tasks.Task{System.ArraySegment{System.Byte}})">
            <summary>
            Pushes bytes from given byte segment and returns a new pipe for chaining.
            Supplied <paramref name="byteSegTask"/> is awaited during bootstrapping (NOT during chaining) 
            </summary>
            <param name="byteSegTask">task returning Source array segment. If the task is just created,
             it will be started during bootstrapping.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Push(System.ArraySegment{System.Byte})">
            <summary>
            Pushes bytes from given byte segment and returns a new pipe for chaining.
            </summary>
            <param name="byteSeg">Source byte array</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Push(System.Threading.Tasks.Task{System.IO.Stream},System.Int32,System.Boolean)">
            <summary>
            Pushes bytes from given source stream and returns a new pipe for chaining.
            Supplied <paramref name="streamTask"/> is awaited during bootstrapping (NOT during chaining) 
            </summary>
            <param name="streamTask">Task returning Source data stream. If the task is just created,
             it will be started during bootstrapping.</param>
            <param name="streamBuffer">Buffer size to use during data loading</param>
            <param name="disposeSourceStream">If true, source stream is disposed</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.Push(System.IO.Stream,System.Int32,System.Boolean)">
            <summary>
            Pushes bytes from given source stream and returns a new pipe for chaining.
            </summary>
            <param name="source">Source data stream</param>
            <param name="streamBuffer">Buffer size to use during data loading</param>
            <param name="disposeSourceStream">If true, source stream is disposed</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.PushJsonAsync``1(System.Threading.Tasks.Task{``0},Newtonsoft.Json.JsonSerializer,System.Text.Encoding,System.Int32,System.Boolean)">
            <summary>
            Pushes the equivalent json representation of the object and returns a new pipe for chaining.
            Supplied <paramref name="objTask"/> is awaited during bootstrapping (NOT during chaining) 
            </summary>
            <typeparam name="T">Type of object to serialize</typeparam>
            <param name="objTask">Task returning Object to serialize as json text. If the task is just created,
             it will be started during bootstrapping.</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="writerBuffer">Buffer size for the stream writer</param>
            <param name="autoFlush">True to enable auto-flushing else false</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.PushJson``1(``0,Newtonsoft.Json.JsonSerializer,System.Text.Encoding,System.Int32,System.Boolean)">
            <summary>
            Pushes the equivalent json representation of the object and returns a new pipe for chaining.
            <para>NOTE: Use <see cref="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.PushJsonAsync``1(System.Threading.Tasks.Task{``0},Newtonsoft.Json.JsonSerializer,System.Text.Encoding,System.Int32,System.Boolean)"/> for <seealso cref="T:System.Threading.Tasks.Task`1"/>
            and use <see cref="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.PushJsonArray``1(System.Collections.Generic.IEnumerable{``0},Newtonsoft.Json.JsonSerializer,System.Text.Encoding,System.Int32,System.Threading.CancellationTokenSource,System.Boolean)"/> for any implementation of <seealso cref="T:System.Collections.Generic.IEnumerable`1"/>.</para>
            </summary>
            <typeparam name="T">Type of object to serialize</typeparam>
            <param name="obj">Object to serialize as json text</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="writerBuffer">Buffer size for the stream writer</param>
            <param name="autoFlush">True to enable auto-flushing else false</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.PushJsonArray``1(System.Collections.Generic.IEnumerable{``0},Newtonsoft.Json.JsonSerializer,System.Text.Encoding,System.Int32,System.Threading.CancellationTokenSource,System.Boolean)">
            <summary>
            Pushes the equivalent json array representation of the objects in the given blocking collection
            and returns a new pipe for chaining.
            <para>IMPORTANT: If passed collection is <seealso cref="T:System.Collections.Concurrent.BlockingCollection`1"/>, then
            the method uses the instance of <paramref name="pcts"/> to suport the error signaling in
            concurrent producer-consumer. For any other kind of collection (including other concurrent collection),
            the implementation simply ignores the <paramref name="pcts"/> instance.</para>
            </summary>
            <typeparam name="T">Type of object to serialize</typeparam>
            <param name="obj">Object to serialize as json text</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="writerBuffer">Buffer size for the stream writer</param>
            <param name="pcts">Source to cancel in case some error is encountered. Normally,
            this source token is observed at data producer side.
            <para>NOTE: Used ONLY when supplied collection is <seealso cref="T:System.Collections.Concurrent.BlockingCollection`1"/></para></param>
            <param name="autoFlush">True to enable auto-flushing else false</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.PushJsonArray``1(System.Action{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken},Newtonsoft.Json.JsonSerializer,System.Int32,System.Text.Encoding,System.Int32,System.Boolean)">
            <summary>
            Pushes the equivalent json array representation of the objects produced by the producer's action
            implementation and returns a new pipe for chaining.
            </summary>
            <typeparam name="T">Type of object to serialize</typeparam>
            <param name="producerAction">Producer lambda responsible of object production</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="ppcBufferSize">Max. number of produced item to hold in intermediary buffer.</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="writerBuffer">Buffer size for the stream writer</param>
            <param name="autoFlush">True to enable auto-flushing else false</param>
            <exception cref="T:System.AggregateException"></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.PushJsonArray``1(System.Func{Dot.Net.DevFast.Extensions.Ppc.IProducerBuffer{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task},Newtonsoft.Json.JsonSerializer,System.Int32,System.Text.Encoding,System.Int32,System.Boolean)">
            <summary>
            Pushes the equivalent json array representation of the objects produced by the producer's action
            implementation and returns a new pipe for chaining.
            </summary>
            <typeparam name="T">Type of object to serialize</typeparam>
            <param name="producerFunc">Producer async lambda responsible of object production</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="ppcBufferSize">Max. number of produced item to hold in intermediary buffer.</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="writerBuffer">Buffer size for the stream writer</param>
            <param name="autoFlush">True to enable auto-flushing else false</param>
            <exception cref="T:System.AggregateException"></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.PushJsonArray``1(Dot.Net.DevFast.Extensions.Ppc.IProducer{``0},Newtonsoft.Json.JsonSerializer,System.Int32,System.Text.Encoding,System.Int32,System.Boolean)">
            <summary>
            Pushes the equivalent json array representation of the objects produced by the producer implementation
            and returns a new pipe for chaining.
            </summary>
            <typeparam name="T">Type of object to serialize</typeparam>
            <param name="producer">Producer side responsible of object production</param>
            <param name="serializer">if not provided, JsonSerializer with default values
            (see also <seealso cref="M:Dot.Net.DevFast.Extensions.JsonExt.CustomJson.Serializer"/>) will be used.</param>
            <param name="ppcBufferSize">Max. number of produced item to hold in intermediary buffer.</param>
            <param name="enc">Encoding to use while writing the file. 
            If not supplied, by default <seealso cref="P:System.Text.Encoding.UTF8"/>
            (withOUT the utf-8 identifier, i.e. new UTF8Encoding(false)) will be used</param>
            <param name="writerBuffer">Buffer size for the stream writer</param>
            <param name="autoFlush">True to enable auto-flushing else false</param>
            <exception cref="T:System.AggregateException"></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenConcurrentlyWriteTo(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.IO.Stream,System.Boolean,System.Action{System.IO.Stream,System.Exception},System.Boolean)">
            <summary>
            Concurrently writes on <paramref name="writableStream"/> and returns a new pipe for chaining.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="writableStream">Stream on which to write concurrently</param>
            <param name="disposeWritableStream">true to dispose <paramref name="writableStream"/> else false.</param>
            <param name="errorHandler">Lambda to call in case an error is encountered during stream operations.
            If NOT supplied then the exception is immediately rethrown, otherwise, it is passed to the lambda
            along with the <paramref name="writableStream"/> instance. It is then up to lambda whether to
            rethrow it or not.</param>
            <param name="include">If true is passed, compression is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenCountBytes(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},Dot.Net.DevFast.IO.IByteCounter@,System.Boolean)">
            <summary>
            Counts the number of bytes observed during push based streaming (exposed through 
            <seealso cref="T:Dot.Net.DevFast.IO.IByteCounter"/>.<seealso cref="P:Dot.Net.DevFast.IO.IByteCounter.ByteCount"/>) 
            and returns a new pipe for chaining.
            <para>IMPORTANT: Access <seealso cref="P:Dot.Net.DevFast.IO.IByteCounter.ByteCount"/> ONLY AFTER the full
            pipeline is bootstrapped and processed, i.e., calling <paramref name="byteCounter"/>.ByteCount immediately
            after this call will not provide the correct count.</para>
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="byteCounter">out param which exposes <seealso cref="P:Dot.Net.DevFast.IO.IByteCounter.ByteCount"/>) property.</param>
            <param name="include">If true is passed, compression is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenCompress(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.Boolean,System.IO.Compression.CompressionLevel,System.Boolean)">
            <summary>
            Applies compression on the data of given functional Stream pipe and returns a new pipe for chaining.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="gzip">If true, <seealso cref="T:System.IO.Compression.GZipStream"/> is used else 
            <seealso cref="T:System.IO.Compression.DeflateStream"/> is used</param>
            <param name="level">Compression level to use.</param>
            <param name="include">If true is passed, compression is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenComputeHash(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.Security.Cryptography.HashAlgorithm,System.Boolean)">
            <summary>
            Computes the hash on the data of the given functional stream pipe and returns a new pipe for chaining.
            <para>IMPORTANT: Access <seealso cref="P:System.Security.Cryptography.HashAlgorithm.Hash"/> ONLY AFTER the full
            piepline is bootstrapped and processed, i.e., calling <paramref name="ha"/>.Hash immediately
            after this call will not provide the correct hash.</para>
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="ha">Instance of crypto hash algorithm</param>
            <param name="include">If true is passed, hash is computed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenToBase64(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.Boolean)">
            <summary>
            Converts the data, of the given functional stream pipe to equivalent Base64
            and returns a new pipe for chaining.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="include">If true is passed, ToBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenFromBase64(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.Security.Cryptography.FromBase64TransformMode,System.Boolean)">
            <summary>
            Decodes the Base64 data, of the given functional stream pipe and returns a new pipe for chaining.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="mode">Base64 transform mode</param>
            <param name="include">If true is passed, FromBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenEncrypt``1(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.Func{``0},System.String,System.String,System.Security.Cryptography.HashAlgorithmName,System.Int32,System.Text.Encoding,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="T">Type of <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/> to apply</typeparam>
            <param name="src">Current pipe of the pipeline</param>
            <param name="cryptoProvider">lambda that provides the crypto instance</param>
            <param name="password">password for key/IV generation (see <seealso cref="T:System.Security.Cryptography.Rfc2898DeriveBytes"/>)</param>
            <param name="salt">Salt string to use during key/IV generation (see <seealso cref="T:System.Security.Cryptography.Rfc2898DeriveBytes"/>)</param>
            <param name="hashName">Hash algorithm to use</param>
            <param name="loopCnt">Loop count</param>
            <param name="enc">Encoding to use to convert password and salt to bytes. If not provided, UTF8Encoding(false) is used</param>
            <param name="include">If true is passed, FromBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenEncrypt``1(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.Func{``0},System.Byte[],System.Byte[],System.Security.Cryptography.CipherMode,System.Security.Cryptography.PaddingMode,System.Boolean)">
            <summary>
            Encrypts the underlying data, of the given functional stream pipe based on give <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/>,
            and returns a new pipe for chaining.
            </summary>
            <typeparam name="T">Type of <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/> to apply</typeparam>
            <param name="src">Current pipe of the pipeline</param>
            <param name="cryptoProvider">lambda that provides the crypto instance</param>
            <param name="key">key byte array</param>
            <param name="iv">iv byte array</param>
            <param name="cipher">Cipher mode to use</param>
            <param name="padding">Padding mode to use</param>
            <param name="include">If true is passed, FromBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenDecrypt``1(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.Func{``0},System.String,System.String,System.Security.Cryptography.HashAlgorithmName,System.Int32,System.Text.Encoding,System.Boolean)">
            <summary>
            Decrypts the underlying data, of the given functional stream pipe based on give <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/>,
            and returns a new pipe for chaining.
            <para>NOTE:You may use <seealso cref="M:Dot.Net.DevFast.Extensions.CreateExts.CreateKeyAndIv(System.String,System.String,System.Security.Cryptography.HashAlgorithmName,System.Int32,System.Int32,System.Int32,System.Text.Encoding)"/> extension method to create IV and KEY byte arrays
            using plain text password and salt string.</para>
            </summary>
            <typeparam name="T">Type of <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/> to apply</typeparam>
            <param name="src">Current pipe of the pipeline</param>
            <param name="cryptoProvider">lambda that provides the crypto instance</param>
            <param name="password">password for key/IV generation (see <seealso cref="T:System.Security.Cryptography.Rfc2898DeriveBytes"/>)</param>
            <param name="salt">Salt string to use during key/IV generation (see <seealso cref="T:System.Security.Cryptography.Rfc2898DeriveBytes"/>)</param>
            <param name="hashName">Hash algorithm to use</param>
            <param name="loopCnt">Loop count</param>
            <param name="enc">Encoding to use to convert password and salt to bytes. If not provided, UTF8Encoding(false) is used</param>
            <param name="include">If true is passed, FromBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenDecrypt``1(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.Func{``0},System.Byte[],System.Byte[],System.Security.Cryptography.CipherMode,System.Security.Cryptography.PaddingMode,System.Boolean)">
            <summary>
            Decrypts the underlying data, of the given functional stream pipe based on give <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/>,
            and returns a new pipe for chaining.
            </summary>
            <typeparam name="T">Type of <seealso cref="T:System.Security.Cryptography.SymmetricAlgorithm"/> to apply</typeparam>
            <param name="src">Current pipe of the pipeline</param>
            <param name="cryptoProvider">lambda that provides the crypto instance</param>
            <param name="key">key byte array</param>
            <param name="iv">iv byte array</param>
            <param name="cipher">Cipher mode to use</param>
            <param name="padding">Padding mode to use</param>
            <param name="include">If true is passed, FromBase64 conversion is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenTransform(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.Security.Cryptography.ICryptoTransform,System.Boolean)">
            <summary>
            Applies the given crypto transformation to the data of the given functional stream pipe
            and returns a new pipe for chaining.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="transformation">Crypto Transformation to apply</param>
            <param name="include">If true is passed, CryptoTransform is performed else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.ThenApply(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.Func{System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task}},System.Boolean)">
            <summary>
            Appends the given arbitrary custom functional stream pipe (i.e. <paramref name="applyFunc"/>) to the pipeline
            and returns a new pipe for chaining.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="applyFunc">Yet another custom functional stream pipe</param>
            <param name="include">If true is passed, given func is applied else ignored</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteFileAsync(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.String,System.String,System.Int32,System.IO.FileOptions,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pushes data throw the pipeline to the file.
            <para>Returns the <seealso cref="T:System.IO.FileInfo"/> object of that the written file</para>
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="folder">folder path where file is saved</param>
            <param name="filename">name of file. If not supplied a new GUID string will be used instead (without extension)</param>
            <param name="fileStreamBuffer">Buffer size of the file stream</param>
            <param name="options">File options</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteFileAsync(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.IO.DirectoryInfo,System.String,System.Int32,System.IO.FileOptions,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pushes data throw the pipeline to the file.
            <para>Returns the <seealso cref="T:System.IO.FileInfo"/> object of that the written file</para>
            </summary> 
            <param name="src">Current pipe of the pipeline</param>
            <param name="folder">directory information of folder where file will be created</param>
            <param name="filename">name of file. If not supplied a new GUID string will be used instead (without extension)</param>
            <param name="fileStreamBuffer">Buffer size of the file stream</param>
            <param name="options">File options</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteFileAsync(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.IO.FileInfo,System.Int32,System.IO.FileOptions,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pushes data throw the pipeline to the file.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="fileinfo">file info object of the file to create/rewrite.</param>
            <param name="fileStreamBuffer">Buffer size of the file stream</param>
            <param name="options">File options</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteBytesAsync(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pushes data throw the pipeline and returns the results as byte array.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="token">Cancellation token to observe</param>
            <param name="estimatedSize">Intial guess for the size of the byte array (optimization on resizing operation).</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteBufferAsync(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean,System.Int32)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pushes data throw the pipeline and returns the contents as newly created <seealso cref="T:System.IO.MemoryStream"/>.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="token">Cancellation token to observe</param>
            <param name="seekToOrigin">If true, Seek with <seealso cref="F:System.IO.SeekOrigin.Begin"/> is performed else not.</param>
            <param name="initialSize">Initial Memory buffer Size</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndExecuteAsync(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pushes data throw the pipeline.
            <para>NOTE: Calling this function will result in running the streaming pipeline, but, you won't receive
            anything in the end. Normally, usage of this function is to avoid use of <seealso cref="T:System.IO.MemoryStream"/>
            to reduce runtime memory pressure, and at the same time counting bytes, calculate crypto-hashes etc.</para>
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndCountBytesAsync(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the total bytes observed at the end.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StreamPipeExt.StreamPipeExts.AndWriteStreamAsync(System.Func{Dot.Net.DevFast.IO.PushFuncStream,System.Threading.Tasks.Task},System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Call to this method shall bootstrap the streaming pipeline and returns the associated asynchronous task that 
            pushes data throw the pipeline and appends the contents to the given <seealso cref="T:System.IO.Stream"/>.
            </summary>
            <param name="src">Current pipe of the pipeline</param>
            <param name="writableTarget">Target stream to write on</param>
            <param name="disposeTarget">If true, target stream is disposed else left open.</param>
            <param name="token">Cancellation token to observe</param>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.StringExt.StringSafe">
            <summary>
            Extension method on Safe (non-error throwing, except GIGO) string operations
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.IsNows(System.String)">
            <summary>
            Checks whether <paramref name="input"/> is NullOrWhiteSpace string.
            </summary>
            <param name="input">stirng to check</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.IsNotNows(System.String)">
            <summary>
            Checks whether <paramref name="input"/> is NOT NullOrWhiteSpace string.
            </summary>
            <param name="input">stirng to check</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToTrimmedUpperSafe(System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Trims and converts the <paramref name="input"/> string based on given culture 
            (if not supplied then <seealso cref="P:System.Globalization.CultureInfo.CurrentCulture"/> is used). 
            If null, returns the provided <paramref name="defaultValue"/>.
            </summary>
            <param name="input">value to operate on</param>
            <param name="defaultValue">return value in case, supplied value is null</param>
            <param name="culture">Culture to use, if null or not supplied, then <seealso cref="P:System.Globalization.CultureInfo.CurrentCulture"/> is used.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToTrimmedLowerSafe(System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Trims and converts the <paramref name="input"/> string based on given culture 
            (if not supplied then <seealso cref="P:System.Globalization.CultureInfo.CurrentCulture"/> is used). 
            If null, returns the provided <paramref name="defaultValue"/>.
            </summary>
            <param name="input">value to operate on</param>
            <param name="defaultValue">return value in case, supplied value is null</param>
            <param name="culture">Culture to use, if null or not supplied, then <seealso cref="P:System.Globalization.CultureInfo.CurrentCulture"/> is used.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.TrimSafeOrEmpty(System.String,System.Char[])">
            <summary>
            If value is null <seealso cref="F:System.String.Empty"/> is returned else trimmed string.
            <para>Also check <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.TrimUnsafe(System.String,System.Char[])"/>,
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.TrimSafeOrNull(System.String,System.Char[])"/> and <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.TrimSafeOrDefault(System.String,System.String,System.Char[])"/></para>
            </summary>
            <param name="input">Value to trim safe</param>
            <param name="trimChars">optional. when not given any char set,
            whitespaces will be removed</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.TrimSafeOrNull(System.String,System.Char[])">
            <summary>
            If value is null, null is returned else trimmed string.
            <para>Also check <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.TrimUnsafe(System.String,System.Char[])"/>,
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.TrimSafeOrEmpty(System.String,System.Char[])"/> and <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.TrimSafeOrDefault(System.String,System.String,System.Char[])"/></para>
            </summary>
            <param name="input">Value to trim safe</param>
            <param name="trimChars">optional. when not given any char set,
            whitespaces will be removed</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.TrimSafeOrDefault(System.String,System.String,System.Char[])">
            <summary>
            If value is null <paramref name="defaultValue"/> is returned else trimmed string.
            <para>Also check <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.TrimUnsafe(System.String,System.Char[])"/>,
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.TrimSafeOrEmpty(System.String,System.Char[])"/> and <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.TrimSafeOrNull(System.String,System.Char[])"/></para>
            </summary>
            <param name="input">Value to trim safe</param>
            <param name="defaultValue">default value to return when input is null.</param>
            <param name="trimChars">optional. when not given any char set,
            whitespaces will be removed</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToEnumOrDefault``1(System.String,``0,System.Boolean)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Enum"/> value along with
            <seealso cref="M:System.Enum.IsDefined(System.Type,System.Object)"/> check. Useful when it is not certain whether the parsed value 
            will result in existing define enum value (example when parsing integers back to enum coming from outside).
            If parsing is successful then returns the parsed value else returns the <paramref name="defaultVal"/>.
            <para>Also check <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnumUnchecked``1(System.String,``0@,System.Boolean)"/>,
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnumUnchecked``1(System.String,System.Nullable{``0}@,System.Boolean)"/>,
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnum``1(System.String,``0@,System.Boolean)"/> and
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnum``1(System.String,System.Nullable{``0}@,System.Boolean)"/> methods</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="defaultVal">Default value to return when parsing fails</param>
            <param name="ignoreCase">true to ignore case, else false to consider string casing</param>
            <typeparam name="T">Enum type</typeparam>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToEnumUncheckedOrDefault``1(System.String,``0,System.Boolean)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Enum"/> value (NOTE: <seealso cref="M:System.Enum.IsDefined(System.Type,System.Object)"/> check
            is NOT performed). Useful when it is known for sure that the parsed value is among existing value..
            If parsing is successful then returns the parsed value else returns the <paramref name="defaultVal"/>.
            <para>Also check <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnumUnchecked``1(System.String,``0@,System.Boolean)"/>,
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnumUnchecked``1(System.String,System.Nullable{``0}@,System.Boolean)"/>,
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnum``1(System.String,``0@,System.Boolean)"/> and
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnum``1(System.String,System.Nullable{``0}@,System.Boolean)"/> methods</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="defaultVal">Default value to return when parsing fails</param>
            <param name="ignoreCase">true to ignore case, else false to consider string casing</param>
            <typeparam name="T">Enum type</typeparam>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToOrDefault(System.String,System.Boolean)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Boolean"/> value. If parsing is successful
            then returns the parsed value else returns the <paramref name="defaultVal"/>.
            </summary>
            <param name="input">string to parse</param>
            <param name="defaultVal">Default value to return when parsing fails</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToOrDefault(System.String,System.Int32,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Int32"/> value. If parsing is successful
            then returns the parsed value else returns the <paramref name="defaultVal"/>.
            </summary>
            <param name="input">string to parse</param>
            <param name="defaultVal">Default value to return when parsing fails</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToOrDefault(System.String,System.Int64,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Int64"/> value. If parsing is successful
            then returns the parsed value else returns the <paramref name="defaultVal"/>.
            </summary>
            <param name="input">string to parse</param>
            <param name="defaultVal">Default value to return when parsing fails</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToOrDefault(System.String,System.Byte,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Byte"/> value. If parsing is successful
            then returns the parsed value else returns the <paramref name="defaultVal"/>.
            </summary>
            <param name="input">string to parse</param>
            <param name="defaultVal">Default value to return when parsing fails</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToOrDefault(System.String,System.SByte,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.SByte"/> value. If parsing is successful
            then returns the parsed value else returns the <paramref name="defaultVal"/>.
            </summary>
            <param name="input">string to parse</param>
            <param name="defaultVal">Default value to return when parsing fails</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToOrDefault(System.String,System.Int16,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Int16"/> value. If parsing is successful
            then returns the parsed value else returns the <paramref name="defaultVal"/>.
            </summary>
            <param name="input">string to parse</param>
            <param name="defaultVal">Default value to return when parsing fails</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToOrDefault(System.String,System.UInt16,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.UInt16"/> value. If parsing is successful
            then returns the parsed value else returns the <paramref name="defaultVal"/>.
            </summary>
            <param name="input">string to parse</param>
            <param name="defaultVal">Default value to return when parsing fails</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToOrDefault(System.String,System.UInt32,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.UInt32"/> value. If parsing is successful
            then returns the parsed value else returns the <paramref name="defaultVal"/>.
            </summary>
            <param name="input">string to parse</param>
            <param name="defaultVal">Default value to return when parsing fails</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToOrDefault(System.String,System.UInt64,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.UInt64"/> value. If parsing is successful
            then returns the parsed value else returns the <paramref name="defaultVal"/>.
            </summary>
            <param name="input">string to parse</param>
            <param name="defaultVal">Default value to return when parsing fails</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToOrDefault(System.String,System.Single,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Single"/> value. If parsing is successful
            then returns the parsed value else returns the <paramref name="defaultVal"/>.
            </summary>
            <param name="input">string to parse</param>
            <param name="defaultVal">Default value to return when parsing fails</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToOrDefault(System.String,System.Double,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Double"/> value. If parsing is successful
            then returns the parsed value else returns the <paramref name="defaultVal"/>.
            </summary>
            <param name="input">string to parse</param>
            <param name="defaultVal">Default value to return when parsing fails</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToOrDefault(System.String,System.Decimal,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Decimal"/> value. If parsing is successful
            then returns the parsed value else returns the <paramref name="defaultVal"/>.
            </summary>
            <param name="input">string to parse</param>
            <param name="defaultVal">Default value to return when parsing fails</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToOrDefault(System.String,System.DateTime,System.String,System.Globalization.DateTimeStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.DateTime"/> value using exact parsing.
            If parsing is successful then returns the parsed value else returns the 
            <paramref name="defaultVal"/>.
            </summary>
            <param name="input">string to parse</param>
            <param name="defaultVal">Default value to return when parsing fails</param>
            <param name="format">date format string</param>
            <param name="formatProvider">format provider</param>
            <param name="style">datetime style</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToOrDefault(System.String,System.DateTime,System.String[],System.Globalization.DateTimeStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.DateTime"/> value using exact parsing
            based on given set of formats. If parsing is successful then returns the parsed value 
            else returns the <paramref name="defaultVal"/>.
            </summary>
            <param name="input">string to parse</param>
            <param name="defaultVal">Default value to return when parsing fails</param>
            <param name="formats">date format strings</param>
            <param name="formatProvider">format provider</param>
            <param name="style">datetime style</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToOrDefault(System.String,System.DateTime,System.Globalization.DateTimeStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.DateTime"/> value. If parsing is successful
            then returns the parsed value else returns the <paramref name="defaultVal"/>.
            </summary>
            <param name="input">string to parse</param>
            <param name="defaultVal">Default value to return when parsing fails</param>
            <param name="formatProvider">format provider</param>
            <param name="style">datetime style</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.StringExt.StringTryTo">
            <summary>
            Extension methods to parse string to different structs.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Boolean@)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Boolean"/> value.
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Type@,System.Boolean)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Type"/> value.
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="ignoreCase">true to ignore string casing else false to consider casing</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Int32@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Int32"/> value.
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Int64@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Int64"/> value.
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Byte@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Byte"/> value.
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.SByte@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.SByte"/> value.
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Int16@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Int16"/> value.
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.UInt16@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.UInt16"/> value.
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.UInt32@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.UInt32"/> value.
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.UInt64@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.UInt64"/> value.
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Single@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Single"/> value.
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Double@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Double"/> value.
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Decimal@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Decimal"/> value.
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.DateTime@,System.String,System.Globalization.DateTimeStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.DateTime"/> value using exact parsing.
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="format">date format string</param>
            <param name="formatProvider">format provider</param>
            <param name="style">datetime style</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.DateTime@,System.String[],System.Globalization.DateTimeStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.DateTime"/> value using exact parsing
            based on given set of formats.
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="formats">date format strings</param>
            <param name="formatProvider">format provider</param>
            <param name="style">datetime style</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.DateTime@,System.Globalization.DateTimeStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.DateTime"/> value.
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="formatProvider">format provider</param>
            <param name="style">datetime style</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnumUnchecked``1(System.String,``0@,System.Boolean)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Enum"/> value.
            <para>Does not validate the existence of parsed value. Could be useful when
            it is known for sure that the parsed value is among existing value.</para>
            <para>Also check <see cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnum``1(System.String,``0@,System.Boolean)"/>
            and <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToEnumOrDefault``1(System.String,``0,System.Boolean)"/> and 
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToEnumUncheckedOrDefault``1(System.String,``0,System.Boolean)"/> methods</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="ignoreCase">true to ignore case, else false to consider string casing</param>
            <returns>True if parsing is successful else false</returns>
            <typeparam name="T">Enum type</typeparam>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnum``1(System.String,``0@,System.Boolean)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Enum"/> value.
            <para>If parsing is successful then calls <seealso cref="M:System.Enum.IsDefined(System.Type,System.Object)"/>. Useful when
            it is not certain whether the parsed value will result in existing define enum value.
            (example when parsing integers back to enum coming from outside)</para>
            <para>Also check <see cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnumUnchecked``1(System.String,``0@,System.Boolean)"/>
            and <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToEnumOrDefault``1(System.String,``0,System.Boolean)"/> and 
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToEnumUncheckedOrDefault``1(System.String,``0,System.Boolean)"/> methods</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="ignoreCase">true to ignore case, else false to consider string casing</param>
            <returns>True if parsing is successful else false</returns>
            <typeparam name="T">Enum type</typeparam>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Nullable{System.Boolean}@)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Boolean"/>? value.
            <para>Returns true when:
            <list type="bullet">
            <item><description><paramref name="input"/> is <seealso cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
            and out <paramref name="value"/> as null.</description></item>
            <item><description><paramref name="input"/> is parsable to <seealso cref="T:System.Boolean"/> with
            <paramref name="value"/> as the parsed outcome.</description></item>
            </list></para>
            <para>Returns false when <paramref name="input"/> is NOT parsable to <seealso cref="T:System.Boolean"/>
            with <paramref name="value"/> as null.</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Nullable{System.Int32}@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Int32"/>? value.
            <para>Returns true when:
            <list type="bullet">
            <item><description><paramref name="input"/> is <seealso cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
            and out <paramref name="value"/> as null.</description></item>
            <item><description><paramref name="input"/> is parsable to <seealso cref="T:System.Int32"/> with
            <paramref name="value"/> as the parsed outcome.</description></item>
            </list></para>
            <para>Returns false when <paramref name="input"/> is NOT parsable to <seealso cref="T:System.Int32"/>
            with <paramref name="value"/> as null.</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Nullable{System.Int64}@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Int64"/>? value.
            <para>Returns true when:
            <list type="bullet">
            <item><description><paramref name="input"/> is <seealso cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
            and out <paramref name="value"/> as null.</description></item>
            <item><description><paramref name="input"/> is parsable to <seealso cref="T:System.Int64"/> with
            <paramref name="value"/> as the parsed outcome.</description></item>
            </list></para>
            <para>Returns false when <paramref name="input"/> is NOT parsable to <seealso cref="T:System.Int64"/>
            with <paramref name="value"/> as null.</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Nullable{System.Byte}@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Byte"/>? value.
            <para>Returns true when:
            <list type="bullet">
            <item><description><paramref name="input"/> is <seealso cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
            and out <paramref name="value"/> as null.</description></item>
            <item><description><paramref name="input"/> is parsable to <seealso cref="T:System.Byte"/> with
            <paramref name="value"/> as the parsed outcome.</description></item>
            </list></para>
            <para>Returns false when <paramref name="input"/> is NOT parsable to <seealso cref="T:System.Byte"/>
            with <paramref name="value"/> as null.</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Nullable{System.SByte}@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.SByte"/>? value.
            <para>Returns true when:
            <list type="bullet">
            <item><description><paramref name="input"/> is <seealso cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
            and out <paramref name="value"/> as null.</description></item>
            <item><description><paramref name="input"/> is parsable to <seealso cref="T:System.SByte"/> with
            <paramref name="value"/> as the parsed outcome.</description></item>
            </list></para>
            <para>Returns false when <paramref name="input"/> is NOT parsable to <seealso cref="T:System.SByte"/>
            with <paramref name="value"/> as null.</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Nullable{System.Int16}@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Int16"/>? value.
            <para>Returns true when:
            <list type="bullet">
            <item><description><paramref name="input"/> is <seealso cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
            and out <paramref name="value"/> as null.</description></item>
            <item><description><paramref name="input"/> is parsable to <seealso cref="T:System.Int16"/> with
            <paramref name="value"/> as the parsed outcome.</description></item>
            </list></para>
            <para>Returns false when <paramref name="input"/> is NOT parsable to <seealso cref="T:System.Int16"/>
            with <paramref name="value"/> as null.</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Nullable{System.UInt16}@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.UInt16"/>? value.
            <para>Returns true when:
            <list type="bullet">
            <item><description><paramref name="input"/> is <seealso cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
            and out <paramref name="value"/> as null.</description></item>
            <item><description><paramref name="input"/> is parsable to <seealso cref="T:System.UInt16"/> with
            <paramref name="value"/> as the parsed outcome.</description></item>
            </list></para>
            <para>Returns false when <paramref name="input"/> is NOT parsable to <seealso cref="T:System.UInt16"/>
            with <paramref name="value"/> as null.</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Nullable{System.UInt32}@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.UInt32"/>? value.
            <para>Returns true when:
            <list type="bullet">
            <item><description><paramref name="input"/> is <seealso cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
            and out <paramref name="value"/> as null.</description></item>
            <item><description><paramref name="input"/> is parsable to <seealso cref="T:System.UInt32"/> with
            <paramref name="value"/> as the parsed outcome.</description></item>
            </list></para>
            <para>Returns false when <paramref name="input"/> is NOT parsable to <seealso cref="T:System.UInt32"/>
            with <paramref name="value"/> as null.</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Nullable{System.UInt64}@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.UInt64"/>? value.
            <para>Returns true when:
            <list type="bullet">
            <item><description><paramref name="input"/> is <seealso cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
            and out <paramref name="value"/> as null.</description></item>
            <item><description><paramref name="input"/> is parsable to <seealso cref="T:System.UInt64"/> with
            <paramref name="value"/> as the parsed outcome.</description></item>
            </list></para>
            <para>Returns false when <paramref name="input"/> is NOT parsable to <seealso cref="T:System.UInt64"/>
            with <paramref name="value"/> as null.</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Nullable{System.Single}@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Single"/>? value.
            <para>Returns true when:
            <list type="bullet">
            <item><description><paramref name="input"/> is <seealso cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
            and out <paramref name="value"/> as null.</description></item>
            <item><description><paramref name="input"/> is parsable to <seealso cref="T:System.Single"/> with
            <paramref name="value"/> as the parsed outcome.</description></item>
            </list></para>
            <para>Returns false when <paramref name="input"/> is NOT parsable to <seealso cref="T:System.Single"/>
            with <paramref name="value"/> as null.</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Nullable{System.Double}@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Double"/>? value.
            <para>Returns true when:
            <list type="bullet">
            <item><description><paramref name="input"/> is <seealso cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
            and out <paramref name="value"/> as null.</description></item>
            <item><description><paramref name="input"/> is parsable to <seealso cref="T:System.Double"/> with
            <paramref name="value"/> as the parsed outcome.</description></item>
            </list></para>
            <para>Returns false when <paramref name="input"/> is NOT parsable to <seealso cref="T:System.Double"/>
            with <paramref name="value"/> as null.</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Nullable{System.Decimal}@,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Decimal"/>? value.
            <para>Returns true when:
            <list type="bullet">
            <item><description><paramref name="input"/> is <seealso cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
            and out <paramref name="value"/> as null.</description></item>
            <item><description><paramref name="input"/> is parsable to <seealso cref="T:System.Decimal"/> with
            <paramref name="value"/> as the parsed outcome.</description></item>
            </list></para>
            <para>Returns false when <paramref name="input"/> is NOT parsable to <seealso cref="T:System.Decimal"/>
            with <paramref name="value"/> as null.</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Nullable{System.DateTime}@,System.String,System.Globalization.DateTimeStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.DateTime"/>? value using exact parsing.
            <para>Returns true when:
            <list type="bullet">
            <item><description><paramref name="input"/> is <seealso cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
            and out <paramref name="value"/> as null.</description></item>
            <item><description><paramref name="input"/> is parsable to <seealso cref="T:System.DateTime"/> with
            <paramref name="value"/> as the parsed outcome.</description></item>
            </list></para>
            <para>Returns false when <paramref name="input"/> is NOT parsable to <seealso cref="T:System.DateTime"/>
            with <paramref name="value"/> as null.</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="format">date format string</param>
            <param name="formatProvider">format provider</param>
            <param name="style">datetime style</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Nullable{System.DateTime}@,System.String[],System.Globalization.DateTimeStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.DateTime"/>? value using exact parsing
            based on given set of formats.
            <para>Returns true when:
            <list type="bullet">
            <item><description><paramref name="input"/> is <seealso cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
            and out <paramref name="value"/> as null.</description></item>
            <item><description><paramref name="input"/> is parsable to <seealso cref="T:System.DateTime"/> with
            <paramref name="value"/> as the parsed outcome.</description></item>
            </list></para>
            <para>Returns false when <paramref name="input"/> is NOT parsable to <seealso cref="T:System.DateTime"/>
            with <paramref name="value"/> as null.</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="formats">date format strings</param>
            <param name="formatProvider">format provider</param>
            <param name="style">datetime style</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryTo(System.String,System.Nullable{System.DateTime}@,System.Globalization.DateTimeStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.DateTime"/>? value.
            <para>Returns true when:
            <list type="bullet">
            <item><description><paramref name="input"/> is <seealso cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
            and out <paramref name="value"/> as null.</description></item>
            <item><description><paramref name="input"/> is parsable to <seealso cref="T:System.DateTime"/> with
            <paramref name="value"/> as the parsed outcome.</description></item>
            </list></para>
            <para>Returns false when <paramref name="input"/> is NOT parsable to <seealso cref="T:System.DateTime"/>
            with <paramref name="value"/> as null.</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="formatProvider">format provider</param>
            <param name="style">datetime style</param>
            <returns>True if parsing is successful else false</returns>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnumUnchecked``1(System.String,System.Nullable{``0}@,System.Boolean)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Enum"/> value.
            <para>Does not validate the existence of parsed value. Could be useful when
            it is known for sure that the parsed value is among existing value.</para>
            <para>Also check <see cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnum``1(System.String,System.Nullable{``0}@,System.Boolean)"/>,
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToEnumOrDefault``1(System.String,``0,System.Boolean)"/> and 
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToEnumUncheckedOrDefault``1(System.String,``0,System.Boolean)"/> methods</para>
            <para>Returns true when:
            <list type="bullet">
            <item><description><paramref name="input"/> is <seealso cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
            and out <paramref name="value"/> as null.</description></item>
            <item><description><paramref name="input"/> is parsable to <typeparamref name="T"/> with
            <paramref name="value"/> as the parsed outcome without checking whether it is defined or not.</description></item>
            </list></para>
            <para>Returns false when <paramref name="input"/> is NOT parsable to <typeparamref name="T"/>
            and <paramref name="value"/> as null.</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="ignoreCase">true to ignore case, else false to consider string casing</param>
            <returns>True if parsing is successful else false</returns>
            <typeparam name="T">Enum type</typeparam>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnum``1(System.String,System.Nullable{``0}@,System.Boolean)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Enum"/> value.
            <para>If parsing is successful then calls <seealso cref="M:System.Enum.IsDefined(System.Type,System.Object)"/>. Useful when
            it is not certain whether the parsed value will result in existing define enum value.
            (example when parsing integers back to enum coming from outside)</para>
            <para>Also check <see cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnumUnchecked``1(System.String,System.Nullable{``0}@,System.Boolean)"/>
            and <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToEnumOrDefault``1(System.String,``0,System.Boolean)"/> and 
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.ToEnumUncheckedOrDefault``1(System.String,``0,System.Boolean)"/> methods</para>
            <para>Returns true when:
            <list type="bullet">
            <item><description><paramref name="input"/> is <seealso cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
            and out <paramref name="value"/> as null.</description></item>
            <item><description><paramref name="input"/> is parsable to <typeparamref name="T"/> with
            <paramref name="value"/> as the parsed outcome among defined values.</description></item>
            </list></para>
            <para>Returns false when <paramref name="input"/> is NOT parsable to <typeparamref name="T"/>
            or the value does not exits among defined value, in this case <paramref name="value"/> as null.</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="value">parsed value</param>
            <param name="ignoreCase">true to ignore case, else false to consider string casing</param>
            <returns>True if parsing is successful else false</returns>
            <typeparam name="T">Enum type</typeparam>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe">
            <summary>
            Extension method on UnSafe (possible exception or invalid results) string operations
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.TrimUnsafe(System.String,System.Char[])">
            <summary>
            Trims string when not null else throws error (another way to avoid <seealso cref="T:System.NullReferenceException"/>)
            <para>Also check <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.TrimSafeOrEmpty(System.String,System.Char[])"/>, 
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.TrimSafeOrNull(System.String,System.Char[])"/> and 
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringSafe.TrimSafeOrDefault(System.String,System.String,System.Char[])"/></para>
            </summary>
            <param name="input">Value to trim safe</param>
            <param name="trimChars">optional. when not given any char set,
            whitespaces will be removed</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When null string is passed as input
            (refer <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.NullString"/>)</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToFileInfo(System.String,System.String,System.String)">
            <summary>
            Returns a new <seealso cref="T:System.IO.FileInfo"/> instance after joining filename with extension
            to the <paramref name="folderPath"/>.
            <para>Expect all <seealso cref="T:System.IO.FileInfo"/> related errors.</para>
            </summary>
            <param name="folderPath">Folder path to the file</param>
            <param name="filename">filename without extension</param>
            <param name="extension">extension without period, e.g., "txt", "json" etc</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToFileInfo(System.String,System.String)">
            <summary>
            Returns a new <seealso cref="T:System.IO.FileInfo"/> instance after joining <paramref name="filenameWithExt"/>
            to the <paramref name="folderPath"/>.
            <para>Expect all <seealso cref="T:System.IO.FileInfo"/> related errors.</para>
            </summary>
            <param name="folderPath">Folder path to the file</param>
            <param name="filenameWithExt">file name with extensions, e.g., "abc.txt", "mydata.json" etc</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToFileInfo(System.String)">
            <summary>
            Returns a new <seealso cref="T:System.IO.FileInfo"/> instance from given <paramref name="fullFilePath"/>.
            <para>Expect all <seealso cref="T:System.IO.FileInfo"/> related errors.</para>
            </summary>
            <param name="fullFilePath">Complete path of the file</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToDirectoryInfo(System.String,System.String[],System.Boolean)">
            <summary>
            Returns a new <seealso cref="T:System.IO.DirectoryInfo"/> instance from combined path using
            <paramref name="basePath"/> and <paramref name="subPaths"/>.
            <para>Expect all <seealso cref="T:System.IO.DirectoryInfo"/> related errors.</para>
            </summary>
            <param name="basePath">base path</param>
            <param name="subPaths">individual path components</param>
            <param name="create">if true <seealso cref="M:System.IO.Directory.CreateDirectory(System.String)"/> will be called</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">When null array is passed as input
            (refer  <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.NullOrEmptyCollection"/>)</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToDirectoryInfo(System.String,System.Boolean)">
            <summary>
            Returns a new <seealso cref="T:System.IO.DirectoryInfo"/> instance from given <paramref name="fullPath"/>.
            <para>Expect all <seealso cref="T:System.IO.DirectoryInfo"/> related errors.</para>
            </summary>
            <param name="fullPath">Full path to the directory</param>
            <param name="create">if true <seealso cref="M:System.IO.Directory.CreateDirectory(System.String)"/> will be called</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToEnum``1(System.String,System.Boolean)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Enum"/> value along with
            <seealso cref="M:System.Enum.IsDefined(System.Type,System.Object)"/> check. Useful when it is not certain whether the parsed value 
            will result in existing define enum value (example when parsing integers back to enum coming from outside).
            If parsing is successful then returns the parsed value else throws an exception.
            <para>Also check <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnumUnchecked``1(System.String,``0@,System.Boolean)"/>,
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnumUnchecked``1(System.String,System.Nullable{``0}@,System.Boolean)"/>,
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnum``1(System.String,``0@,System.Boolean)"/> and
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnum``1(System.String,System.Nullable{``0}@,System.Boolean)"/> methods</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="ignoreCase">true to ignore case, else false to consider string casing</param>
            <typeparam name="T">Enum type</typeparam>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">with <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToEnumUnchecked``1(System.String,System.Boolean)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Enum"/> value (NOTE: <seealso cref="M:System.Enum.IsDefined(System.Type,System.Object)"/> check
            is NOT performed). Useful when it is known for sure that the parsed value is among existing value..
            If parsing is successful then returns the parsed value else throws an exception.
            <para>Also check <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnumUnchecked``1(System.String,``0@,System.Boolean)"/>,
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnumUnchecked``1(System.String,System.Nullable{``0}@,System.Boolean)"/>,
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnum``1(System.String,``0@,System.Boolean)"/> and
            <seealso cref="M:Dot.Net.DevFast.Extensions.StringExt.StringTryTo.TryToEnum``1(System.String,System.Nullable{``0}@,System.Boolean)"/> methods</para>
            </summary>
            <param name="input">string to parse</param>
            <param name="ignoreCase">true to ignore case, else false to consider string casing</param>
            <typeparam name="T">Enum type</typeparam>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">with <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToBool(System.String)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Boolean"/> value. If parsing is successful
            then returns the parsed value else throws an exception.
            </summary>
            <param name="input">string to parse</param>
            <returns>True if parsing is successful else false</returns>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">with <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToInt(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Int32"/> value. If parsing is successful
            then returns the parsed value else throws an exception.
            </summary>
            <param name="input">string to parse</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">with <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToLong(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Int64"/> value. If parsing is successful
            then returns the parsed value else throws an exception.
            </summary>
            <param name="input">string to parse</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">with <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToByte(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Byte"/> value. If parsing is successful
            then returns the parsed value else throws an exception.
            </summary>
            <param name="input">string to parse</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">with <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToSByte(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.SByte"/> value. If parsing is successful
            then returns the parsed value else throws an exception.
            </summary>
            <param name="input">string to parse</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">with <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToShort(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Int16"/> value. If parsing is successful
            then returns the parsed value else throws an exception.
            </summary>
            <param name="input">string to parse</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">with <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToUShort(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.UInt16"/> value. If parsing is successful
            then returns the parsed value else throws an exception.
            </summary>
            <param name="input">string to parse</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">with <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToUInt(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.UInt32"/> value. If parsing is successful
            then returns the parsed value else throws an exception.
            </summary>
            <param name="input">string to parse</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">with <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToULong(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.UInt64"/> value. If parsing is successful
            then returns the parsed value else throws an exception.
            </summary>
            <param name="input">string to parse</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">with <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToFloat(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Single"/> value. If parsing is successful
            then returns the parsed value else throws an exception.
            </summary>
            <param name="input">string to parse</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">with <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToDouble(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Double"/> value. If parsing is successful
            then returns the parsed value else throws an exception.
            </summary>
            <param name="input">string to parse</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">with <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToDecimal(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.Decimal"/> value. If parsing is successful
            then returns the parsed value else throws an exception.
            </summary>
            <param name="input">string to parse</param>
            <param name="style">style to use during parsing</param>
            <param name="formatProvider">format provider</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">with <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToDateTime(System.String,System.String,System.Globalization.DateTimeStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.DateTime"/> value using exact parsing.
            If parsing is successful then returns the parsed value else throws an exception.
            </summary>
            <param name="input">string to parse</param>
            <param name="format">date format string</param>
            <param name="formatProvider">format provider</param>
            <param name="style">datetime style</param>
            <returns>True if parsing is successful else false</returns>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">with <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToDateTime(System.String,System.String[],System.Globalization.DateTimeStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.DateTime"/> value using exact parsing
            based on given set of formats. If parsing is successful then returns the parsed value 
            else throws an exception.
            </summary>
            <param name="input">string to parse</param>
            <param name="formats">date format strings</param>
            <param name="formatProvider">format provider</param>
            <param name="style">datetime style</param>
            <returns>True if parsing is successful else false</returns>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">with <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToDateTime(System.String,System.Globalization.DateTimeStyles,System.IFormatProvider)">
            <summary>
            Tries parsing <seealso cref="T:System.String"/> to <seealso cref="T:System.DateTime"/> value. If parsing is successful
            then returns the parsed value else throws an exception.
            </summary>
            <param name="input">string to parse</param>
            <param name="formatProvider">format provider</param>
            <param name="style">datetime style</param>
            <returns>True if parsing is successful else false</returns>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">with <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.StringParsingFailed"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToBytes(System.String,System.Text.Encoding)">
            <summary>
            Converts the <paramref name="input"/> to byte array, based on <paramref name="enc"/>.
            </summary>
            <param name="input">Input string</param>
            <param name="enc">Encoding to use, if not supplied then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">when <paramref name="input"/> is null</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToByteSegment(System.String,System.Text.Encoding)">
            <summary>
            Converts the <paramref name="input"/> to byte array segment, based on <paramref name="enc"/>.
            </summary>
            <param name="input">Input string</param>
            <param name="enc">Encoding to use, if not supplied then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">when <paramref name="input"/> is null</exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToStreamAsync(System.String,System.IO.Stream,System.Text.Encoding,System.Threading.CancellationToken,System.Int32,System.Boolean)">
            <summary>
            Writes the <paramref name="input"/> to <paramref name="targetStream"/> using <paramref name="enc"/>
            while watching the <paramref name="token"/>.
            </summary>
            <param name="input">Input string</param>
            <param name="targetStream">target stream for data writing</param>
            <param name="enc">Encoding to use, if not supplied then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">when <paramref name="input"/> is null</exception>
            <param name="token">Cancellation token</param>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeTarget">True to dispose <paramref name="targetStream"/>, false
            to leave it undisposed after the write.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.StringExt.StringUnsafe.ToStreamAsync(System.Text.StringBuilder,System.IO.Stream,System.Text.Encoding,System.Threading.CancellationToken,System.Int32,System.Boolean)">
            <summary>
            Writes the string value of <paramref name="input"/> to <paramref name="targetStream"/> using <paramref name="enc"/>
            while watching the <paramref name="token"/>.
            </summary>
            <param name="input">Input string</param>
            <param name="targetStream">target stream for data writing</param>
            <param name="token">Cancellation token</param>
            <param name="enc">Encoding to use, if not supplied then <seealso cref="P:System.Text.Encoding.UTF8"/> is used.</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">when <paramref name="input"/> is null</exception>
            <param name="bufferSize">Buffer size</param>
            <param name="disposeTarget">True to dispose <paramref name="targetStream"/>, false
            to leave it undisposed after the write.</param>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.SyncAsync">
            <summary>
            Contains extension method on synchronous delegates to convert those to corresponding Async delegates
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync(System.Action,System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous action to async func that returns a task to await on with an option to
            delegate the action execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).</para>
            </summary>
            <param name="sync">synchronous action method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the action might still be executing.
            Thus, to truly stop the action execution one must find a way to observe the same token
            inside the action body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``1(System.Func{``0},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous func to async func that returns a typed-task to await on with an option to
            delegate the func execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>).</para>
            </summary>
            <param name="sync">synchronous func method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the func might still be executing.
            Thus, to truly stop the func execution one must find a way to observe the same token
            inside the func body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``1(System.Action{``0},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous action to async func that returns a task to await on with an option to
            delegate the action execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).</para>
            </summary>
            <param name="sync">synchronous action method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the action might still be executing.
            Thus, to truly stop the action execution one must find a way to observe the same token
            inside the action body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``2(System.Func{``0,``1},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous func to async func that returns a typed-task to await on with an option to
            delegate the func execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>).</para>
            </summary>
            <param name="sync">synchronous func method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the func might still be executing.
            Thus, to truly stop the func execution one must find a way to observe the same token
            inside the func body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``2(System.Action{``0,``1},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous action to async func that returns a task to await on with an option to
            delegate the action execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).</para>
            </summary>
            <param name="sync">synchronous action method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the action might still be executing.
            Thus, to truly stop the action execution one must find a way to observe the same token
            inside the action body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``3(System.Func{``0,``1,``2},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous func to async func that returns a typed-task to await on with an option to
            delegate the func execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>).</para>
            </summary>
            <param name="sync">synchronous func method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the func might still be executing.
            Thus, to truly stop the func execution one must find a way to observe the same token
            inside the func body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``3(System.Action{``0,``1,``2},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous action to async func that returns a task to await on with an option to
            delegate the action execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).</para>
            </summary>
            <param name="sync">synchronous action method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the action might still be executing.
            Thus, to truly stop the action execution one must find a way to observe the same token
            inside the action body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``4(System.Func{``0,``1,``2,``3},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous func to async func that returns a typed-task to await on with an option to
            delegate the func execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>).</para>
            </summary>
            <param name="sync">synchronous func method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the func might still be executing.
            Thus, to truly stop the func execution one must find a way to observe the same token
            inside the func body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``4(System.Action{``0,``1,``2,``3},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous action to async func that returns a task to await on with an option to
            delegate the action execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).</para>
            </summary>
            <param name="sync">synchronous action method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the action might still be executing.
            Thus, to truly stop the action execution one must find a way to observe the same token
            inside the action body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``5(System.Func{``0,``1,``2,``3,``4},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous func to async func that returns a typed-task to await on with an option to
            delegate the func execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>).</para>
            </summary>
            <param name="sync">synchronous func method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the func might still be executing.
            Thus, to truly stop the func execution one must find a way to observe the same token
            inside the func body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``5(System.Action{``0,``1,``2,``3,``4},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous action to async func that returns a task to await on with an option to
            delegate the action execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).</para>
            </summary>
            <param name="sync">synchronous action method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the action might still be executing.
            Thus, to truly stop the action execution one must find a way to observe the same token
            inside the action body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``6(System.Func{``0,``1,``2,``3,``4,``5},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous func to async func that returns a typed-task to await on with an option to
            delegate the func execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>).</para>
            </summary>
            <param name="sync">synchronous func method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the func might still be executing.
            Thus, to truly stop the func execution one must find a way to observe the same token
            inside the func body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``6(System.Action{``0,``1,``2,``3,``4,``5},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous action to async func that returns a task to await on with an option to
            delegate the action execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).</para>
            </summary>
            <param name="sync">synchronous action method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the action might still be executing.
            Thus, to truly stop the action execution one must find a way to observe the same token
            inside the action body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``7(System.Func{``0,``1,``2,``3,``4,``5,``6},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous func to async func that returns a typed-task to await on with an option to
            delegate the func execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>).</para>
            </summary>
            <param name="sync">synchronous func method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the func might still be executing.
            Thus, to truly stop the func execution one must find a way to observe the same token
            inside the func body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``7(System.Action{``0,``1,``2,``3,``4,``5,``6},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous action to async func that returns a task to await on with an option to
            delegate the action execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).</para>
            </summary>
            <param name="sync">synchronous action method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the action might still be executing.
            Thus, to truly stop the action execution one must find a way to observe the same token
            inside the action body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous func to async func that returns a typed-task to await on with an option to
            delegate the func execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>).</para>
            </summary>
            <param name="sync">synchronous func method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the func might still be executing.
            Thus, to truly stop the func execution one must find a way to observe the same token
            inside the func body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``8(System.Action{``0,``1,``2,``3,``4,``5,``6,``7},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous action to async func that returns a task to await on with an option to
            delegate the action execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).</para>
            </summary>
            <param name="sync">synchronous action method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the action might still be executing.
            Thus, to truly stop the action execution one must find a way to observe the same token
            inside the action body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous func to async func that returns a typed-task to await on with an option to
            delegate the func execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>).</para>
            </summary>
            <param name="sync">synchronous func method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the func might still be executing.
            Thus, to truly stop the func execution one must find a way to observe the same token
            inside the func body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous action to async func that returns a task to await on with an option to
            delegate the action execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).</para>
            </summary>
            <param name="sync">synchronous action method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the action might still be executing.
            Thus, to truly stop the action execution one must find a way to observe the same token
            inside the action body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous func to async func that returns a typed-task to await on with an option to
            delegate the func execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>).</para>
            </summary>
            <param name="sync">synchronous func method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the func might still be executing.
            Thus, to truly stop the func execution one must find a way to observe the same token
            inside the func body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous action to async func that returns a task to await on with an option to
            delegate the action execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).</para>
            </summary>
            <param name="sync">synchronous action method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the action might still be executing.
            Thus, to truly stop the action execution one must find a way to observe the same token
            inside the action body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous func to async func that returns a typed-task to await on with an option to
            delegate the func execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>).</para>
            </summary>
            <param name="sync">synchronous func method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the func might still be executing.
            Thus, to truly stop the func execution one must find a way to observe the same token
            inside the func body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``11(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous action to async func that returns a task to await on with an option to
            delegate the action execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).</para>
            </summary>
            <param name="sync">synchronous action method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the action might still be executing.
            Thus, to truly stop the action execution one must find a way to observe the same token
            inside the action body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous func to async func that returns a typed-task to await on with an option to
            delegate the func execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>).</para>
            </summary>
            <param name="sync">synchronous func method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the func might still be executing.
            Thus, to truly stop the func execution one must find a way to observe the same token
            inside the func body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``12(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous action to async func that returns a task to await on with an option to
            delegate the action execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).</para>
            </summary>
            <param name="sync">synchronous action method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the action might still be executing.
            Thus, to truly stop the action execution one must find a way to observe the same token
            inside the action body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous func to async func that returns a typed-task to await on with an option to
            delegate the func execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>).</para>
            </summary>
            <param name="sync">synchronous func method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the func might still be executing.
            Thus, to truly stop the func execution one must find a way to observe the same token
            inside the func body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous action to async func that returns a task to await on with an option to
            delegate the action execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).</para>
            </summary>
            <param name="sync">synchronous action method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the action might still be executing.
            Thus, to truly stop the action execution one must find a way to observe the same token
            inside the action body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous func to async func that returns a typed-task to await on with an option to
            delegate the func execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>).</para>
            </summary>
            <param name="sync">synchronous func method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the func might still be executing.
            Thus, to truly stop the func execution one must find a way to observe the same token
            inside the func body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous action to async func that returns a task to await on with an option to
            delegate the action execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).</para>
            </summary>
            <param name="sync">synchronous action method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the action might still be executing.
            Thus, to truly stop the action execution one must find a way to observe the same token
            inside the action body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous func to async func that returns a typed-task to await on with an option to
            delegate the func execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>).</para>
            </summary>
            <param name="sync">synchronous func method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the func might still be executing.
            Thus, to truly stop the func execution one must find a way to observe the same token
            inside the func body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous action to async func that returns a task to await on with an option to
            delegate the action execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).</para>
            </summary>
            <param name="sync">synchronous action method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the action might still be executing.
            Thus, to truly stop the action execution one must find a way to observe the same token
            inside the action body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous func to async func that returns a typed-task to await on with an option to
            delegate the func execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>).</para>
            </summary>
            <param name="sync">synchronous func method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the func might still be executing.
            Thus, to truly stop the func execution one must find a way to observe the same token
            inside the func body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous action to async func that returns a task to await on with an option to
            delegate the action execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).</para>
            </summary>
            <param name="sync">synchronous action method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the action might still be executing.
            Thus, to truly stop the action execution one must find a way to observe the same token
            inside the action body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ToAsync``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Threading.CancellationToken)">
            <summary>
            Converts a synchronous func to async func that returns a typed-task to await on with an option to
            delegate the func execution as a separate new task.
            <para>NOTE: When <paramref name="runAsync"/> is set to true and <paramref name="token"/> is not supplied
            calling this function simply returns a newly running task (<seealso cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>).</para>
            </summary>
            <param name="sync">synchronous func method</param>
            <param name="runAsync">when true, delegate executes in a new task. When false a task containing the results
            is returned, i.e. <paramref name="sync"/> executes inline no matter when the returned task is awaited.</param>
            <param name="options">Options to use when <paramref name="runAsync"/> is set to true and cancelable token is supplied else options
            are ignored.</param>
            <param name="token">cancellation token to observe. When the cancellation token is cancelled the task
            yields <seealso cref="T:System.Threading.Tasks.TaskCanceledException"/> but the func might still be executing.
            Thus, to truly stop the func execution one must find a way to observe the same token
            inside the func body by other means.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ExecuteErrorWrapped(System.Action,System.Action{System.Exception})">
            <summary>
            Executes the <paramref name="lambdaToExecute"/> inside try and passes the caught exception to <paramref name="errorHandler"/>.
            </summary>
            <param name="lambdaToExecute">Action sync Lambda</param>
            <param name="errorHandler">Error handler</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ExecuteErrorWrapped``1(System.Func{``0},System.Func{System.Exception,``0})">
            <summary>
            Executes the <paramref name="lambdaToExecute"/> inside try and passes the caught exception to <paramref name="errorHandler"/>.
            </summary>
            <param name="lambdaToExecute">Func sync Lambda</param>
            <param name="errorHandler">Error handler</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ExecuteErrorWrappedAsync(System.Func{System.Threading.Tasks.Task},System.Action{System.Exception})">
            <summary>
            Executes the <paramref name="lambdaToExecute"/> inside try and passes the caught exception to <paramref name="errorHandler"/>.
            </summary>
            <param name="lambdaToExecute">Func async Lambda</param>
            <param name="errorHandler">Error handler</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ExecuteErrorWrappedAsync``1(System.Func{System.Threading.Tasks.Task{``0}},System.Func{System.Exception,``0})">
            <summary>
            Executes the <paramref name="lambdaToExecute"/> inside try and passes the caught exception to <paramref name="errorHandler"/>.
            </summary>
            <param name="lambdaToExecute">Func async Lambda</param>
            <param name="errorHandler">Error handler</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ErrorWrapper(System.Action,System.Action{System.Exception})">
            <summary>
            Returns a new sync lambda which executes given lambda inside try-catch and passes any exception
            to error handler.
            </summary>
            <param name="lambdaToExecute">Sync lambda to execute inside try-catch</param>
            <param name="errorHandler">Error handler to call in case of error.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ErrorWrapper``1(System.Func{``0},System.Func{System.Exception,``0})">
            <summary>
            Returns a new sync lambda which executes given lambda inside try-catch and passes any exception
            to error handler.
            </summary>
            <param name="lambdaToExecute">Sync lambda to execute inside try-catch</param>
            <param name="errorHandler">Error handler to call in case of error.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ErrorWrapper(System.Func{System.Threading.Tasks.Task},System.Action{System.Exception})">
            <summary>
            Returns a new async lambda which executes given lambda inside try-catch and passes any exception
            to error handler.
            </summary>
            <param name="lambdaToExecute">Async lambda to execute inside try-catch</param>
            <param name="errorHandler">Error handler to call in case of error.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.ErrorWrapper``1(System.Func{System.Threading.Tasks.Task{``0}},System.Func{System.Exception,``0})">
            <summary>
            Returns a new async lambda which executes given lambda inside try-catch and passes any exception
            to error handler.
            </summary>
            <param name="lambdaToExecute">Async lambda to execute inside try-catch</param>
            <param name="errorHandler">Error handler to call in case of error.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.SyncAsync.AsTaskResultAsync``1(``0)">
            <summary>
            Converts the given object to result of an awaitable task.
            </summary>
            <typeparam name="T">Result Type</typeparam>
            <param name="obj">instance</param>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.TaskExts">
            <summary>
            Extension class that contains methods on Tasks
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.TaskExts.WhenAll(System.Action{System.Int32,System.Threading.CancellationToken},System.Int32,System.Threading.CancellationToken)">
            <summary>
            Creates and returns a wrapped task that awaits on all concurrent tasks created by repeatatively (as specified by <paramref name="repeatCount"/>)
            executing the given <paramref name="action"/>.
            </summary>
            <param name="action">action to repeat. The first <seealso cref="T:System.Int32"/> argument is the 0-based index of repeatation loop</param>
            <param name="repeatCount">number of times <paramref name="action"/> needs to be repeated (possible min value: 1)</param>
            <param name="token">Cancellation token, if any. This cancellation token is passed to <paramref name="action"/></param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.TaskExts.WhenAll(System.Func{System.Int32,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Int32,System.Threading.CancellationToken)">
            <summary>
            Creates and returns a wrapped task that awaits on all consurrent tasks created by repeatatively (as specified by <paramref name="repeatCount"/>)
            executing the given <paramref name="func"/>.
            </summary>
            <param name="func">function to repeat. The first <seealso cref="T:System.Int32"/> argument is the 0-based index of repeatation loop</param>
            <param name="repeatCount">number of times <paramref name="func"/> needs to be repeated (possible min value: 1)</param>
            <param name="token">Cancellation token, if any. This cancellation token is passed to <paramref name="func"/></param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.TaskExts.WhenAll(System.Collections.Generic.IEnumerable{System.Action{System.Threading.CancellationToken}},System.Int32,System.Threading.CancellationToken,System.Boolean,System.Action{System.Exception})">
            <summary>
            Creates and returns a wrapped task that awaits on tasks generated during enumeration on <paramref name="actions"/> while respecting the
            concurrency as specified by <paramref name="maxConcurrency"/> (i.e. at no time, enumeration will span more tasks
            then specified by <paramref name="maxConcurrency"/>).
            <para>NOTE: Internally no measures are taken against exceptions raised by the passed delegates, thus, it is important to
            understand the usage of <paramref name="errorHandler"/>.</para>
            </summary>
            <param name="actions">collection of actions to execute and await on</param>
            <param name="maxConcurrency">maximum number of task to span (possible min value: 1)</param>
            <param name="token">Cancellation token, if any. This cancellation token is passed to <paramref name="actions"/>.
            (Note: <seealso cref="T:System.OperationCanceledException"/> will be thrown back on await of task and will not be passed 
            to <paramref name="errorHandler"/>)</param>
            <param name="stopOnCancel">If true, when token is canceled, enumeration loop will stop as soon as possible 
            (i.e. all the running tasks will be awaited but no new task will be created) and <seealso cref="T:System.OperationCanceledException"/>
            will be raised. If false, enumeration would continue irrespective of token state.</param>
            <param name="errorHandler">If errorHandler is passed and an exception occurs during the execution of these tasks, then
            the exception will be passed to it and enumeration would continue. If error handler not passed, then that perticular
            concurrent enumeration would stop (i.e. concurrency would reduce by 1, but remaining delegates would be executed by other
            concurrent enumerations). Thus, if N (N = <paramref name="maxConcurrency"/>) such exceptions occurs, then all enumerations 
            would stop. In any case, if <paramref name="errorHandler"/> is not supplied and at least one exception occurs
            then the await on this task would yield in exception, irrespective of the state of the those concurrent enumerations.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.TaskExts.WhenAll(System.Collections.Generic.IEnumerable{System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task}},System.Int32,System.Threading.CancellationToken,System.Boolean,System.Action{System.Exception})">
            <summary>
            Creates and returns a wrapped task that awaits on tasks generated during enumeration on <paramref name="funcs"/> while respecting the
            concurrency as specified by <paramref name="maxConcurrency"/> (i.e. at no time, enumeration will span more tasks
            then specified by <paramref name="maxConcurrency"/>).
            <para>NOTE: Internally no measures are taken against exceptions raised by the passed delegates, thus, it is important to
            understand the usage of <paramref name="errorHandler"/>.</para>
            </summary>
            <param name="funcs">collection of functions to execute and await on</param>
            <param name="maxConcurrency">maximum number of task to span (possible min value: 1)</param>
            <param name="token">Cancellation token, if any. This cancellation token is passed to <paramref name="funcs"/>.
            (Note: <seealso cref="T:System.OperationCanceledException"/> will be thrown back on await of task and will not be passed 
            to <paramref name="errorHandler"/>)</param>
            <param name="stopOnCancel">If true, when token is canceled, enumeration loop will stop as soon as possible 
            (i.e. all the running tasks will be awaited but no new task will be created) and <seealso cref="T:System.OperationCanceledException"/>
            will be raised. If false, enumeration would continue irrespective of token state.
            </param>
            <param name="errorHandler">If errorHandler is passed and an exception occurs during the execution of these tasks, then
            the exception will be passed to it and enumeration would continue. If error handler not passed, then that perticular
            concurrent enumeration would stop (i.e. concurrency would reduce by 1, but remaining delegates would be executed by other
            concurrent enumerations). Thus, if N (N = <paramref name="maxConcurrency"/>) such exceptions occurs, then all enumerations 
            would stop. In any case, if <paramref name="errorHandler"/> is not supplied and at least one exception occurs
            then the await on this task would yield in exception, irrespective of the state of the those concurrent enumerations.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.TaskExts.WhenAll(System.Collections.Generic.IEnumerable{System.Action},System.Int32,System.Threading.CancellationToken,System.Action{System.Exception})">
            <summary>
            Creates and returns a wrapped task that awaits on tasks generated during enumeration on <paramref name="actions"/> while respecting the
            concurrency as specified by <paramref name="maxConcurrency"/> (i.e. at no time, enumeration will span more tasks
            then specified by <paramref name="maxConcurrency"/>).
            <para>NOTE: Internally no measures are taken against exceptions raised by the passed delegates, thus, it is important to
            understand the usage of <paramref name="errorHandler"/>.</para>
            </summary>
            <param name="actions">collection of actions to execute and await on</param>
            <param name="maxConcurrency">maximum number of task to span (possible min value: 1)</param>
            <param name="token">Token to observe. When token is canceled, enumeration loop will stop as soon as possible 
            (i.e. all the running tasks will be awaited but no new task will be created) and <seealso cref="T:System.OperationCanceledException"/>
            will be raised (Note: This error will be thrown back on await of task and will not be passed to <paramref name="errorHandler"/>)</param>
            <param name="errorHandler">If errorHandler is passed and an exception occurs during the execution of these tasks, then
            the exception will be passed to it and enumeration would continue. If error handler not passed, then that perticular
            concurrent enumeration would stop (i.e. concurrency would reduce by 1, but remaining delegates would be executed by other
            concurrent enumerations). Thus, if N (N = <paramref name="maxConcurrency"/>) such exceptions occurs, then all enumerations 
            would stop. In any case, if <paramref name="errorHandler"/> is not supplied and at least one exception occurs
            then the await on this task would yield in exception, irrespective of the state of the those concurrent enumerations.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.TaskExts.WhenAll(System.Collections.Generic.IEnumerable{System.Func{System.Threading.Tasks.Task}},System.Int32,System.Threading.CancellationToken,System.Action{System.Exception})">
            <summary>
            Creates and returns a wrapped task that awaits on tasks generated during enumeration on <paramref name="funcs"/> while respecting the
            concurrency as specified by <paramref name="maxConcurrency"/> (i.e. at no time, enumeration will span more tasks
            then specified by <paramref name="maxConcurrency"/>).
            <para>NOTE: Internally no measures are taken against exceptions raised by the passed delegates, thus, it is important to
            understand the usage of <paramref name="errorHandler"/>.</para>
            </summary>
            <param name="funcs">collection of functions to execute and await on</param>
            <param name="maxConcurrency">maximum number of task to span (possible min value: 1)</param>
            <param name="token">Token to observe. When token is canceled, enumeration loop will stop as soon as possible 
            (i.e. all the running tasks will be awaited but no new task will be created) and <seealso cref="T:System.OperationCanceledException"/>
            will be raised (Note: This error will be thrown back on await of task and will not be passed to <paramref name="errorHandler"/>)</param>
            <param name="errorHandler">If errorHandler is passed and an exception occurs during the execution of these tasks, then
            the exception will be passed to it and enumeration would continue. If error handler not passed, then that perticular
            concurrent enumeration would stop (i.e. concurrency would reduce by 1, but remaining delegates would be executed by other
            concurrent enumerations). Thus, if N (N = <paramref name="maxConcurrency"/>) such exceptions occurs, then all enumerations 
            would stop. In any case, if <paramref name="errorHandler"/> is not supplied and at least one exception occurs
            then the await on this task would yield in exception, irrespective of the state of the those concurrent enumerations.</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.TaskExts.StartIfNeeded``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Starts the given task if not already started. Returns it back after starting for chaining or awaiting.
            </summary>
            <typeparam name="T">Task param type</typeparam>
            <param name="task">Task to start</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.TaskExts.StartIfNeeded(System.Threading.Tasks.Task)">
            <summary>
            Starts the given task if not already started. Returns it back after starting for chaining or awaiting.
            </summary>
            <param name="task">Task to start</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.TaskExts.AwaitNDispose(System.Threading.Tasks.Task,System.IDisposable)">
            <summary>
            Awaits on the given task and once task finishes (irrespective of its state), disposes
            the given disposable instance. Runs everything as a new task.
            </summary>
            <param name="awaitOn">Task to await on. If not started, then it will started before it is awaited on.</param>
            <param name="disposeIt">Disposable instance</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.TaskExts.AwaitNDispose(System.Threading.Tasks.Task,System.IAsyncDisposable)">
            <summary>
            Awaits on the given task and once task finishes (irrespective of its state), disposes
            the given disposable instance. Runs everything as a new task.
            </summary>
            <param name="awaitOn">Task to await on. If not started, then it will started before it is awaited on.</param>
            <param name="disposeIt">Disposable instance</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.TaskExts.AwaitNDisposeAsync(System.Threading.Tasks.Task,System.IDisposable)">
            <summary>
            Awaits on the given task and once task finishes (irrespective of its state), disposes
            the given disposable instance. New task is NOT created.
            </summary>
            <param name="awaitOn">Task to await on. If not started, then it will started before it is awaited on.</param>
            <param name="disposeIt">Disposable instance</param>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.TaskExts.AwaitNDisposeAsync(System.Threading.Tasks.Task,System.IAsyncDisposable)">
            <summary>
            Awaits on the given task and once task finishes (irrespective of its state), disposes
            the given disposable instance. New task is NOT created.
            </summary>
            <param name="awaitOn">Task to await on. If not started, then it will started before it is awaited on.</param>
            <param name="disposeIt">Disposable instance</param>
        </member>
        <member name="T:Dot.Net.DevFast.Extensions.ThrowIfPredicate">
            <summary>
            Extension library to produce conditional error based on a predicate
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIf``1(System.Boolean,Dot.Net.DevFast.Etc.DdnDfErrorCode,``0)">
            <summary>
            Throws exception when <paramref name="truthValue"/> is true.
            </summary>
            <param name="truthValue">truth value</param>
            <param name="errorCode">error code of the exception</param>
            <param name="obj">Object to return if condition is false</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException"></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIf``1(System.Boolean,Dot.Net.DevFast.Etc.DdnDfErrorCode,System.String,``0)">
            <summary>
            Throws exception when <paramref name="truthValue"/> is true.
            </summary>
            <param name="truthValue">truth value</param>
            <param name="errorCode">error code of the exception</param>
            <param name="errorMessage">Error message</param>
            <param name="obj">Object to return if condition is false</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException"></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIf``1(System.Boolean,Dot.Net.DevFast.Etc.DdnDfErrorCode,System.Func{System.String},``0)">
            <summary>
            Throws exception when <paramref name="truthValue"/> is true.
            </summary>
            <param name="truthValue">truth value</param>
            <param name="errorCode">error code of the exception</param>
            <param name="errorMessageDelegate">Error message delegate</param>
            <param name="obj">Object to return if condition is false</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException"></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNot``1(System.Boolean,Dot.Net.DevFast.Etc.DdnDfErrorCode,``0)">
            <summary>
            Throws exception when <paramref name="truthValue"/> is false.
            </summary>
            <param name="truthValue">truth value</param>
            <param name="errorCode">error code of the exception</param>
            <param name="obj">Object to return if condition is true</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException"></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNot``1(System.Boolean,Dot.Net.DevFast.Etc.DdnDfErrorCode,System.String,``0)">
            <summary>
            Throws exception when <paramref name="truthValue"/> is false.
            </summary>
            <param name="truthValue">truth value</param>
            <param name="errorCode">error code of the exception</param>
            <param name="errorMessage">Error message</param>
            <param name="obj">Object to return if condition is true</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException"></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNot``1(System.Boolean,Dot.Net.DevFast.Etc.DdnDfErrorCode,System.Func{System.String},``0)">
            <summary>
            Throws exception when <paramref name="truthValue"/> is false.
            </summary>
            <param name="truthValue">truth value</param>
            <param name="errorCode">error code of the exception</param>
            <param name="errorMessageDelegate">Error message delegate</param>
            <param name="obj">Object to return if condition is true</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException"></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNull``1(``0)">
            <summary>
            Throws exception when provided object is null else same object instance is returned
            to performed method chaining.
            </summary>
            <typeparam name="T">Any reference type</typeparam>
            <param name="obj">instance</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.NullObject"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNull``1(``0,System.String)">
            <summary>
            Throws exception when provided object is null else same object instance is returned
            to performed method chaining.
            </summary>
            <typeparam name="T">Any reference type</typeparam>
            <param name="obj">instance</param>
            <param name="errorMessage">error message of the exception</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.NullObject"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNull``1(``0,System.Func{System.String})">
            <summary>
            Throws exception when provided object is null else same object instance is returned
            to performed method chaining.
            </summary>
            <typeparam name="T">Any reference type</typeparam>
            <param name="obj">instance</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.NullObject"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNullOrEmpty(System.String)">
            <summary>
            Throws error if the string is empty or contains only whitespaces
            else returns the original string value.
            </summary>
            <param name="val">Val to check</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.EmptyOrWhiteSpacedString"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNullOrEmpty(System.String,System.String)">
            <summary>
            Throws error if the string is empty or contains only whitespaces
            else returns the original string value.
            </summary>
            <param name="val">Val to check</param>
            <param name="errorMessage">Error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.EmptyOrWhiteSpacedString"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNullOrEmpty(System.String,System.Func{System.String})">
            <summary>
            Throws error if the string is empty or contains only whitespaces
            else returns the original string value.
            </summary>
            <param name="val">Val to check</param>
            <param name="errorMessageDelegate">Error message delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.EmptyOrWhiteSpacedString"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNullOrEmpty``1(``0)">
            <summary>
            Throws exception when provided array is either null or empty. Same object instance is returned
            to performed method chaining.
            </summary>
            <typeparam name="T">Collection type</typeparam>
            <param name="obj">instance</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.NullOrEmptyCollection"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNullOrEmpty``1(``0,System.String)">
            <summary>
            Throws exception when provided array is either null or empty. Same object instance is returned
            to performed method chaining.
            </summary>
            <typeparam name="T">Collection type</typeparam>
            <param name="obj">instance</param>
            <param name="errorMessage">error message of the exception</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.NullOrEmptyCollection"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNullOrEmpty``1(``0,System.Func{System.String})">
            <summary>
            Throws exception when provided array is either null or empty. Same object instance is returned
            to performed method chaining.
            </summary>
            <typeparam name="T">Collection type</typeparam>
            <param name="obj">instance</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.NullOrEmptyCollection"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(``0,``1)">
            <summary>
            Throws exception when provided value is not in the collection. Else collection instance is returned
            to performed method chaining.
            </summary>
            <typeparam name="T">Collection type</typeparam>
            <typeparam name="TV">Generic param type of the Collection</typeparam>
            <param name="collection">collection instance</param>
            <param name="lookUpValue">look up value instance</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotInCollection"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(``0,``1,System.String)">
            <summary>
            Throws exception when provided value is not in the collection. Else collection instance is returned
            to performed method chaining.
            </summary>
            <typeparam name="T">Array type</typeparam>
            <typeparam name="TV">Generic param type of the Collection</typeparam>
            <param name="collection">collection instance</param>
            <param name="lookUpValue">look up value instance</param>
            <param name="errorMessage">error message of the exception</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotInCollection"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(``0,``1,System.Func{System.String})">
            <summary>
            Throws exception when provided value not ont in the collection. Else collection instance is returned
            to performed method chaining.
            </summary>
            <typeparam name="T">Array type</typeparam>
            <typeparam name="TV">Generic param type of the Collection</typeparam>
            <param name="collection">collection instance</param>
            <param name="lookUpValue">look up value instance</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotInCollection"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
            Throws exception when provided key is not found in dictionary. Else associated value instance is returned
            to performed method chaining on the value.
            </summary>
            <typeparam name="TK">Type of key of the dictionary</typeparam>
            <typeparam name="TV">Type of value of the dictionary</typeparam>
            <param name="dictionary">dictionary instance</param>
            <param name="key">key instance</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.KeyNotFound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.String)">
            <summary>
            Throws exception when provided key is not found in dictionary. Else associated value instance is returned
            to performed method chaining on the value.
            </summary>
            <typeparam name="TK">Type of key of the dictionary</typeparam>
            <typeparam name="TV">Type of value of the dictionary</typeparam>
            <param name="dictionary">dictionary instance</param>
            <param name="key">key instance</param>
            <param name="errorMessage">error message of the exception</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.KeyNotFound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Func{System.String})">
            <summary>
            Throws exception when provided key is not found in dictionary. Else associated value instance is returned
            to performed method chaining on the value.
            </summary>
            <typeparam name="TK">Type of key of the dictionary</typeparam>
            <typeparam name="TV">Type of value of the dictionary</typeparam>
            <param name="dictionary">dictionary instance</param>
            <param name="key">key instance</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.KeyNotFound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0)">
            <summary>
            Throws exception when provided key is not found in dictionary. Else associated value instance is returned
            to performed method chaining on the value.
            </summary>
            <typeparam name="TK">Type of key of the dictionary</typeparam>
            <typeparam name="TV">Type of value of the dictionary</typeparam>
            <param name="dictionary">dictionary instance</param>
            <param name="key">key instance</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.KeyNotFound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0,System.String)">
            <summary>
            Throws exception when provided key is not found in dictionary. Else associated value instance is returned
            to performed method chaining on the value.
            </summary>
            <typeparam name="TK">Type of key of the dictionary</typeparam>
            <typeparam name="TV">Type of value of the dictionary</typeparam>
            <param name="dictionary">dictionary instance</param>
            <param name="key">key instance</param>
            <param name="errorMessage">error message of the exception</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.KeyNotFound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0,System.Func{System.String})">
            <summary>
            Throws exception when provided key is not found in dictionary. Else associated value instance is returned
            to performed method chaining on the value.
            </summary>
            <typeparam name="TK">Type of key of the dictionary</typeparam>
            <typeparam name="TV">Type of value of the dictionary</typeparam>
            <param name="dictionary">dictionary instance</param>
            <param name="key">key instance</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.KeyNotFound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(Dot.Net.DevFast.Collections.Concurrent.FastDictionary{``0,``1},``0)">
            <summary>
            Throws exception when provided key is not found in dictionary. Else associated value instance is returned
            to performed method chaining on the value.
            </summary>
            <typeparam name="TK">Type of key of the dictionary</typeparam>
            <typeparam name="TV">Type of value of the dictionary</typeparam>
            <param name="dictionary">dictionary instance</param>
            <param name="key">key instance</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.KeyNotFound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(Dot.Net.DevFast.Collections.Concurrent.FastDictionary{``0,``1},``0,System.String)">
            <summary>
            Throws exception when provided key is not found in dictionary. Else associated value instance is returned
            to performed method chaining on the value.
            </summary>
            <typeparam name="TK">Type of key of the dictionary</typeparam>
            <typeparam name="TV">Type of value of the dictionary</typeparam>
            <param name="dictionary">dictionary instance</param>
            <param name="key">key instance</param>
            <param name="errorMessage">error message of the exception</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.KeyNotFound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(Dot.Net.DevFast.Collections.Concurrent.FastDictionary{``0,``1},``0,System.Func{System.String})">
            <summary>
            Throws exception when provided key is not found in dictionary. Else associated value instance is returned
            to performed method chaining on the value.
            </summary>
            <typeparam name="TK">Type of key of the dictionary</typeparam>
            <typeparam name="TV">Type of value of the dictionary</typeparam>
            <param name="dictionary">dictionary instance</param>
            <param name="key">key instance</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.KeyNotFound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Throws exception when provided key is not found in dictionary. Else associated value instance is returned
            to performed method chaining on the value.
            </summary>
            <typeparam name="TK">Type of key of the dictionary</typeparam>
            <typeparam name="TV">Type of value of the dictionary</typeparam>
            <param name="dictionary">dictionary instance</param>
            <param name="key">key instance</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.KeyNotFound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.String)">
            <summary>
            Throws exception when provided key is not found in dictionary. Else associated value instance is returned
            to performed method chaining on the value.
            </summary>
            <typeparam name="TK">Type of key of the dictionary</typeparam>
            <typeparam name="TV">Type of value of the dictionary</typeparam>
            <param name="dictionary">dictionary instance</param>
            <param name="key">key instance</param>
            <param name="errorMessage">error message of the exception</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.KeyNotFound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{System.String})">
            <summary>
            Throws exception when provided key is not found in dictionary. Else associated value instance is returned
            to performed method chaining on the value.
            </summary>
            <typeparam name="TK">Type of key of the dictionary</typeparam>
            <typeparam name="TV">Type of value of the dictionary</typeparam>
            <param name="dictionary">dictionary instance</param>
            <param name="key">key instance</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.KeyNotFound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},``0)">
            <summary>
            Throws exception when provided key is not found in dictionary. Else associated value instance is returned
            to performed method chaining on the value.
            </summary>
            <typeparam name="TK">Type of key of the dictionary</typeparam>
            <typeparam name="TV">Type of value of the dictionary</typeparam>
            <param name="dictionary">dictionary instance</param>
            <param name="key">key instance</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.KeyNotFound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},``0,System.String)">
            <summary>
            Throws exception when provided key is not found in dictionary. Else associated value instance is returned
            to performed method chaining on the value.
            </summary>
            <typeparam name="TK">Type of key of the dictionary</typeparam>
            <typeparam name="TV">Type of value of the dictionary</typeparam>
            <param name="dictionary">dictionary instance</param>
            <param name="key">key instance</param>
            <param name="errorMessage">error message of the exception</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.KeyNotFound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowOnMiss``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},``0,System.Func{System.String})">
            <summary>
            Throws exception when provided key is not found in dictionary. Else associated value instance is returned
            to performed method chaining on the value.
            </summary>
            <typeparam name="TK">Type of key of the dictionary</typeparam>
            <typeparam name="TV">Type of value of the dictionary</typeparam>
            <param name="dictionary">dictionary instance</param>
            <param name="key">key instance</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.KeyNotFound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfZero(System.Int32)">
            <summary>
            Throws exception when given value is 0.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfZero(System.Int32,System.String)">
            <summary>
            Throws exception when given value is 0.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfZero(System.Int32,System.Func{System.String})">
            <summary>
            Throws exception when given value is 0.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotZero(System.Int32)">
            <summary>
            Throws exception when given value is NOT 0.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotZero(System.Int32,System.String)">
            <summary>
            Throws exception when given value is NOT 0.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotZero(System.Int32,System.Func{System.String})">
            <summary>
            Throws exception when given value is NOT 0.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfEqual(System.Int32,System.Int32)">
            <summary>
            Throws exception when <paramref name="value"/>==<paramref name="comperand"/>.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfEqual(System.Int32,System.Int32,System.String)">
            <summary>
            Throws exception when <paramref name="value"/>==<paramref name="comperand"/>.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfEqual(System.Int32,System.Int32,System.Func{System.String})">
            <summary>
            Throws exception when <paramref name="value"/>==<paramref name="comperand"/>.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotEqual(System.Int32,System.Int32)">
            <summary>
            Throws exception when <paramref name="value"/> != <paramref name="comperand"/>.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotEqual(System.Int32,System.Int32,System.String)">
            <summary>
            Throws exception when <paramref name="value"/> != <paramref name="comperand"/>.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotEqual(System.Int32,System.Int32,System.Func{System.String})">
            <summary>
            Throws exception when <paramref name="value"/> != <paramref name="comperand"/>.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNegative(System.Int32)">
            <summary>
            Throws exception when given value is strictly less than 0 (-1 onwards).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueLessThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNegative(System.Int32,System.String)">
            <summary>
            Throws exception when given value is strictly less than 0 (-1 onwards).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueLessThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNegative(System.Int32,System.Func{System.String})">
            <summary>
            Throws exception when given value is strictly less than 0 (-1 onwards).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueLessThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfLess(System.Int32,System.Int32)">
            <summary>
            Throws exception when given comparable value is strictly less than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value instance to compare</param>
            <param name="threshold">Threshold value of comparison</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueLessThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfLess(System.Int32,System.Int32,System.String)">
            <summary>
            Throws exception when given comparable value is strictly less than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="threshold">Threshold value of comparison</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueLessThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfLess(System.Int32,System.Int32,System.Func{System.String})">
            <summary>
            Throws exception when given comparable value is strictly less than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="threshold">Threshold value of comparison</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueLessThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfPositive(System.Int32)">
            <summary>
            Throws exception when given value is strictly greater than 0 (+1 onwards).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueGreaterThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfPositive(System.Int32,System.String)">
            <summary>
            Throws exception when given value is strictly greater than 0 (+1 onwards).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueGreaterThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfPositive(System.Int32,System.Func{System.String})">
            <summary>
            Throws exception when given value is strictly greater than 0 (+1 onwards).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueGreaterThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfGreater(System.Int32,System.Int32)">
            <summary>
            Throws exception when given comparable value is strictly greater than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="threshold">Threshold value of comparison</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueGreaterThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfGreater(System.Int32,System.Int32,System.String)">
            <summary>
            Throws exception when given comparable value is strictly greater than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="threshold">Threshold value of comparison</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueGreaterThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfGreater(System.Int32,System.Int32,System.Func{System.String})">
            <summary>
            Throws exception when given comparable value is strictly greater than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="threshold">Threshold value of comparison</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueGreaterThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfZero(System.Int64)">
            <summary>
            Throws exception when given value is 0.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfZero(System.Int64,System.String)">
            <summary>
            Throws exception when given value is 0.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfZero(System.Int64,System.Func{System.String})">
            <summary>
            Throws exception when given value is 0.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfEqual(System.Int64,System.Int64)">
            <summary>
            Throws exception when <paramref name="value"/>==<paramref name="comperand"/>.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfEqual(System.Int64,System.Int64,System.String)">
            <summary>
            Throws exception when <paramref name="value"/>==<paramref name="comperand"/>.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfEqual(System.Int64,System.Int64,System.Func{System.String})">
            <summary>
            Throws exception when <paramref name="value"/>==<paramref name="comperand"/>.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotZero(System.Int64)">
            <summary>
            Throws exception when given value is NOT 0.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotZero(System.Int64,System.String)">
            <summary>
            Throws exception when given value is NOT 0.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotZero(System.Int64,System.Func{System.String})">
            <summary>
            Throws exception when given value is NOT 0.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotEqual(System.Int64,System.Int64)">
            <summary>
            Throws exception when <paramref name="value"/> != <paramref name="comperand"/>.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotEqual(System.Int64,System.Int64,System.String)">
            <summary>
            Throws exception when <paramref name="value"/> != <paramref name="comperand"/>.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotEqual(System.Int64,System.Int64,System.Func{System.String})">
            <summary>
            Throws exception when <paramref name="value"/> != <paramref name="comperand"/>.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNegative(System.Int64)">
            <summary>
            Throws exception when given value is strictly less than 0 (-1 onwards).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueLessThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNegative(System.Int64,System.String)">
            <summary>
            Throws exception when given value is strictly less than 0 (-1 onwards).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueLessThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNegative(System.Int64,System.Func{System.String})">
            <summary>
            Throws exception when given value is strictly less than 0 (-1 onwards).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueLessThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfLess(System.Int64,System.Int64)">
            <summary>
            Throws exception when given comparable value is strictly less than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value instance to compare</param>
            <param name="threshold">Threshold value of comparison</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueLessThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfLess(System.Int64,System.Int64,System.String)">
            <summary>
            Throws exception when given comparable value is strictly less than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="threshold">Threshold value of comparison</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueLessThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfLess(System.Int64,System.Int64,System.Func{System.String})">
            <summary>
            Throws exception when given comparable value is strictly less than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="threshold">Threshold value of comparison</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueLessThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfPositive(System.Int64)">
            <summary>
            Throws exception when given value is strictly greater than 0 (+1 onwards).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueGreaterThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfPositive(System.Int64,System.String)">
            <summary>
            Throws exception when given value is strictly greater than 0 (+1 onwards).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueGreaterThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfPositive(System.Int64,System.Func{System.String})">
            <summary>
            Throws exception when given value is strictly greater than 0 (+1 onwards).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueGreaterThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfGreater(System.Int64,System.Int64)">
            <summary>
            Throws exception when given comparable value is strictly greater than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="threshold">Threshold value of comparison</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueGreaterThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfGreater(System.Int64,System.Int64,System.String)">
            <summary>
            Throws exception when given comparable value is strictly greater than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="threshold">Threshold value of comparison</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueGreaterThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfGreater(System.Int64,System.Int64,System.Func{System.String})">
            <summary>
            Throws exception when given comparable value is strictly greater than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="threshold">Threshold value of comparison</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueGreaterThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfEqual``1(``0,``0)">
            <summary>
            Throws exception when <paramref name="value"/> and <paramref name="comperand"/> are equal.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfEqual``1(``0,``0,System.String)">
            <summary>
            Throws exception when <paramref name="value"/> and <paramref name="comperand"/> are equal.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfEqual``1(``0,``0,System.Func{System.String})">
            <summary>
            Throws exception when <paramref name="value"/> and <paramref name="comperand"/> are equal.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfEqual``1(``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Throws exception when <paramref name="value"/> and <paramref name="comperand"/> are equal.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="comparer">comparer instance</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfEqual``1(``0,``0,System.Collections.Generic.IEqualityComparer{``0},System.String)">
            <summary>
            Throws exception when <paramref name="value"/> and <paramref name="comperand"/> are equal.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="comparer">comparer instance</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfEqual``1(``0,``0,System.Collections.Generic.IEqualityComparer{``0},System.Func{System.String})">
            <summary>
            Throws exception when <paramref name="value"/> and <paramref name="comperand"/> are equal.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="comparer">comparer instance</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotEqual``1(``0,``0)">
            <summary>
            Throws exception when <paramref name="value"/> and <paramref name="comperand"/> are NOT equal.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotEqual``1(``0,``0,System.String)">
            <summary>
            Throws exception when <paramref name="value"/> and <paramref name="comperand"/> are NOT equal.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotEqual``1(``0,``0,System.Func{System.String})">
            <summary>
            Throws exception when <paramref name="value"/> and <paramref name="comperand"/> are NOT equal.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotEqual``1(``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Throws exception when <paramref name="value"/> and <paramref name="comperand"/> are NOT equal.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="comparer">comparer instance</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotEqual``1(``0,``0,System.Collections.Generic.IEqualityComparer{``0},System.String)">
            <summary>
            Throws exception when <paramref name="value"/> and <paramref name="comperand"/> are NOT equal.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="comparer">comparer instance</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotEqual``1(``0,``0,System.Collections.Generic.IEqualityComparer{``0},System.Func{System.String})">
            <summary>
            Throws exception when <paramref name="value"/> and <paramref name="comperand"/> are NOT equal.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="comperand">value to compare to</param>
            <param name="comparer">comparer instance</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueNotEqual"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfLess``1(``0,``0)">
            <summary>
            Throws exception when given comparable value is strictly less than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value instance to compare</param>
            <param name="threshold">Threshold value of comparison</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueLessThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfLess``1(``0,``0,System.String)">
            <summary>
            Throws exception when given comparable value is strictly less than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="threshold">Threshold value of comparison</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueLessThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfLess``1(``0,``0,System.Func{System.String})">
            <summary>
            Throws exception when given comparable value is strictly less than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="threshold">Threshold value of comparison</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueLessThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfGreater``1(``0,``0)">
            <summary>
            Throws exception when given comparable value is strictly greater than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="threshold">Threshold value of comparison</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueGreaterThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfGreater``1(``0,``0,System.String)">
            <summary>
            Throws exception when given comparable value is strictly greater than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="threshold">Threshold value of comparison</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueGreaterThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfGreater``1(``0,``0,System.Func{System.String})">
            <summary>
            Throws exception when given comparable value is strictly greater than given threshold.
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="threshold">Threshold value of comparison</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueGreaterThanThreshold"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotBounded``1(``0,``0,``0)">
            <summary>
            Throws exception when given comparable value is out of bound (both bound exclusive, i.e.,
            throws when <paramref name="value"/> &lt; LowerOfTwoBound OR <paramref name="value"/> &gt; HigherOfTwoBound).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="firstBoundExcl">first bound of comparison</param>
            <param name="secondBoundExcl">second bound of comparison</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueOutOfBound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotBounded``1(``0,``0,``0,System.String)">
            <summary>
            Throws exception when given comparable value is out of bound (both bound exclusive, i.e.,
            throws when <paramref name="value"/> &lt; LowerOfTwoBound OR <paramref name="value"/> &gt; HigherOfTwoBound).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="firstBoundExcl">first bound of comparison</param>
            <param name="secondBoundExcl">second bound of comparison</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueOutOfBound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfNotBounded``1(``0,``0,``0,System.Func{System.String})">
            <summary>
            Throws exception when given comparable value is out of bound (both bound exclusive, i.e.,
            throws when <paramref name="value"/> &lt; LowerOfTwoBound OR <paramref name="value"/> &gt; HigherOfTwoBound).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="firstBoundExcl">first bound of comparison</param>
            <param name="secondBoundExcl">second bound of comparison</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueOutOfBound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfBounded``1(``0,``0,``0)">
            <summary>
            Throws exception when given comparable value is within the bounds (both bound inclusive, i.e.,
            throws when LowerOfTwoBound &lt;= <paramref name="value"/> &lt;= HigherOfTwoBound).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="firstBoundExcl">first bound of comparison</param>
            <param name="secondBoundExcl">second bound of comparison</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueInBound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfBounded``1(``0,``0,``0,System.String)">
            <summary>
            Throws exception when given comparable value is within the bounds (both bound inclusive, i.e.,
            throws when LowerOfTwoBound &lt;= <paramref name="value"/> &lt;= HigherOfTwoBound).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="firstBoundExcl">first bound of comparison</param>
            <param name="secondBoundExcl">second bound of comparison</param>
            <param name="errorMessage">error message</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueInBound"/></exception>
        </member>
        <member name="M:Dot.Net.DevFast.Extensions.ThrowIfPredicate.ThrowIfBounded``1(``0,``0,``0,System.Func{System.String})">
            <summary>
            Throws exception when given comparable value is within the bounds (both bound inclusive, i.e.,
            throws when LowerOfTwoBound &lt;= <paramref name="value"/> &lt;= HigherOfTwoBound).
            Else <paramref name="value"/> is returned to performed method chaining.
            </summary>
            <param name="value">Value to check</param>
            <param name="firstBoundExcl">first bound of comparison</param>
            <param name="secondBoundExcl">second bound of comparison</param>
            <param name="errorMessageDelegate">error message generating delegate</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException">Error code as <seealso cref="F:Dot.Net.DevFast.Etc.DdnDfErrorCode.ValueInBound"/></exception>
        </member>
        <member name="T:Dot.Net.DevFast.IO.BroadcastStream">
            <inheritdoc />
            <summary>
            Stream that can perform concurrent unidirectional write on two underlying streams.
            Normally this implementation is NOT for public exposure.
            It exists specially for streaming APIs to have concurrent writes.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.BroadcastStream.#ctor(Dot.Net.DevFast.IO.PushFuncStream,System.IO.Stream,System.Boolean,System.Action{System.IO.Stream,System.Exception})">
            <inheritdoc />
            <summary>
            Ctor.
            </summary>
            <param name="pfs">Push functional stream to write on.</param>
            <param name="writableStream">Another writable stream</param>
            <param name="disposeWritable">true to dispose <paramref name="writableStream"/> else false.</param>
            <param name="streamErrHandler">Error handler for writable stream</param>
        </member>
        <member name="M:Dot.Net.DevFast.IO.BroadcastStream.Flush">
            <inheritdoc />
            <summary>
            Flushes both streams.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.BroadcastStream.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc />
            <summary>
            Flushes both streams.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.BroadcastStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
            <summary>
            Throws NotImplementedException.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.BroadcastStream.SetLength(System.Int64)">
            <inheritdoc />
            <summary>
            Does nothing
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.BroadcastStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
            <summary>
            Throws NotImplementedException.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.BroadcastStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Dot.Net.DevFast.IO.BroadcastStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="P:Dot.Net.DevFast.IO.BroadcastStream.CanRead">
            <inheritdoc />
            <summary>
            Returns false.
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.IO.BroadcastStream.CanSeek">
            <inheritdoc />
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.IO.BroadcastStream.CanWrite">
            <inheritdoc />
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.IO.BroadcastStream.Length">
            <inheritdoc />
            <summary>
            Returns 0.
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.IO.BroadcastStream.Position">
            <inheritdoc />
            <summary>
            Gets 0, sets nothing
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.BroadcastStream.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Dot.Net.DevFast.IO.IByteCounter">
            <summary>
            Interface to impose the byte countting getter.
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.IO.IByteCounter.ByteCount">
            <summary>
            Count of bytes observed during Streaming operations.
            </summary>
        </member>
        <member name="T:Dot.Net.DevFast.IO.ByteCountStream">
            <inheritdoc cref="T:System.IO.Stream"/>
            <summary>
            Stream implementation that counts the number of BYTEs (exposed by <see cref="P:Dot.Net.DevFast.IO.ByteCountingStream.ByteCount" /> property)
            passed through it. It works as a pass-through stream if another stream is supplied through one of the Ctor.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.ByteCountStream.#ctor(System.IO.Stream,System.Boolean)">
            <inheritdoc />
            <summary>
            Initializes an instance that passes (or reads) all the byte data to (from) inner stream
            and counts the number of bytes it observed.
            <para>If <paramref name="innerStream"/> is NOT supplied then <seealso cref="F:System.IO.Stream.Null"/> will be used internally</para>
            </summary>
            <param name="innerStream">inner stream from which to read or to write. If <paramref name="innerStream"/> is NOT supplied then <seealso cref="F:System.IO.Stream.Null"/> will be used internally.</param>
            <param name="leaveOpen">false to dispose inner or true to leave it open.</param>
        </member>
        <member name="M:Dot.Net.DevFast.IO.ByteCountStream.ResetWith(System.IO.Stream,System.Boolean)">
            <summary>
            This is a workaround to support out param in streaming APIs.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.ByteCountStream.Flush">
            <inheritdoc />
            <summary>
            Calls the <seealso cref="M:System.IO.Stream.Flush"/> on the inner stream.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.ByteCountStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
            <summary>
            Calls the <seealso cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)"/> on the inner stream.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.ByteCountStream.SetLength(System.Int64)">
            <inheritdoc />
            <summary>
            Calls the <seealso cref="M:System.IO.Stream.SetLength(System.Int64)"/> on the inner stream.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.ByteCountStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
            <summary>
            Calls <seealso cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> on the inner stream and counts bytes.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.ByteCountStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
            <summary>
            Calls <seealso cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"/> on the inner stream and counts bytes.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.ByteCountStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
            <summary>
            Calls <seealso cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)"/> on the inner stream and counts bytes.
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.ByteCountStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
            <summary>
            Calls <seealso cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"/> on the inner stream and counts bytes.
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.IO.ByteCountStream.CanRead">
            <inheritdoc />
            <summary>
            Calls the <seealso cref="P:System.IO.Stream.CanRead"/> on the inner stream.
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.IO.ByteCountStream.CanSeek">
            <inheritdoc />
            <summary>
            Calls the <seealso cref="P:System.IO.Stream.CanSeek"/> on the inner stream.
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.IO.ByteCountStream.CanWrite">
            <inheritdoc />
            <summary>
            Calls the <seealso cref="P:System.IO.Stream.CanWrite"/> on the inner stream.
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.IO.ByteCountStream.Length">
            <inheritdoc />
            <summary>
            Calls the <seealso cref="P:System.IO.Stream.Length"/> on the inner stream.
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.IO.ByteCountStream.Position">
            <inheritdoc />
            <summary>
            Calls the <seealso cref="P:System.IO.Stream.Position"/> on the inner stream.
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.IO.ByteCountStream.ByteCount">
            <inheritdoc />
            <summary>
            Count of bytes observed during read/write methods.
            <para>Property remains accessible after dispose.</para>
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.ByteCountStream.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="P:Dot.Net.DevFast.IO.ByteCountStream.InnerStream">
            <summary>
            Gets the associated inner stream.
            </summary>
        </member>
        <member name="T:Dot.Net.DevFast.IO.PullFuncStream">
            <summary>
            Data structure to facilitate Pull based functional streaming,
            i.e., 2ndst Pipe reads from 1st, 3rd reads from 2nd and so on and so forth... /// </summary>
        </member>
        <member name="P:Dot.Net.DevFast.IO.PullFuncStream.Readable">
            <summary>
            Readable stream
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.IO.PullFuncStream.Dispose">
            <summary>
            If true, stream is disposed at the end of streaming else left open
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.PullFuncStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Ctor.
            </summary>
            <param name="readable">readable stream</param>
            <param name="dispose">true to dispose at the end of streaming else false</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException"></exception>
        </member>
        <member name="T:Dot.Net.DevFast.IO.PushFuncStream">
            <summary>
            Data structure to facilitate Push based functional streaming,
            i.e., 1st Pipe writes on 2nd that writes on 3rd and so on and so forth...
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.IO.PushFuncStream.Writable">
            <summary>
            Writable stream
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.IO.PushFuncStream.Dispose">
            <summary>
            If true, stream is disposed at the end of streaming else left open
            </summary>
        </member>
        <member name="P:Dot.Net.DevFast.IO.PushFuncStream.Token">
            <summary>
            Associated Cancellation token
            </summary>
        </member>
        <member name="M:Dot.Net.DevFast.IO.PushFuncStream.#ctor(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Ctor.
            </summary>
            <param name="writable">writable stream</param>
            <param name="dispose">true to dispose at the end of streaming else false</param>
            <param name="token">Cancellation token to observe</param>
            <exception cref="T:Dot.Net.DevFast.Etc.DdnDfException"></exception>
        </member>
    </members>
</doc>
